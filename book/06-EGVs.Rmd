# Ecogeographical variables {#Ch06}

This section names and provides description (R code with its explanation in 
procedure) of every one of the 538 EGVs created.

For better undestanding of the relatedness of these vairable, refer to flowchart below 
(Fig. \@ref(fig:flowchart)). 
Names used in figure correspond to EGV layer names and follow naming convention: 
[group]_[specific name]_[scale], where: 

- group is broader collection of EGVs describing the same fenomena, ecosystem, coming from the same source, etc.;

- specific name shortly describes landscape class and/or metrics used in creation of the layer;

- scale is one of: cell, 500, 1250, 3000, 10000 m around the center of analysis cell. The resolution of every EGV is 1 ha, larger scales are summarised to it.


```{r flowchart, echo=FALSE, out.width = '100%', fig.cap='Relationships of ecogeographical variables created.'}
knitr::include_graphics("./Figures/EGV_FlowChartY_eps_krasains_300dpi_2.png")
```

<br>


In cover fraction and edge variables, we first calculated values at the analysis 
cell resolution and then used {exactextract} to summarise values from larger scales. 
This package uses pixel area weight to calculate weighted summary statistic, thus the 
error created due to aggregation is negligible, particularly at larger scales, but 
reduces computation time thousunds up to even hundreds of thousands times compared 
to input resolution (10 m). To further speed up the procedures, we used "sparse" 
mode in `egvtools::radius_function`, thus summarising zonal statistics every 300 m for 
3000 m radius buffers and every 1000 m for 10000 m buffers, obtaining near linear 
reduction in time relative to the number of zones (nine fold and 100 fold further 
computation time reduction), while loosing less than 0.001 % of variability altogether.

We used slightly different approach with diversity metrics - first we calculated 
Shanons diversity index at 25 ha raster grid cells as there is nearly no variability 
of landscape classes at 1 ha grid cells. Further on we calculated arithmetic mean as 
zonal statictics value ("sparse" mode with `egvtools::radius_function`), but we 
did not create this EGV at the analysis cells scale.


## Climate_CHELSAv2.1-bio1_cell	{#ch06.001}

**filename:** `Climate_CHELSAv2.1-bio1_cell.tif`	

**layername:** `egv_1`	

**English name:** Mean annual daily mean air temperature (°C) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējā ikdienas gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----
localname="Climate_CHELSAv2.1-bio1_cell.tif"
layername="egv_1"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio1_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
nosaukums="Climate_CHELSAv2.1-bio1_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_1.png")
```


## Climate_CHELSAv2.1-bio10_cell	{#ch06.002}

**filename:** `Climate_CHELSAv2.1-bio10_cell.tif`	

**layername:** `egv_2`	

**English name:** Mean daily mean air temperatures (°C) of the warmest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada siltākā ceturkšņa vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio10_cell.tif"
layername="egv_2"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio10_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio10_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_2.png")
```



## Climate_CHELSAv2.1-bio11_cell	{#ch06.003}

**filename:** `Climate_CHELSAv2.1-bio11_cell.tif`	

**layername:** `egv_3`	

**English name:** Mean daily mean air temperatures (°C) of the coldest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada aukstākā ceturkšņa vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio11_cell.tif"
layername="egv_3"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio11_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio11_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_3.png")
```



## Climate_CHELSAv2.1-bio12_cell	{#ch06.004}

**filename:** `Climate_CHELSAv2.1-bio12_cell.tif`	

**layername:** `egv_4`	

**English name:** Annual precipitation amount (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada nokrišņu daudzums (kg m⁻² gadā) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio12_cell.tif"
layername="egv_4"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio12_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio12_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_4.png")
```



## Climate_CHELSAv2.1-bio13_cell	{#ch06.005}

**filename:** `Climate_CHELSAv2.1-bio13_cell.tif`	

**layername:** `egv_5`	

**English name:** Precipitation amount (kg m⁻² month⁻¹) of the wettest month (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Slapjākā mēneša nokrišņu daudzums (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio13_cell.tif"
layername="egv_5"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio13_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio13_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_5.png")
```



## Climate_CHELSAv2.1-bio14_cell	{#ch06.006}

**filename:** `Climate_CHELSAv2.1-bio14_cell.tif`	

**layername:** `egv_6`	

**English name:** Precipitation amount (kg m⁻² month⁻¹) of the driest month (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Sausākā mēneša nokrišņu daudzums (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio14_cell.tif"
layername="egv_6"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio14_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio14_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_6.png")
```



## Climate_CHELSAv2.1-bio15_cell	{#ch06.007}

**filename:** `Climate_CHELSAv2.1-bio15_cell.tif`	

**layername:** `egv_7`	

**English name:** Precipitation seasonality (kg m⁻²) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Nokrišņu sezonalitāte (kg m⁻²) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio15_cell.tif"
layername="egv_7"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio15_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio15_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_7.png")
```



## Climate_CHELSAv2.1-bio16_cell	{#ch06.008}

**filename:** `Climate_CHELSAv2.1-bio16_cell.tif`	

**layername:** `egv_8`	

**English name:** Mean monthly precipitation amount (kg m⁻² month⁻¹) of the wettest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Slapjākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio16_cell.tif"
layername="egv_8"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio16_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio16_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_8.png")
```



## Climate_CHELSAv2.1-bio17_cell	{#ch06.009}

**filename:** `Climate_CHELSAv2.1-bio17_cell.tif`	

**layername:** `egv_9`	

**English name:** Mean monthly precipitation amount (kg m⁻² month⁻¹) of the driest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Sausākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio17_cell.tif"
layername="egv_9"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio17_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio17_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_9.png")
```



## Climate_CHELSAv2.1-bio18_cell	{#ch06.010}

**filename:** `Climate_CHELSAv2.1-bio18_cell.tif`	

**layername:** `egv_10`	

**English name:** Mean monthly precipitation amount (kg m⁻² month⁻¹) of the warmest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Siltākā ceturkšņa vidējais nokrišņu daudzuma mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio18_cell.tif"
layername="egv_10"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio18_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio18_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_10.png")
```



## Climate_CHELSAv2.1-bio19_cell	{#ch06.011}

**filename:** `Climate_CHELSAv2.1-bio19_cell.tif`	

**layername:** `egv_11`	

**English name:** Mean monthly precipitation amount (kg m⁻² month⁻¹) of the coldest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Aukstākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio19_cell.tif"
layername="egv_11"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio19_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio19_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_11.png")
```



## Climate_CHELSAv2.1-bio2_cell	{#ch06.012}

**filename:** `Climate_CHELSAv2.1-bio2_cell.tif`	

**layername:** `egv_12`	

**English name:** Mean diurnal air temperature range (°C) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Diennakts temperatūru amplitūda (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio2_cell.tif"
layername="egv_12"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio2_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio2_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_12.png")
```



## Climate_CHELSAv2.1-bio3_cell	{#ch06.013}

**filename:** `Climate_CHELSAv2.1-bio3_cell.tif`	

**layername:** `egv_13`	

**English name:** Isothermality (ratio of diurnal variation to annual variation in temperatures) (°C) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Izotermalitāte (attiecība starp diennakts un gada temperatūras svārstībām) (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio3_cell.tif"
layername="egv_13"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio3_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio3_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_13.png")
```



## Climate_CHELSAv2.1-bio4_cell	{#ch06.014}

**filename:** `Climate_CHELSAv2.1-bio4_cell.tif`	

**layername:** `egv_14`	

**English name:** Temperature seasonality (standard deviation of the monthly mean temperatures) (°C/100) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Temperatūru sezonalitāte (mēneša vidējo temperatūru standartnovirze) (°C/100) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio4_cell.tif"
layername="egv_14"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio4_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio4_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_14.png")
```



## Climate_CHELSAv2.1-bio5_cell	{#ch06.015}

**filename:** `Climate_CHELSAv2.1-bio5_cell.tif`	

**layername:** `egv_15`	

**English name:** Mean daily maximum air temperature (°C) of the warmest month (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Siltākā mēneša vidējā ikdienas augstākā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio5_cell.tif"
layername="egv_15"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio5_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio5_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_15.png")
```



## Climate_CHELSAv2.1-bio6_cell	{#ch06.016}

**filename:** `Climate_CHELSAv2.1-bio6_cell.tif`	

**layername:** `egv_16`	

**English name:** Mean daily minimum air temperature (°C) of the coldest month (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Aukstākā mēneša vidējā ikdienas zemākā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio6_cell.tif"
layername="egv_16"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio6_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio6_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_16.png")
```



## Climate_CHELSAv2.1-bio7_cell	{#ch06.017}

**filename:** `Climate_CHELSAv2.1-bio7_cell.tif`	

**layername:** `egv_17`	

**English name:** Annual range of air temperature (°C) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada temperatūru amplitūda (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio7_cell.tif"
layername="egv_17"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio7_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio7_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_17.png")
```



## Climate_CHELSAv2.1-bio8_cell	{#ch06.018}

**filename:** `Climate_CHELSAv2.1-bio8_cell.tif`	

**layername:** `egv_18`	

**English name:** Mean daily mean air temperatures (°C) of the wettest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Slapjākā ceturkšņa vidējā ikdienas vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio8_cell.tif"
layername="egv_18"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio8_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio8_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_18.png")
```



## Climate_CHELSAv2.1-bio9_cell	{#ch06.019}

**filename:** `Climate_CHELSAv2.1-bio9_cell.tif`	

**layername:** `egv_19`	

**English name:** Mean daily mean air temperatures (°C) of the driest quarter (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Sausākā ceturkšņa vidējā ikdienas vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-bio9_cell.tif"
layername="egv_19"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio9_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-bio9_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_19.png")
```



## Climate_CHELSAv2.1-clt-max_cell	{#ch06.020}

**filename:** `Climate_CHELSAv2.1-clt-max_cell.tif`	

**layername:** `egv_20`	

**English name:** Maximum monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālais mēneša vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-clt-max_cell.tif"
layername="egv_20"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-clt-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_20.png")
```



## Climate_CHELSAv2.1-clt-mean_cell	{#ch06.021}

**filename:** `Climate_CHELSAv2.1-clt-mean_cell.tif`	

**layername:** `egv_21`	

**English name:** Mean monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-clt-mean_cell.tif"
layername="egv_21"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-clt-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_21.png")
```



## Climate_CHELSAv2.1-clt-min_cell	{#ch06.022}

**filename:** `Climate_CHELSAv2.1-clt-min_cell.tif`	

**layername:** `egv_22`	

**English name:** Minimum monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālais mēneša vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-clt-min_cell.tif"
layername="egv_22"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-clt-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_22.png")
```



## Climate_CHELSAv2.1-clt-range_cell	{#ch06.023}

**filename:** `Climate_CHELSAv2.1-clt-range_cell.tif`	

**layername:** `egv_23`	

**English name:** Annual range of monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada mākoņu seguma amplitūda (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-clt-range_cell.tif"
layername="egv_23"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-clt-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_23.png")
```



## Climate_CHELSAv2.1-cmi-max_cell	{#ch06.024}

**filename:** `Climate_CHELSAv2.1-cmi-max_cell.tif`	

**layername:** `egv_24`	

**English name:** Maximum monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālais mēneša vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-cmi-max_cell.tif"
layername="egv_24"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-cmi-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_24.png")
```



## Climate_CHELSAv2.1-cmi-mean_cell	{#ch06.025}

**filename:** `Climate_CHELSAv2.1-cmi-mean_cell.tif`	

**layername:** `egv_25`	

**English name:** Mean monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-cmi-mean_cell.tif"
layername="egv_25"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-cmi-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_25.png")
```



## Climate_CHELSAv2.1-cmi-min_cell	{#ch06.026}

**filename:** `Climate_CHELSAv2.1-cmi-min_cell.tif`	

**layername:** `egv_26`	

**English name:** Minimum monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālais mēneša vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-cmi-min_cell.tif"
layername="egv_26"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-cmi-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_26.png")
```



## Climate_CHELSAv2.1-cmi-range_cell	{#ch06.027}

**filename:** `Climate_CHELSAv2.1-cmi-range_cell.tif`	

**layername:** `egv_27`	

**English name:** Annual range of monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada klimata mitruma indeksa amplitūda (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-cmi-range_cell.tif"
layername="egv_27"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-cmi-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_27.png")
```



## Climate_CHELSAv2.1-fcf_cell	{#ch06.028}

**filename:** `Climate_CHELSAv2.1-fcf_cell.tif`	

**layername:** `egv_28`	

**English name:** Frost change frequency (number of events in which tmin or tmax go above or below 0°C) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Sasalšanas gadījumu biežums (zemākā vai augstākā temperatūra šķērso 0°C) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-fcf_cell.tif"
layername="egv_28"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-fcf_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-fcf_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_28.png")
```



## Climate_CHELSAv2.1-fgd_cell	{#ch06.029}

**filename:** `Climate_CHELSAv2.1-fgd_cell.tif`	

**layername:** `egv_29`	

**English name:** First day of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pirmā diena (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-fgd_cell.tif"
layername="egv_29"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-fgd_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-fgd_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_29.png")
```



## Climate_CHELSAv2.1-gdd0_cell	{#ch06.030}

**filename:** `Climate_CHELSAv2.1-gdd0_cell.tif`	

**layername:** `egv_30`	

**English name:** Growing degree days heat sum above 0°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Aktīvo temperatūru summa no 0°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdd0_cell.tif"
layername="egv_30"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd0_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdd0_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_30.png")
```



## Climate_CHELSAv2.1-gdd10_cell	{#ch06.031}

**filename:** `Climate_CHELSAv2.1-gdd10_cell.tif`	

**layername:** `egv_31`	

**English name:** Growing degree days heat sum above 10°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Aktīvo temperatūru summa no 10°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdd10_cell.tif"
layername="egv_31"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd10_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdd10_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_31.png")
```



## Climate_CHELSAv2.1-gdd5_cell	{#ch06.032}

**filename:** `Climate_CHELSAv2.1-gdd5_cell.tif`	

**layername:** `egv_32`	

**English name:** Growing degree days heat sum above 5°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Aktīvo temperatūru summa no 5°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdd5_cell.tif"
layername="egv_32"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd5_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdd5_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_32.png")
```



## Climate_CHELSAv2.1-gddlgd0_cell	{#ch06.033}

**filename:** `Climate_CHELSAv2.1-gddlgd0_cell.tif`	

**layername:** `egv_33`	

**English name:** Last growing degree day above 0°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pēdējā diena no 0°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gddlgd0_cell.tif"
layername="egv_33"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd0_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gddlgd0_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_33.png")
```



## Climate_CHELSAv2.1-gddlgd10_cell	{#ch06.034}

**filename:** `Climate_CHELSAv2.1-gddlgd10_cell.tif`	

**layername:** `egv_34`	

**English name:** Last growing degree day above 10°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pēdējā diena no 10°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gddlgd10_cell.tif"
layername="egv_34"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd10_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gddlgd10_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_34.png")
```



## Climate_CHELSAv2.1-gddlgd5_cell	{#ch06.035}

**filename:** `Climate_CHELSAv2.1-gddlgd5_cell.tif`	

**layername:** `egv_35`	

**English name:** Last growing degree day above 5°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pēdējā diena no 5°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gddlgd5_cell.tif"
layername="egv_35"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd5_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gddlgd5_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_35.png")
```



## Climate_CHELSAv2.1-gdgfgd0_cell	{#ch06.036}

**filename:** `Climate_CHELSAv2.1-gdgfgd0_cell.tif`	

**layername:** `egv_36`	

**English name:** First growing degree day above 0°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pirmā diena no 0°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdgfgd0_cell.tif"
layername="egv_36"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd0_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdgfgd0_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_36.png")
```



## Climate_CHELSAv2.1-gdgfgd10_cell	{#ch06.037}

**filename:** `Climate_CHELSAv2.1-gdgfgd10_cell.tif`	

**layername:** `egv_37`	

**English name:** First growing degree day above 10°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pirmā diena no 10°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdgfgd10_cell.tif"
layername="egv_37"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd10_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdgfgd10_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_37.png")
```



## Climate_CHELSAv2.1-gdgfgd5_cell	{#ch06.038}

**filename:** `Climate_CHELSAv2.1-gdgfgd5_cell.tif`	

**layername:** `egv_38`	

**English name:** First growing degree day above 5°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas pirmā diena no 5°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gdgfgd5_cell.tif"
layername="egv_38"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd5_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gdgfgd5_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_38.png")
```



## Climate_CHELSAv2.1-gsl_cell	{#ch06.039}

**filename:** `Climate_CHELSAv2.1-gsl_cell.tif`	

**layername:** `egv_39`	

**English name:** Length of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonas garums (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gsl_cell.tif"
layername="egv_39"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gsl_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gsl_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_39.png")
```



## Climate_CHELSAv2.1-gsp_cell	{#ch06.040}

**filename:** `Climate_CHELSAv2.1-gsp_cell.tif`	

**layername:** `egv_40`	

**English name:** Accumulated precipitation amount (kg m⁻² year⁻¹) on growing season days (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Veģetācijas sezonā (TREELIM) uzkrātais nokrišņu daudzums (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gsp_cell.tif"
layername="egv_40"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gsp_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gsp_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_40.png")
```



## Climate_CHELSAv2.1-gst_cell	{#ch06.041}

**filename:** `Climate_CHELSAv2.1-gst_cell.tif`	

**layername:** `egv_41`	

**English name:** Mean temperature of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējā ikdienas gaisa temperatūra (°C) veģetācijas sezonā (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-gst_cell.tif"
layername="egv_41"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gst_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-gst_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_41.png")
```



## Climate_CHELSAv2.1-hurs-max_cell	{#ch06.042}

**filename:** `Climate_CHELSAv2.1-hurs-max_cell.tif`	

**layername:** `egv_42`	

**English name:** Maximum monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālais mēneša vidējais gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-hurs-max_cell.tif"
layername="egv_42"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-hurs-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_42.png")
```



## Climate_CHELSAv2.1-hurs-mean_cell	{#ch06.043}

**filename:** `Climate_CHELSAv2.1-hurs-mean_cell.tif`	

**layername:** `egv_43`	

**English name:** Mean monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējais ikmēneša gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-hurs-mean_cell.tif"
layername="egv_43"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-hurs-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_43.png")
```



## Climate_CHELSAv2.1-hurs-min_cell	{#ch06.044}

**filename:** `Climate_CHELSAv2.1-hurs-min_cell.tif`	

**layername:** `egv_44`	

**English name:** Minimum monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālais mēneša vidējais gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-hurs-min_cell.tif"
layername="egv_44"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-hurs-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_44.png")
```



## Climate_CHELSAv2.1-hurs-range_cell	{#ch06.045}

**filename:** `Climate_CHELSAv2.1-hurs-range_cell.tif`	

**layername:** `egv_45`	

**English name:** Annual range of monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada gaisa mitruma amplitūda (%) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-hurs-range_cell.tif"
layername="egv_45"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-hurs-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_45.png")
```



## Climate_CHELSAv2.1-lgd_cell	{#ch06.046}

**filename:** `Climate_CHELSAv2.1-lgd_cell.tif`	

**layername:** `egv_46`	

**English name:** Last day of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Pēdējā veģetācijas sezonas diena (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-lgd_cell.tif"
layername="egv_46"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-lgd_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-lgd_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_46.png")
```



## Climate_CHELSAv2.1-ngd0_cell	{#ch06.047}

**filename:** `Climate_CHELSAv2.1-ngd0_cell.tif`	

**layername:** `egv_47`	

**English name:** Number of days at which 2m air temperature > 0°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 0°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-ngd0_cell.tif"
layername="egv_47"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd0_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-ngd0_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_47.png")
```



## Climate_CHELSAv2.1-ngd10_cell	{#ch06.048}

**filename:** `Climate_CHELSAv2.1-ngd10_cell.tif`	

**layername:** `egv_48`	

**English name:** Number of days at which 2m air temperature > 10°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 10°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-ngd10_cell.tif"
layername="egv_48"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd10_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-ngd10_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_48.png")
```



## Climate_CHELSAv2.1-ngd5_cell	{#ch06.049}

**filename:** `Climate_CHELSAv2.1-ngd5_cell.tif`	

**layername:** `egv_49`	

**English name:** Number of days at which 2m air temperature > 5°C (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 5°C (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-ngd5_cell.tif"
layername="egv_49"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd5_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-ngd5_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_49.png")
```



## Climate_CHELSAv2.1-npp_cell	{#ch06.050}

**filename:** `Climate_CHELSAv2.1-npp_cell.tif`	

**layername:** `egv_50`	

**English name:** Net primary productivity (g C m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Neto primārā produkcija (g C m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-npp_cell.tif"
layername="egv_50"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-npp_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-npp_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_50.png")
```



## Climate_CHELSAv2.1-pet-penman-max_cell	{#ch06.051}

**filename:** `Climate_CHELSAv2.1-pet-penman-max_cell.tif`	

**layername:** `egv_51`	

**English name:** Maximum monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālā mēneša potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-pet-penman-max_cell.tif"
layername="egv_51"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-pet-penman-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_51.png")
```



## Climate_CHELSAv2.1-pet-penman-mean_cell	{#ch06.052}

**filename:** `Climate_CHELSAv2.1-pet-penman-mean_cell.tif`	

**layername:** `egv_52`	

**English name:** Mean monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējā mēneša potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-pet-penman-mean_cell.tif"
layername="egv_52"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-pet-penman-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_52.png")
```



## Climate_CHELSAv2.1-pet-penman-min_cell	{#ch06.053}

**filename:** `Climate_CHELSAv2.1-pet-penman-min_cell.tif`	

**layername:** `egv_53`	

**English name:** Minimum monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālā mēneša vidējā potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-pet-penman-min_cell.tif"
layername="egv_53"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-pet-penman-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_53.png")
```



## Climate_CHELSAv2.1-pet-penman-range_cell	{#ch06.054}

**filename:** `Climate_CHELSAv2.1-pet-penman-range_cell.tif`	

**layername:** `egv_54`	

**English name:** Annual range of monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada potenciālā evapotranspirācijas amplitūda (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-pet-penman-range_cell.tif"
layername="egv_54"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-pet-penman-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_54.png")
```



## Climate_CHELSAv2.1-rsds-max_cell	{#ch06.055}

**filename:** `Climate_CHELSAv2.1-rsds-max_cell.tif`	

**layername:** `egv_55`	

**English name:** Maximum monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālā mēneša vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-rsds-max_cell.tif"
layername="egv_55"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-rsds-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_55.png")
```



## Climate_CHELSAv2.1-rsds-mean_cell	{#ch06.056}

**filename:** `Climate_CHELSAv2.1-rsds-mean_cell.tif`	

**layername:** `egv_56`	

**English name:** Mean monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-rsds-mean_cell.tif"
layername="egv_56"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-rsds-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_56.png")
```



## Climate_CHELSAv2.1-rsds-min_cell	{#ch06.057}

**filename:** `Climate_CHELSAv2.1-rsds-min_cell.tif`	

**layername:** `egv_57`	

**English name:** Minimum monthly surface shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālā mēneša vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-rsds-min_cell.tif"
layername="egv_57"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-rsds-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_57.png")
```



## Climate_CHELSAv2.1-rsds-range_cell	{#ch06.058}

**filename:** `Climate_CHELSAv2.1-rsds-range_cell.tif`	

**layername:** `egv_58`	

**English name:** Annual range of monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada amplitūda Zemes virsmu sasniedzošajai saules radiācijai (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-rsds-range_cell.tif"
layername="egv_58"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-rsds-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_58.png")
```



## Climate_CHELSAv2.1-scd_cell	{#ch06.059}

**filename:** `Climate_CHELSAv2.1-scd_cell.tif`	

**layername:** `egv_59`	

**English name:** Number of days with snow cover (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Dienu ar sniega segu skaits (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-scd_cell.tif"
layername="egv_59"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-scd_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-scd_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_59.png")
```



## Climate_CHELSAv2.1-sfcWind-max_cell	{#ch06.060}

**filename:** `Climate_CHELSAv2.1-sfcWind-max_cell.tif`	

**layername:** `egv_60`	

**English name:** Maximum monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālais mēneša vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-sfcWind-max_cell.tif"
layername="egv_60"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-sfcWind-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_60.png")
```



## Climate_CHELSAv2.1-sfcWind-mean_cell	{#ch06.061}

**filename:** `Climate_CHELSAv2.1-sfcWind-mean_cell.tif`	

**layername:** `egv_61`	

**English name:** Mean monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-sfcWind-mean_cell.tif"
layername="egv_61"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-sfcWind-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_61.png")
```



## Climate_CHELSAv2.1-sfcWind-min_cell	{#ch06.062}

**filename:** `Climate_CHELSAv2.1-sfcWind-min_cell.tif`	

**layername:** `egv_62`	

**English name:** Minimum monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālais mēneša vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-sfcWind-min_cell.tif"
layername="egv_62"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-sfcWind-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_62.png")
```



## Climate_CHELSAv2.1-sfcWind-range_cell	{#ch06.063}

**filename:** `Climate_CHELSAv2.1-sfcWind-range_cell.tif`	

**layername:** `egv_63`	

**English name:** Annual range of monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada amplitūda vidējam piezemes slāņa vēja ātrumam (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-sfcWind-range_cell.tif"
layername="egv_63"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-sfcWind-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_63.png")
```



## Climate_CHELSAv2.1-swb_cell	{#ch06.064}

**filename:** `Climate_CHELSAv2.1-swb_cell.tif`	

**layername:** `egv_64`	

**English name:** Site water balance (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Ūdens bilance (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-swb_cell.tif"
layername="egv_64"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-swb_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-swb_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_64.png")
```



## Climate_CHELSAv2.1-swe_cell	{#ch06.065}

**filename:** `Climate_CHELSAv2.1-swe_cell.tif`	

**layername:** `egv_65`	

**English name:** Snow water equivalent (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Ūdens ekvivalents sniegā (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-swe_cell.tif"
layername="egv_65"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-swe_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-swe_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_65.png")
```



## Climate_CHELSAv2.1-vpd-max_cell	{#ch06.066}

**filename:** `Climate_CHELSAv2.1-vpd-max_cell.tif`	

**layername:** `egv_66`	

**English name:** Maximum monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Maksimālais mēneša vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-vpd-max_cell.tif"
layername="egv_66"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-max_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-vpd-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_66.png")
```



## Climate_CHELSAv2.1-vpd-mean_cell	{#ch06.067}

**filename:** `Climate_CHELSAv2.1-vpd-mean_cell.tif`	

**layername:** `egv_67`	

**English name:** Mean monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-vpd-mean_cell.tif"
layername="egv_67"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-mean_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-vpd-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_67.png")
```



## Climate_CHELSAv2.1-vpd-min_cell	{#ch06.068}

**filename:** `Climate_CHELSAv2.1-vpd-min_cell.tif`	

**layername:** `egv_68`	

**English name:** Minimum monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Minimālais mēneša vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-vpd-min_cell.tif"
layername="egv_68"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-min_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-vpd-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_68.png")
```



## Climate_CHELSAv2.1-vpd-range_cell	{#ch06.069}

**filename:** `Climate_CHELSAv2.1-vpd-range_cell.tif`	

**layername:** `egv_69`	

**English name:** Annual range of monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha)

**Latvian name:** Gada iztvaikošanas spiediena deficīta amplitūda (Pa) (CHELSA v2.1) analīzes šūnā (1 ha)

**Procedure:** Directly follows [CHELSA v2.1](#Ch04.11). EGV is prepared with the 
workflow `egvtools::downscale2egv()` with inverse distance weighted (power = 2) 
gap filling and soft smoothing (power = 0.5) over 5 km radius of every cell. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# job ----

localname="Climate_CHELSAv2.1-vpd-range_cell.tif"
layername="egv_69"
reading="./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-range_cell.tif"

df <- downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = reading,
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = localname,
  layer_name    = layername,
  fill_gaps     = TRUE,
  smooth        = TRUE,
  smooth_radius_km = 5,
  plot_result   = TRUE)
print(df)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Climate_CHELSAv2.1-vpd-range_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_69.png")
```



## HydroClim_01-max_cell	{#ch06.070}

**filename:** `HydroClim_01-max_cell.tif`	

**layername:** `egv_70`	

**English name:** Maximum per subcatchment upstream mean annual air temperature (°C) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā vidējā gaisa temperatūra augštecē (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_01-max_cell.tif"
layername="egv_70"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_01-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_70.png")
```



## HydroClim_02-max_cell	{#ch06.071}

**filename:** `HydroClim_02-max_cell.tif`	

**layername:** `egv_71`	

**English name:** Maximum per subcatchment upstream mean diurnal air temperature range (°C) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā diennakts gaisa temperatūras amplitūda augštecē (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_02-max_cell.tif"
layername="egv_71"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_02-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_71.png")
```



## HydroClim_03-max_cell	{#ch06.072}

**filename:** `HydroClim_03-max_cell.tif`	

**layername:** `egv_72`	

**English name:** Maximum per subcatchment upstream isothermality (ratio of diurnal variation to annual variation in temperatures) (°C) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā izotermalitāte augštecē (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_03-max_cell.tif"
layername="egv_72"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_03-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_72.png")
```



## HydroClim_04-max_cell	{#ch06.073}

**filename:** `HydroClim_04-max_cell.tif`	

**layername:** `egv_73`	

**English name:** Maximum per subcatchment upstream temperature seasonality (standard deviation of the monthly mean temperatures) (°C/100) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā temperatūras sezonalitāte augštecē (°C/100) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_04-max_cell.tif"
layername="egv_73"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_04-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_73.png")
```



## HydroClim_05-max_cell	{#ch06.074}

**filename:** `HydroClim_05-max_cell.tif`	

**layername:** `egv_74`	

**English name:** Maximum per subcatchment upstream mean daily maximum air temperature (°C) of the warmest month (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra siltākajā mēnesī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_05-max_cell.tif"
layername="egv_74"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_05-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_74.png")
```



## HydroClim_06-min_cell	{#ch06.075}

**filename:** `HydroClim_06-min_cell.tif`	

**layername:** `egv_75`	

**English name:** Minimum per subcatchment upstream mean daily minimum air temperature (°C) of the coldest month (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina minimālā augšteces dienas vidējā gaisa temperatūra vēsākajā mēnesī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - min - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_06-min_cell.tif"
layername="egv_75"
summary_function="min"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_06-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_75.png")
```



## HydroClim_07-max_cell	{#ch06.076}

**filename:** `HydroClim_07-max_cell.tif`	

**layername:** `egv_76`	

**English name:** Maximum per subcatchment upstream annual range of air temperature (°C) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces gada gaisa temperatūru amplitūda (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_07-max_cell.tif"
layername="egv_76"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_07-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_76.png")
```



## HydroClim_08-max_cell	{#ch06.077}

**filename:** `HydroClim_08-max_cell.tif`	

**layername:** `egv_77`	

**English name:** Maximum per subcatchment upstream mean daily mean air temperatures (°C) of the wettest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra mitrākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_08-max_cell.tif"
layername="egv_77"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_08-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_77.png")
```



## HydroClim_09-min_cell	{#ch06.078}

**filename:** `HydroClim_09-min_cell.tif`	

**layername:** `egv_78`	

**English name:** Minimum per subcatchment upstream mean daily mean air temperatures (°C) of the driest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra sausākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - min - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_09-min_cell.tif"
layername="egv_78"
summary_function="min"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_09-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_78.png")
```



## HydroClim_10-max_cell	{#ch06.079}

**filename:** `HydroClim_10-max_cell.tif`	

**layername:** `egv_79`	

**English name:** Maximum per subcatchment upstream mean daily mean air temperatures (°C) of the warmest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra siltākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_10-max_cell.tif"
layername="egv_79"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_10-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_79.png")
```



## HydroClim_11-min_cell	{#ch06.080}

**filename:** `HydroClim_11-min_cell.tif`	

**layername:** `egv_80`	

**English name:** Minimum per subcatchment upstream mean daily mean air temperatures (°C) of the coldest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra vēsākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - min - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_11-min_cell.tif"
layername="egv_80"
summary_function="min"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_11-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_80.png")
```



## HydroClim_12-max_cell	{#ch06.081}

**filename:** `HydroClim_12-max_cell.tif`	

**layername:** `egv_81`	

**English name:** Maximum per subcatchment upstream annual precipitation amount (kg m⁻² year⁻¹) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums gadā (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_12-max_cell.tif"
layername="egv_81"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_12-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_81.png")
```



## HydroClim_13-max_cell	{#ch06.082}

**filename:** `HydroClim_13-max_cell.tif`	

**layername:** `egv_82`	

**English name:** Maximum per subcatchment upstream precipitation amount (kg m⁻² year⁻¹) of the wettest month (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums mitrākajā mēnesī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_13-max_cell.tif"
layername="egv_82"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_13-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_82.png")
```



## HydroClim_14-max_cell	{#ch06.083}

**filename:** `HydroClim_14-max_cell.tif`	

**layername:** `egv_83`	

**English name:** Maximum per subcatchment upstream precipitation amount (kg m⁻² year⁻¹) of the driest month (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums sausākajā mēnesī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_14-max_cell.tif"
layername="egv_83"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_14-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_83.png")
```



## HydroClim_15-max_cell	{#ch06.084}

**filename:** `HydroClim_15-max_cell.tif`	

**layername:** `egv_84`	

**English name:** Maximum per subcatchment upstream precipitation seasonality (kg m⁻²) (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzuma sezonalitāte (kg m⁻²) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_15-max_cell.tif"
layername="egv_84"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_15-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_84.png")
```



## HydroClim_16-max_cell	{#ch06.085}

**filename:** `HydroClim_16-max_cell.tif`	

**layername:** `egv_85`	

**English name:** Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the wettest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums mitrākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_16-max_cell.tif"
layername="egv_85"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_16-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_85.png")
```



## HydroClim_17-max_cell	{#ch06.086}

**filename:** `HydroClim_17-max_cell.tif`	

**layername:** `egv_86`	

**English name:** Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the driest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums sausākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_17-max_cell.tif"
layername="egv_86"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_17-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_86.png")
```



## HydroClim_18-max_cell	{#ch06.087}

**filename:** `HydroClim_18-max_cell.tif`	

**layername:** `egv_87`	

**English name:** Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the warmest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums siltākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_18-max_cell.tif"
layername="egv_87"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_18-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_87.png")
```



## HydroClim_19-max_cell	{#ch06.088}

**filename:** `HydroClim_19-max_cell.tif`	

**layername:** `egv_88`	

**English name:** Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the coldest quarter (HydroClim) within the analysis cell (1 ha)

**Latvian name:** Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums vēsākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha)

**Procedure:** Information - both basins and raster layers - from [HydroClim data](#Ch04.12) 
is used. First, basin CRS is transformed to epsg:3059. Then zonal statistics (per basin) with 
layer specific summary function - max - are calculated (`exactextractr::exact_extract()`) 
and then rasterized with `egvtools::polygon2input()`. Once rasterized to input data, 
EGV is created with `egvtools::input2egv()`. To prevent from gaps at the edges, 
inderse distance weighted (power = 2) gap filling is implemented. To save disk space, 
intermediate input layer is unlinked. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(exactextractr)) {install.packages("exactextractr"); require(exactextractr)}

# basins ----
level12=st_read("./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp")
grid_1km=sfarrow::st_read_parquet("./Templates/TemplateGrids/tikls1km_sauzeme.parquet")
grid_1km=st_transform(grid_1km,crs=3059)
level12=st_transform(level12,crs=3059)
level12=level12[grid_1km,,]

level12=st_make_valid(level12)

# job ----

localname="HydroClim_19-max_cell.tif"
layername="egv_88"
summary_function="max"
  
slanis=rast(paste0("./Geodata/2024/HydroClim/",localname))
level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function)
  
polygon2input(vector_data = level12,
              template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
              out_path = "./RasterGrids_10m/2024/",
              file_name = localname,
              value_field = "Hydro_values",
              fun="first",
              value_type = "continuous",
              prepare=FALSE,
              project_mode = "auto",
              check_na = FALSE,
              plot_result=FALSE,
              plot_gaps = FALSE,
              overwrite=TRUE)
  
egvrez=input2egv(input=paste0("./RasterGrids_10m/2024/",localname),
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 input_template = "./Templates/TemplateRasters/LV10m_10km.tif",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = localname,
                 layername = layername,
                 idw_weight = 2,
                 plot_gaps = FALSE,plot_final = FALSE)
egvrez
  
unlink(paste0("./RasterGrids_10m/2024/",localname))

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="HydroClim_19-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_88.png")
```



## Distance_Builtup_cell	{#ch06.089}

**filename:** `Distance_Builtup_cell.tif`	

**layername:** `egv_89`	

**English name:** Distance to Built-Up features, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz apbūvei, vidējais analīzes šūnā (1 ha)

**Procedure:**   Derived from [Landscape classification](#Ch05.03) with class 
500 reclassified as 1 and others as 0. Processed 
with `egvtools::distance2egv()`. 
To protect against possible data loss at edge cells, inverse distance 
weighted (power = 2) gap filling is implemented.  At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# Distance_Builtup_cell.tif	egv_89 ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")
builtup=ifel(simple_landscape==500,1,0)
plot(builtup)
distegv=distance2egv(input = builtup,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_Builtup_cell.tif",
                     layername = "egv_89")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_Builtup_cell.tif"))
rm(builtup)
rm(distegv)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Builtup_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_89.png")
```



## Distance_ForestInside_cell	{#ch06.090}

**filename:** `Distance_ForestInside_cell.tif`	

**layername:** `egv_90`	

**English name:** Distance to Forest Edge Inside Forests, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz meža malai tā iekšienē, vidējais analīzes šūnā (1 ha)

**Procedure:**  Derived from [Landscape classification](#Ch05.03) with values in 
a range from 630 to 700 reclassified as 0 and others as 1. Processed 
with `egvtools::distance2egv()`. To protect against possible data loss at 
edge cells, inverse distance 
weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# Distance_ForestInside_cell.tif	egv_90 ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")
trees_inside=ifel(simple_landscape>=630&simple_landscape<700,0,1)
plot(trees_inside)
distegv=distance2egv(input = trees_inside,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_ForestInside_cell.tif",
                     layername = "egv_90")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_ForestInside_cell.tif"))
rm(trees_inside)
rm(distegv)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_ForestInside_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_90.png")
```



## Distance_GrasslandPermanent_cell	{#ch06.091}

**filename:** `Distance_GrasslandPermanent_cell.tif`	

**layername:** `egv_91`	

**English name:** Distance to Permanent Grasslands, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz ilggadīgiem zālājiem, vidējais analīzes šūnā (1 ha)

**Procedure:** Derived from [Rural Support Service's information on declared fields](#Ch04.02) 
with `PRODUCT_CODE=="710"` classified as 1 and the rest of the country as 0. Processed 
with `egvtools::distance2egv()`. To protect against possible data loss at 
edge cells, inverse distance weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

rastra_pamatne=raster(template10)

# Distance_GrasslandPermanent_cell.tif	egv_91 ----
kodes=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
permgrass=lad %>% 
  filter(PRODUCT_CODE=="710") %>% 
  mutate(yes=1)
permgrass_r=fasterize(permgrass,rastra_pamatne,field="yes",fun="first")
permgrass_t=rast(permgrass_r)
permgrass_t2=cover(permgrass_t,nulls10)
plot(permgrass_t2)
distegv=distance2egv(input = permgrass_t2,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_GrasslandPermanent_cell.tif",
                     layername = "egv_91")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_GrasslandPermanent_cell.tif"))
rm(distegv)
rm(kodes)
rm(lad)
rm(permgrass)
rm(permgrass_r)
rm(permgrass_t)
rm(permgrass_t2)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_GrasslandPermanent_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_91.png")
```



## Distance_Landfill_cell	{#ch06.092}

**filename:** `Distance_Landfill_cell.tif`	

**layername:** `egv_92`	

**English name:** Distance to Landfills, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz atkritumu poligoniem, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [Waste and garbage disposal sites, landfills](#Ch04.14).
1. From the [attachaed file](https://github.com/aavotins/HiQBioDiv_EGVs/blob/main/Data/Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx) read sheet "Poligoni";

2. Create an `sf` object (epsg:3059);

3. Rasterize and cover so that cells of interest are 1 and others are 0;

4. create an egv with `egvtools::distance2egv()`. Expect warning regarding nothing 
to do with aggregation. It is because `egvtools::distance2egv()` already operate at 
egv-template not the input-template resolution. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# Distance_Landfill_cell.tif egv_92 ----

# reading coordinates
landfills=read_excel("./Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx",sheet="Poligoni")
#sf object
landfills_sf=st_as_sf(landfills,coords=c("X","Y"),crs=3059)
# rasterize
landfills_rast=rasterize(landfills_sf,template100)
# raster to 1=Cell of interest, 0=background
landfills_bg=cover(landfills_rast,nulls100)

# create an egv
distegv=distance2egv(input = landfills_bg,
             template_egv = template100,
             values_as_one = 1,
             fill_gaps = TRUE, idw_weight = 2,
             outlocation = "RasterGrids_100m/2024/RAW/",
             outfilename = "Distance_Landfill_cell.tif",
             layername = "egv_92")
distegv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Landfill_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)


```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_92.png")
```



## Distance_Sea_cell	{#ch06.093}

**filename:** `Distance_Sea_cell.tif`	

**layername:** `egv_93`	

**English name:** Distance to Sea, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz jūrai, vidējais analīzes šūnā (1 ha)

**Procedure:**  Directly follows [Latvian Exclusive Economic Zone polygon](#Ch04.16).
1. Read layer as `sf` object (it already is epsg:3059);

2. Rasterize and cover so that cells of interest are 1 and others are 0;

3. create an egv with `egvtools::distance2egv()`. {fasterize} does not write CRS 
with `WKT` from epsg-string. Therefore it is better to use `project_to_template_input=TRUE` and
define input-template. However, the only difference is in how the CRS is stored, 
therefore this can ignored - distance will be calculated on the input CRS and only 
resulting layer will be projected to match egv-template (faster due to 10x aggregation of 
resolution). To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}


# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
rastrs10=raster::raster(template10)


# Distance_Sea_cell.tif egv_93 ----

# sea layer, sf
sea=st_read("./Geodata/2024/LV_EEZ/LV_EEZ.shp")

# quick rasterization
sea_r=fasterize(sea,rastrs10,field="LV_EEZ")
sea_rast=rast(sea_r)

# # raster to 1=Cell of interest, 0=background
sea_bg=cover(sea_rast,nulls10)

# create an egv
distegv=distance2egv(input = sea_bg,
                     template_egv = "./Templates/TemplateRasters/LV100m_10km.tif",
                     values_as_one = 1,
                     project_to_template_input=TRUE, # fasterize stores CRS differently
                     template_input=template10,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_Sea_cell.tif",
                     layername = "egv_93")
distegv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Sea_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)


```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_93.png")
```



## Distance_Trees_cell	{#ch06.094}

**filename:** `Distance_Trees_cell.tif`	

**layername:** `egv_94`	

**English name:** Distance to Trees, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz kokiem, vidējais analīzes šūnā (1 ha)

**Procedure:** Derived from [Landscape classification](#Ch05.03) with values in 
a range from 630 to 700 reclassified as 1 and others as 0. Processed 
with `egvtools::distance2egv()`. To protect against possible data loss at 
edge cells, inverse distance 
weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# Distance_Trees_cell.tif	egv_94 ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")
trees=ifel(simple_landscape>=630&simple_landscape<700,1,0)
plot(trees)
distegv=distance2egv(input = trees,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_Trees_cell.tif",
                     layername = "egv_94")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_Trees_cell.tif"))
rm(trees)
rm(distegv)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Trees_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_94.png")
```



## Distance_Waste_cell	{#ch06.095}

**filename:** `Distance_Waste_cell.tif`	

**layername:** `egv_95`	

**English name:** Distance to Waste disposal sites, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz atkritumu šķirošanas un uzglabāšanas vietām, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [Waste and garbage disposal sites, landfills](#Ch04.14).
1. From the [attachaed file](https://github.com/aavotins/HiQBioDiv_EGVs/blob/main/Data/Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx) read sheet "AtkritumuVietas" and clean names;

2. Create an `sf` object (epsg:3059);

3. Filter to non-deposit collection locations;

4. Rasterize and cover so that cells of interest are 1 and others are 0;

5. create an egv with `egvtools::distance2egv()`. Expect warning regarding nothing 
to do with aggregation. It is because `egvtools::distance2egv()` already operate at 
egv-template not the input-template resolution. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. 

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# Distance_Waste_cell.tif egv_95 ----

# reading coordinates
waste=read_excel("./Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx",sheet="AtkritumuVietas")
# cleaning names
waste2=janitor::clean_names(waste)
#sf object
waste_sf=st_as_sf(waste2,coords=c("y_koordinata_lks92_tm","x_koordinata_lks92_tm"),crs=3059)
# filtering to non-deposit
table(waste_sf$pienemsanas_vietas_tips)
waste_sf2=waste_sf %>% 
  filter(!str_detect(pienemsanas_vietas_tips,"Depozīta"))
# rasterize
waste_rast=rasterize(waste_sf2,template100)
# raster to 1=Cell of interest, 0=background
wastw_bg=cover(waste_rast,nulls100)

# create an egv
distegv=distance2egv(input = wastw_bg,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_Waste_cell.tif",
                     layername = "egv_95")
distegv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Waste_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_95.png")
```



## Distance_Water_cell	{#ch06.096}

**filename:** `Distance_Water_cell.tif`	

**layername:** `egv_96`	

**English name:** Distance to Waterbodies, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz ūdenstilpēn, vidējais analīzes šūnā (1 ha)

**Procedure:** Derived from [Landscape classification](#Ch05.03) with class 200 
reclassified as 1 and others as 0. Processed with `egvtools::distance2egv()`. 
To protect against possible data loss at edge cells, inverse distance 
weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# Distance_Water_cell.tif	egv_96 ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")
water=ifel(simple_landscape==200,1,0)
plot(water)
distegv=distance2egv(input = water,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_Water_cell.tif",
                     layername = "egv_96")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_Water_cell.tif"))
rm(water)
rm(distegv)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_Water_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_96.png")
```



## Distance_WaterInside_cell	{#ch06.097}

**filename:** `Distance_WaterInside_cell.tif`	

**layername:** `egv_97`	

**English name:** Distance to Waterbody Edge Inside Waterbody, average within the analysis cell (1 ha)

**Latvian name:** Attālums līdz ūdenstilpes malai tās iekšienē, vidējais analīzes šūnā (1 ha)

**Procedure:** Derived from [Landscape classification](#Ch05.03) with class 200 
reclassified as 0 and others as 1. Processed with `egvtools::distance2egv()`. 
To protect against possible data loss at edge cells, inverse distance 
weighted (power = 2) gap filling is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# Distance_WaterInside_cell.tif	egv_97 ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")
water_outside=ifel(simple_landscape==200,0,1)
plot(water_outside)
distegv=distance2egv(input = water_outside,
                     template_egv = template100,
                     values_as_one = 1,
                     fill_gaps = TRUE, idw_weight = 2,
                     outlocation = "RasterGrids_100m/2024/RAW/",
                     outfilename = "Distance_WaterInside_cell.tif",
                     layername = "egv_97")
distegv
plot(rast("RasterGrids_100m/2024/RAW/Distance_WaterInside_cell.tif"))
rm(water_outside)
rm(distegv)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Distance_WaterInside_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_97.png")
```



## Diversity_Farmland_r500	{#ch06.098}

**filename:** `Diversity_Farmland_r500.tif`	

**layername:** `egv_98`	

**English name:** Average farmland class α-diversity of 500 m grid cells within the 0.5 km landscape

**Latvian name:** Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 0.5 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Farmland diversity](#Ch05.04.0). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Farmland_500x.tif"),
  layer_prefixes = c("Diversity_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Farmland_r500.tif	egv_98
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Farmland_r500.tif")
names(slanis)="egv_98"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Farmland_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Farmland_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_98.png")
```



## Diversity_Farmland_r1250	{#ch06.099}

**filename:** `Diversity_Farmland_r1250.tif`	

**layername:** `egv_99`	

**English name:** Average farmland class α-diversity of 500 m grid cells within the 1.25 km landscape

**Latvian name:** Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 1.25 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Farmland diversity](#Ch05.04.0). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Farmland_500x.tif"),
  layer_prefixes = c("Diversity_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Farmland_r1250.tif	egv_99
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Farmland_r1250.tif")
names(slanis)="egv_99"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Farmland_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Farmland_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_99.png")
```



## Diversity_Farmland_r3000	{#ch06.100}

**filename:** `Diversity_Farmland_r3000.tif`	

**layername:** `egv_100`	

**English name:** Average farmland class α-diversity of 500 m grid cells within the 3 km landscape

**Latvian name:** Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Farmland diversity](#Ch05.04.0). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Farmland_500x.tif"),
  layer_prefixes = c("Diversity_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Farmland_r3000.tif	egv_100
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Farmland_r3000.tif")
names(slanis)="egv_100"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Farmland_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Farmland_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_100.png")
```



## Diversity_Farmland_r10000	{#ch06.101}

**filename:** `Diversity_Farmland_r10000.tif`	

**layername:** `egv_101`	

**English name:** Average farmland class α-diversity of 500 m grid cells within the 10 km landscape

**Latvian name:** Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Farmland diversity](#Ch05.04.0). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Farmland_500x.tif"),
  layer_prefixes = c("Diversity_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Farmland_r10000.tif	egv_101
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Farmland_r10000.tif")
names(slanis)="egv_101"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Farmland_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Farmland_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_101.png")
```



## Diversity_Forest_r500	{#ch06.102}

**filename:** `Diversity_Forest_r500.tif`	

**layername:** `egv_102`	

**English name:** Average forest class α-diversity of 500 m grid cells within the 0.5 km landscape

**Latvian name:** Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 0.5 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Forest diversity](#Ch05.04.02). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Forests_500x.tif"),
  layer_prefixes = c("Diversity_Forest"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Forest_r500.tif	egv_102
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Forest_r500.tif")
names(slanis)="egv_102"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Forest_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Forest_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_102.png")
```



## Diversity_Forest_r1250	{#ch06.103}

**filename:** `Diversity_Forest_r1250.tif`	

**layername:** `egv_103`	

**English name:** Average forest class α-diversity of 500 m grid cells within the 1.25 km landscape

**Latvian name:** Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 1.25 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Forest diversity](#Ch05.04.02). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Forests_500x.tif"),
  layer_prefixes = c("Diversity_Forest"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Forest_r1250.tif	egv_103
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Forest_r1250.tif")
names(slanis)="egv_103"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Forest_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Forest_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_103.png")
```



## Diversity_Forest_r3000	{#ch06.104}

**filename:** `Diversity_Forest_r3000.tif`	

**layername:** `egv_104`	

**English name:** Average forest class α-diversity of 500 m grid cells within the 3 km landscape

**Latvian name:** Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Forest diversity](#Ch05.04.02). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Forests_500x.tif"),
  layer_prefixes = c("Diversity_Forest"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Forest_r3000.tif	egv_104
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Forest_r3000.tif")
names(slanis)="egv_104"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Forest_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Forest_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_104.png")
```



## Diversity_Forest_r10000	{#ch06.105}

**filename:** `Diversity_Forest_r10000.tif`	

**layername:** `egv_105`	

**English name:** Average forest class α-diversity of 500 m grid cells within the 10 km landscape

**Latvian name:** Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Forest diversity](#Ch05.04.02). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_Forests_500x.tif"),
  layer_prefixes = c("Diversity_Forest"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Forest_r10000.tif	egv_105
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Forest_r10000.tif")
names(slanis)="egv_105"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Forest_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Forest_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_105.png")
```



## Diversity_Total_r500	{#ch06.106}

**filename:** `Diversity_Total_r500.tif`	

**layername:** `egv_106`	

**English name:** Average combined landscape α-diversity of 500 m grid cells within the 0.5 km landscape

**Latvian name:** Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 0.5 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Landscape in general diversity](#Ch05.04.01). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif"),
  layer_prefixes = c("Diversity_Total"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Total_r500.tif	egv_106
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Total_r500.tif")
names(slanis)="egv_106"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Total_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Total_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_106.png")
```



## Diversity_Total_r1250	{#ch06.107}

**filename:** `Diversity_Total_r1250.tif`	

**layername:** `egv_107`	

**English name:** Average combined landscape α-diversity of 500 m grid cells within the 1.25 km landscape

**Latvian name:** Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 1.25 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Landscape in general diversity](#Ch05.04.01). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif"),
  layer_prefixes = c("Diversity_Total"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Total_r1250.tif	egv_107
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Total_r1250.tif")
names(slanis)="egv_107"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Total_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Total_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_107.png")
```



## Diversity_Total_r3000	{#ch06.108}

**filename:** `Diversity_Total_r3000.tif`	

**layername:** `egv_108`	

**English name:** Average combined landscape α-diversity of 500 m grid cells within the 3 km landscape

**Latvian name:** Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Landscape in general diversity](#Ch05.04.01). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif"),
  layer_prefixes = c("Diversity_Total"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Total_r3000.tif	egv_108
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Total_r3000.tif")
names(slanis)="egv_108"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Total_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Total_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_108.png")
```



## Diversity_Total_r10000	{#ch06.109}

**filename:** `Diversity_Total_r10000.tif`	

**layername:** `egv_109`	

**English name:** Average combined landscape α-diversity of 500 m grid cells within the 10 km landscape

**Latvian name:** Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā

**Procedure:** Derived from [Landscape diversity](#Ch05.04), more precisely 
[Landscape in general diversity](#Ch05.04.01). Average value of  25 ha 
cells diversity index values calculated with `egvtools::radius_function()`. To 
guard against missing values at the edges, inverse distance wieghted (power = 2) 
gap filling is allowed. File is written twice, to ensure layername. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif"),
  layer_prefixes = c("Diversity_Total"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Diversity_Total_r10000.tif	egv_109
slanis=rast("./RasterGrids_100m/2024/RAW/Diversity_Total_r10000.tif")
names(slanis)="egv_109"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Diversity_Total_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Diversity_Total_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_109.png")
```



## Edges_Bogs-Trees_cell	{#ch06.110}

**filename:** `Edges_Bogs-Trees_cell.tif`	

**layername:** `egv_110`	

**English name:** Edge pixels of Bogs, Mires bordering with Trees within the analysis cell (1 ha)

**Latvian name:** Purvu malu ar kokiem garums analīzes šūnā (1 ha)

**Procedure:** First, values from 620 to 700 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then bog and transitional mire layers from [EDI](#Ch04.17) are reclassified to presence-only (value 1) and combined. Then, bog-and-mire layer (1=presence) is covered over 
tree layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Bogs-Trees_input.tif ----

trees_from620=ifel(simple_landscape>=620 & simple_landscape<700,0,NA)
plot(trees_from620)

bogs=rast("./RasterGrids_10m/2024/EDI_BogsYN.tif")
bogs=subst(bogs,0,NA)
plot(bogs)
mires=rast("./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif")
mires=subst(mires,0,NA)
plot(mires)
bogs_mires=cover(bogs,mires)
plot(bogs_mires)

bm_trees=cover(bogs_mires,trees_from620)
plot(bm_trees)

edge_bm_trees=project(bm_trees,template10,
                      filename="./RasterGrids_10m/2024/Edges_Bogs-Trees_input.tif",
                      overwrite=TRUE)

rm(edge_bm_trees)
rm(bm_trees)

# Edges_Bogs-Trees_cell.tif	egv_110

landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Bogs-Trees_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Bogs-Trees_cell.tif",
  out_layername  = "egv_110",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Trees_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_110.png")
```


## Edges_Bogs-Trees_r500	{#ch06.111}

**filename:** `Edges_Bogs-Trees_r500.tif`	

**layername:** `egv_111`	

**English name:** Edge pixels of Bogs, Mires bordering with Trees within the 0.5 km landscape

**Latvian name:** Purvu malu ar kokiem garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.110) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 4,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Trees_r500.tif	egv_111
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r500.tif")
names(slanis)="egv_111"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Trees_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_111.png")
```


## Edges_Bogs-Trees_r1250	{#ch06.112}

**filename:** `Edges_Bogs-Trees_r1250.tif`	

**layername:** `egv_112`	

**English name:** Edge pixels of Bogs, Mires bordering with Trees within the 1.25 km landscape

**Latvian name:** Purvu malu ar kokiem garums 1,25 km ainavā

**Procedure:**  Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.110) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 4,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Trees_r1250.tif	egv_112
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r1250.tif")
names(slanis)="egv_112"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Trees_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_112.png")
```


## Edges_Bogs-Trees_r3000	{#ch06.113}

**filename:** `Edges_Bogs-Trees_r3000.tif`	

**layername:** `egv_113`	

**English name:** Edge pixels of Bogs, Mires bordering with Trees within the 3 km landscape

**Latvian name:** Purvu malu ar kokiem garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.110) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 4,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Trees_r3000.tif	egv_113
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r3000.tif")
names(slanis)="egv_113"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Trees_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_113.png")
```


## Edges_Bogs-Trees_r10000	{#ch06.114}

**filename:** `Edges_Bogs-Trees_r10000.tif`	

**layername:** `egv_114`	

**English name:** Edge pixels of Bogs, Mires bordering with Trees within the 10 km landscape

**Latvian name:** Purvu malu ar kokiem garums 10 km ainavā

**Procedure:**Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.110) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 4,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Trees_r10000.tif	egv_114
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r10000.tif")
names(slanis)="egv_114"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Trees_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_114.png")
```


## Edges_Bogs-Water_cell	{#ch06.115}

**filename:** `Edges_Bogs-Water_cell.tif`	

**layername:** `egv_115`	

**English name:** Edge pixels of Bogs, Mires bordering with Water within the analysis cell (1 ha)

**Latvian name:** Purvu malu ar ūdeni garums analīzes šūnā (1 ha)

**Procedure:** First, values 200 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then bog and transitional mire layers from [EDI](#Ch04.17) are reclassified to presence-only (value 1) and combined. Then, bog-and-mire layer (1=presence) is covered over 
water layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Bogs-Water_input.tif ----
bogs=rast("./RasterGrids_10m/2024/EDI_BogsYN.tif")
bogs=subst(bogs,0,NA)
plot(bogs)
mires=rast("./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif")
mires=subst(mires,0,NA)
plot(mires)
bogs_mires=cover(bogs,mires)
plot(bogs_mires)

water=ifel(simple_landscape==200,0,NA)
plot(water)

bm_water=cover(bogs_mires,water)
plot(bm_water)

edge_bm_water=project(bm_water,template10,
                      filename="./RasterGrids_10m/2024/Edges_Bogs-Water_input.tif",
                      overwrite=TRUE)
rm(edge_bm_water)
rm(bm_water)


# Edges_Bogs-Water_cell.tif	egv_115 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Bogs-Water_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Bogs-Water_cell.tif",
  out_layername  = "egv_115",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Water_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_115.png")
```


## Edges_Bogs-Water_r500	{#ch06.116}

**filename:** `Edges_Bogs-Water_r500.tif`	

**layername:** `egv_116`	

**English name:** Edge pixels of Bogs, Mires bordering with Water within the 0.5 km landscape

**Latvian name:** Purvu malu ar ūdeni garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.115) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Water_r500.tif	egv_116
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r500.tif")
names(slanis)="egv_116"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Water_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_116.png")
```


## Edges_Bogs-Water_r1250	{#ch06.117}

**filename:** `Edges_Bogs-Water_r1250.tif`	

**layername:** `egv_117`	

**English name:** Edge pixels of Bogs, Mires bordering with Water within the 1.25 km landscape

**Latvian name:** Purvu malu ar ūdeni garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.115) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Water_r1250.tif	egv_117
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r1250.tif")
names(slanis)="egv_117"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Water_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_117.png")
```


## Edges_Bogs-Water_r3000	{#ch06.118}

**filename:** `Edges_Bogs-Water_r3000.tif`	

**layername:** `egv_118`	

**English name:** Edge pixels of Bogs, Mires bordering with Water within the 3 km landscape

**Latvian name:** Purvu malu ar ūdeni garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.115) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Water_r3000.tif	egv_118
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r3000.tif")
names(slanis)="egv_118"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Water_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_118.png")
```


## Edges_Bogs-Water_r10000	{#ch06.119}

**filename:** `Edges_Bogs-Water_r10000.tif`	

**layername:** `egv_119`	

**English name:** Edge pixels of Bogs, Mires bordering with Water within the 10 km landscape

**Latvian name:** Purvu malu ar ūdeni garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.115) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif"),
  layer_prefixes = c("Edges_Bogs-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)

# Edges_Bogs-Water_r10000.tif	egv_119
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r10000.tif")
names(slanis)="egv_119"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Bogs-Water_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_119.png")
```


## Edges_Farmland-Builtup_cell	{#ch06.120}

**filename:** `Edges_Farmland-Builtup_cell.tif`	

**layername:** `egv_120`	

**English name:** Edge pixels of Farmland bordering with Built-Up areas within the analysis cell (1 ha)

**Latvian name:** Lauksaimniecības zemju malu ar apbūvi garums analīzes šūnā (1 ha)

**Procedure:** First, values larger than 300 and smaller than 400 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then values 500 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Farmland-Builtup_input.tif ----
farmland=ifel(simple_landscape>300 & simple_landscape<400,1,NA)
plot(farmland)

builtup=ifel(simple_landscape==500,0,NA)
plot(builtup)

farmland_builtup=cover(farmland,builtup)
plot(farmland_builtup)

edge_farmland_builtup=project(farmland_builtup,template10,
                      filename="./RasterGrids_10m/2024/Edges_Farmland-Builtup_input.tif",
                      overwrite=TRUE)
rm(edge_farmland_builtup)
rm(farmland_builtup)


# Edges_Farmland-Builtup_cell.tif	egv_120 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Farmland-Builtup_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Farmland-Builtup_cell.tif",
  out_layername  = "egv_120",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Farmland-Builtup_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_120.png")
```


## Edges_Farmland-Builtup_r500	{#ch06.121}

**filename:** `Edges_Farmland-Builtup_r500.tif`	

**layername:** `egv_121`	

**English name:** Edge pixels of Farmland bordering with Built-Up areas within the 0.5 km landscape

**Latvian name:** Lauksaimniecības zemju malu ar apbūvi garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.120) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Farmland-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Farmland-Builtup_r500.tif	egv_121 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r500.tif")
names(slanis)="egv_121"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Farmland-Builtup_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_121.png")
```


## Edges_Farmland-Builtup_r1250	{#ch06.122}

**filename:** `Edges_Farmland-Builtup_r1250.tif`	

**layername:** `egv_122`	

**English name:** Edge pixels of Farmland bordering with Built-Up areas within the 1.25 km landscape

**Latvian name:** Lauksaimniecības zemju malu ar apbūvi garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.120) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Farmland-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Farmland-Builtup_r1250.tif	egv_122 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r1250.tif")
names(slanis)="egv_122"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Farmland-Builtup_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_122.png")
```


## Edges_Farmland-Builtup_r3000	{#ch06.123}

**filename:** `Edges_Farmland-Builtup_r3000.tif`	

**layername:** `egv_123`	

**English name:** Edge pixels of Farmland bordering with Built-Up areas within the 3 km landscape

**Latvian name:** Lauksaimniecības zemju malu ar apbūvi garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.120) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Farmland-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Farmland-Builtup_r3000.tif	egv_123 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r3000.tif")
names(slanis)="egv_123"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Farmland-Builtup_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_123.png")
```


## Edges_Farmland-Builtup_r10000	{#ch06.124}

**filename:** `Edges_Farmland-Builtup_r10000.tif`	

**layername:** `egv_124`	

**English name:** Edge pixels of Farmland bordering with Built-Up areas within the 10 km landscape

**Latvian name:** Lauksaimniecības zemju malu ar apbūvi garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.120) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Farmland-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Farmland-Builtup_r10000.tif	egv_124 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r10000.tif")
names(slanis)="egv_124"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Farmland-Builtup_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_124.png")
```


## Edges_Trees-Builtup_cell	{#ch06.125}

**filename:** `Edges_Trees-Builtup_cell.tif`	

**layername:** `egv_125`	

**English name:** Edge pixels of Trees bordering with Built-Up areas within the analysis cell (1 ha)

**Latvian name:** Koku malu ar apbūvi garums analīzes šūnā (1 ha)

**Procedure:** First, values larger than 630 and smaller than 700 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then values 500 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Trees-Builtup_input.tif ----
trees_from630=ifel(simple_landscape>=630 & simple_landscape<700,1,NA)
plot(trees_from630)

builtup=ifel(simple_landscape==500,0,NA)
plot(builtup)

trees630_builtup=cover(trees_from630,builtup)
plot(trees630_builtup)

edge_trees630_builtup=project(trees630_builtup,template10,
                              filename="./RasterGrids_10m/2024/Edges_Trees-Builtup_input.tif",
                              overwrite=TRUE)
rm(edge_trees630_builtup)
rm(trees630_builtup)


# Edges_Trees-Builtup_cell.tif	egv_125 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Trees-Builtup_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Trees-Builtup_cell.tif",
  out_layername  = "egv_125",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees-Builtup_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_125.png")
```


## Edges_Trees-Builtup_r500	{#ch06.126}

**filename:** `Edges_Trees-Builtup_r500.tif`	

**layername:** `egv_126`	

**English name:** Edge pixels of Trees bordering with Built-Up areas within the 0.5 km landscape

**Latvian name:** Koku malu ar apbūvi garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.125) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Trees-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees-Builtup_r500.tif	egv_126 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r500.tif")
names(slanis)="egv_126"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees-Builtup_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_126.png")
```


## Edges_Trees-Builtup_r1250	{#ch06.127}

**filename:** `Edges_Trees-Builtup_r1250.tif`	

**layername:** `egv_127`	

**English name:** Edge pixels of Trees bordering with Built-Up areas within the 1.25 km landscape

**Latvian name:** Koku malu ar apbūvi garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.125) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Trees-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees-Builtup_r1250.tif	egv_127 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r1250.tif")
names(slanis)="egv_127"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees-Builtup_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_127.png")
```


## Edges_Trees-Builtup_r3000	{#ch06.128}

**filename:** `Edges_Trees-Builtup_r3000.tif`	

**layername:** `egv_128`	

**English name:** Edge pixels of Trees bordering with Built-Up areas within the 3 km landscape

**Latvian name:** Koku malu ar apbūvi garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.125) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Trees-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees-Builtup_r3000.tif	egv_128 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r3000.tif")
names(slanis)="egv_128"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees-Builtup_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_128.png")
```


## Edges_Trees-Builtup_r10000	{#ch06.129}

**filename:** `Edges_Trees-Builtup_r10000.tif`	

**layername:** `egv_129`	

**English name:** Edge pixels of Trees bordering with Built-Up areas within the 10 km landscape

**Latvian name:** Koku malu ar apbūvi garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.125) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif"),
  layer_prefixes = c("Edges_Trees-Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees-Builtup_r10000.tif	egv_129 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r10000.tif")
names(slanis)="egv_129"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees-Builtup_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_129.png")
```


## Edges_CropsFallow_cell	{#ch06.130}

**filename:** `Edges_CropsFallow_cell.tif`	

**layername:** `egv_130`	

**English name:** Edge pixels of Cropland, Fallow land within the analysis cell (1 ha)

**Latvian name:** Aramzemju malu garums analīzes šūnā (1 ha)

**Procedure:** First, values larger than or equal to 310 and smaller than 325 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_CropsFallow_input.tif ----
cropsfallow=ifel(simple_landscape>=310 & simple_landscape<325,1,NA)
plot(cropsfallow)
cropsfallow=cover(cropsfallow,nulls10)
plot(cropsfallow)

edge_cropsfallow=project(cropsfallow,template10,
                       filename="./RasterGrids_10m/2024/Edges_CropsFallow_input.tif",
                       overwrite=TRUE)
rm(edge_cropsfallow)


# Edges_CropsFallow_cell.tif	egv_130 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_CropsFallow_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_CropsFallow_cell.tif",
  out_layername  = "egv_130",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_CropsFallow_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_130.png")
```


## Edges_CropsFallow_r500	{#ch06.131}

**filename:** `Edges_CropsFallow_r500.tif`	

**layername:** `egv_131`	

**English name:** Edge pixels of Cropland, Fallow land within the 0.5 km landscape

**Latvian name:** Aramzemju malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.130) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif"),
  layer_prefixes = c("Edges_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_CropsFallow_r500.tif	egv_131 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r500.tif")
names(slanis)="egv_131"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_CropsFallow_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_131.png")
```


## Edges_CropsFallow_r1250	{#ch06.132}

**filename:** `Edges_CropsFallow_r1250.tif`	

**layername:** `egv_132`	

**English name:** Edge pixels of Cropland, Fallow land within the 1.25 km landscape

**Latvian name:** Aramzemju malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.130) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif"),
  layer_prefixes = c("Edges_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_CropsFallow_r1250.tif	egv_132 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r1250.tif")
names(slanis)="egv_132"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_CropsFallow_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_132.png")
```


## Edges_CropsFallow_r3000	{#ch06.133}

**filename:** `Edges_CropsFallow_r3000.tif`	

**layername:** `egv_133`	

**English name:** Edge pixels of Cropland, Fallow land within the 3 km landscape

**Latvian name:** Aramzemju malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.130) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif"),
  layer_prefixes = c("Edges_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_CropsFallow_r3000.tif	egv_133 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r3000.tif")
names(slanis)="egv_133"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_CropsFallow_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_133.png")
```


## Edges_CropsFallow_r10000	{#ch06.134}

**filename:** `Edges_CropsFallow_r10000.tif`	

**layername:** `egv_134`	

**English name:** Edge pixels of Cropland, Fallow land within the 10 km landscape

**Latvian name:** Aramzemju malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.130) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif"),
  layer_prefixes = c("Edges_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_CropsFallow_r10000.tif	egv_134 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r10000.tif")
names(slanis)="egv_134"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_CropsFallow_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_134.png")
```


## Edges_FarmlandShrubs-Trees_cell	{#ch06.135}

**filename:** `Edges_FarmlandShrubs-Trees_cell.tif`	

**layername:** `egv_135`	

**English name:** Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the analysis cell (1 ha)

**Latvian name:** Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums analīzes šūnā (1 ha)

**Procedure:** First, values between 300 and 400 and between 600 and 630 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then values larger than or equal to 630 to 700 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_FarmlandShrubs-Trees_input.tif ----
farmshrub=ifel((simple_landscape>300 & simple_landscape<400)|
                 (simple_landscape>600 & simple_landscape<630),0,NA)

trees_from630=ifel(simple_landscape>=630 & simple_landscape<700,1,NA)
plot(trees_from630)

farmshrub_trees630=cover(farmshrub,trees_from630)
plot(farmshrub_trees630)

edge_farmshrub_trees630=project(farmshrub_trees630,template10,
                              filename="./RasterGrids_10m/2024/Edges_FarmlandShrubs-Trees_input.tif",
                              overwrite=TRUE)
rm(edge_farmshrub_trees630)
rm(farmshrub_trees630)


# Edges_FarmlandShrubs-Trees_cell.tif	egv_135 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_FarmlandShrubs-Trees_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_FarmlandShrubs-Trees_cell.tif",
  out_layername  = "egv_135",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_FarmlandShrubs-Trees_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_135.png")
```


## Edges_FarmlandShrubs-Trees_r500	{#ch06.136}

**filename:** `Edges_FarmlandShrubs-Trees_r500.tif`	

**layername:** `egv_136`	

**English name:** Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 0.5 km landscape

**Latvian name:** Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.135) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif"),
  layer_prefixes = c("Edges_FarmlandShrubs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_FarmlandShrubs-Trees_r500.tif	egv_136 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r500.tif")
names(slanis)="egv_136"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_FarmlandShrubs-Trees_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_136.png")
```


## Edges_FarmlandShrubs-Trees_r1250	{#ch06.137}

**filename:** `Edges_FarmlandShrubs-Trees_r1250.tif`	

**layername:** `egv_137`	

**English name:** Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 1.25 km landscape

**Latvian name:** Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.135) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif"),
  layer_prefixes = c("Edges_FarmlandShrubs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_FarmlandShrubs-Trees_r1250.tif	egv_137 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r1250.tif")
names(slanis)="egv_137"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_FarmlandShrubs-Trees_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_137.png")
```


## Edges_FarmlandShrubs-Trees_r3000	{#ch06.138}

**filename:** `Edges_FarmlandShrubs-Trees_r3000.tif`	

**layername:** `egv_138`	

**English name:** Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 3 km landscape

**Latvian name:** Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.135) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif"),
  layer_prefixes = c("Edges_FarmlandShrubs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_FarmlandShrubs-Trees_r3000.tif	egv_138 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r3000.tif")
names(slanis)="egv_138"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_FarmlandShrubs-Trees_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_138.png")
```


## Edges_FarmlandShrubs-Trees_r10000	{#ch06.139}

**filename:** `Edges_FarmlandShrubs-Trees_r10000.tif`	

**layername:** `egv_139`	

**English name:** Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 10 km landscape

**Latvian name:** Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.135) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif"),
  layer_prefixes = c("Edges_FarmlandShrubs-Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_FarmlandShrubs-Trees_r10000.tif	egv_139 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r10000.tif")
names(slanis)="egv_139"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_FarmlandShrubs-Trees_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_139.png")
```


## Edges_Grasslands_cell	{#ch06.140}

**filename:** `Edges_Grasslands_cell.tif`	

**layername:** `egv_140`	

**English name:** Edge pixels of Grassland within the analysis cell (1 ha)

**Latvian name:** Zālāju malu garums analīzes šūnā (1 ha)

**Procedure:** First, values equal to 330 and from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Grasslands_input.tif ----
grassland=ifel(simple_landscape==330,1,NA)
plot(grassland)
grassland=cover(grassland,nulls10)
plot(grassland)

edge_grassland=project(grassland,template10,
                           filename="./RasterGrids_10m/2024/Edges_Grasslands_input.tif",
                           overwrite=TRUE)
rm(edge_grassland)


# Edges_Grasslands_cell.tif	egv_140 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Grasslands_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Grasslands_cell.tif",
  out_layername  = "egv_140",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Grasslands_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_140.png")
```


## Edges_Grasslands_r500	{#ch06.141}

**filename:** `Edges_Grasslands_r500.tif`	

**layername:** `egv_141`	

**English name:** Edge pixels of Grassland within the 0.5 km landscape

**Latvian name:** Zālāju malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.140) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif"),
  layer_prefixes = c("Edges_Grasslands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Grasslands_r500.tif	egv_141 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Grasslands_r500.tif")
names(slanis)="egv_141"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Grasslands_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Grasslands_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_141.png")
```


## Edges_Grasslands_r1250	{#ch06.142}

**filename:** `Edges_Grasslands_r1250.tif`	

**layername:** `egv_142`	

**English name:** Edge pixels of Grassland within the 1.25 km landscape

**Latvian name:** Zālāju malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.140) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif"),
  layer_prefixes = c("Edges_Grasslands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Grasslands_r1250.tif	egv_142 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Grasslands_r1250.tif")
names(slanis)="egv_142"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Grasslands_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Grasslands_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_142.png")
```


## Edges_Grasslands_r3000	{#ch06.143}

**filename:** `Edges_Grasslands_r3000.tif`	

**layername:** `egv_143`	

**English name:** Edge pixels of Grassland within the 3 km landscape

**Latvian name:** Zālāju malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.140) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif"),
  layer_prefixes = c("Edges_Grasslands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Grasslands_r3000.tif	egv_143 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Grasslands_r3000.tif")
names(slanis)="egv_143"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Grasslands_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Grasslands_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_143.png")
```


## Edges_Grasslands_r10000	{#ch06.144}

**filename:** `Edges_Grasslands_r10000.tif`	

**layername:** `egv_144`	

**English name:** Edge pixels of Grassland within the 10 km landscape

**Latvian name:** Zālāju malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.140) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif"),
  layer_prefixes = c("Edges_Grasslands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Grasslands_r10000.tif	egv_144 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Grasslands_r10000.tif")
names(slanis)="egv_144"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Grasslands_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Grasslands_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_144.png")
```


## Edges_OldForests_cell	{#ch06.145}

**filename:** `Edges_OldForests_cell.tif`	

**layername:** `egv_145`	

**English name:** Edge pixels of Forests Over Rotation Age within the analysis cell (1 ha)

**Latvian name:** Pieaugušo un pāraugušo mežaudžu malu garums analīzes šūnā (1 ha)

**Procedure:** First, raster layer with forest stands from [MVR](#Ch04.01) at age groups 4 and 5 is prepared (presence = 1, everything else = NA). Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_OldForests_input.tif ----
mvr=sfarrow::st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr2=mvr %>% 
  mutate(forest_age=ifelse(vgr=="4"|vgr=="5",1,NA)) %>% 
  filter(!is.na(forest_age))

rast_old=fasterize(mvr2,raster(template10),field="forest_age")
terra_old=rast(rast_old)
plot(terra_old)
terra_old=cover(terra_old,nulls10)
plot(terra_old)

edge_old=project(terra_old,template10,
                       filename="./RasterGrids_10m/2024/Edges_OldForests_input.tif",
                       overwrite=TRUE)
rm(mvr)
rm(mvr2)
rm(rast_old)
rm(terra_old)
rm(edge_old)


# Edges_OldForests_cell.tif	egv_145 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_OldForests_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_OldForests_cell.tif",
  out_layername  = "egv_145",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_OldForests_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_145.png")
```


## Edges_OldForests_r500	{#ch06.146}

**filename:** `Edges_OldForests_r500.tif`	

**layername:** `egv_146`	

**English name:** Edge pixels of Forests Over Rotation Age within the 0.5 km landscape

**Latvian name:** Pieaugušo un pāraugušo mežaudžu malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif"),
  layer_prefixes = c("Edges_OldForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_OldForests_r500.tif	egv_146 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_OldForests_r500.tif")
names(slanis)="egv_146"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_OldForests_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_OldForests_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_146.png")
```


## Edges_OldForests_r1250	{#ch06.147}

**filename:** `Edges_OldForests_r1250.tif`	

**layername:** `egv_147`	

**English name:** Edge pixels of Forests Over Rotation Age within the 1.25 km landscape

**Latvian name:** Pieaugušo un pāraugušo mežaudžu malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif"),
  layer_prefixes = c("Edges_OldForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_OldForests_r1250.tif	egv_147 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_OldForests_r1250.tif")
names(slanis)="egv_147"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_OldForests_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_OldForests_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_147.png")
```


## Edges_OldForests_r3000	{#ch06.148}

**filename:** `Edges_OldForests_r3000.tif`	

**layername:** `egv_148`	

**English name:** Edge pixels of Forests Over Rotation Age within the 3 km landscape

**Latvian name:** Pieaugušo un pāraugušo mežaudžu malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif"),
  layer_prefixes = c("Edges_OldForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_OldForests_r3000.tif	egv_148 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_OldForests_r3000.tif")
names(slanis)="egv_148"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_OldForests_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_OldForests_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_148.png")
```


## Edges_OldForests_r10000	{#ch06.149}

**filename:** `Edges_OldForests_r10000.tif`	

**layername:** `egv_149`	

**English name:** Edge pixels of Forests Over Rotation Age within the 10 km landscape

**Latvian name:** Pieaugušo un pāraugušo mežaudžu malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif"),
  layer_prefixes = c("Edges_OldForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_OldForests_r10000.tif	egv_149 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_OldForests_r10000.tif")
names(slanis)="egv_149"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_OldForests_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_OldForests_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_149.png")
```


## Edges_Roads_cell	{#ch06.150}

**filename:** `Edges_Roads_cell.tif`	

**layername:** `egv_150`	

**English name:** Edge pixels of Roads within the analysis cell (1 ha)

**Latvian name:** Ceļu malu garums analīzes šūnā (1 ha)

**Procedure:** First, values equal to 100 and from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Roads_input.tif ----
roads=ifel(simple_landscape==100,1,NA)
plot(roads)
roads=cover(roads,nulls10)
plot(roads)

edge_roads=project(roads,template10,
                   filename="./RasterGrids_10m/2024/Edges_Roads_input.tif",
                   overwrite=TRUE)
rm(edge_roads)


# Edges_Roads_cell.tif	egv_150 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Roads_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Roads_cell.tif",
  out_layername  = "egv_150",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Roads_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_150.png")
```


## Edges_Roads_r500	{#ch06.151}

**filename:** `Edges_Roads_r500.tif`	

**layername:** `egv_151`	

**English name:** Edge pixels of Roads within the 0.5 km landscape

**Latvian name:** Ceļu malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif"),
  layer_prefixes = c("Edges_Roads"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Roads_r500.tif	egv_151 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Roads_r500.tif")
names(slanis)="egv_151"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Roads_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Roads_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_151.png")
```


## Edges_Roads_r1250	{#ch06.152}

**filename:** `Edges_Roads_r1250.tif`	

**layername:** `egv_152`	

**English name:** Edge pixels of Roads within the 1.25 km landscape

**Latvian name:** Ceļu malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif"),
  layer_prefixes = c("Edges_Roads"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Roads_r1250.tif	egv_152 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Roads_r1250.tif")
names(slanis)="egv_152"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Roads_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Roads_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_152.png")
```


## Edges_Roads_r3000	{#ch06.153}

**filename:** `Edges_Roads_r3000.tif`	

**layername:** `egv_153`	

**English name:** Edge pixels of Roads within the 3 km landscape

**Latvian name:** Ceļu malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif"),
  layer_prefixes = c("Edges_Roads"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Roads_r3000.tif	egv_153 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Roads_r3000.tif")
names(slanis)="egv_153"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Roads_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Roads_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_153.png")
```


## Edges_Roads_r10000	{#ch06.154}

**filename:** `Edges_Roads_r10000.tif`	

**layername:** `egv_154`	

**English name:** Edge pixels of Roads within the 10 km landscape

**Latvian name:** Ceļu malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.145) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif"),
  layer_prefixes = c("Edges_Roads"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Roads_r10000.tif	egv_154 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Roads_r10000.tif")
names(slanis)="egv_154"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Roads_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Roads_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_154.png")
```


## Edges_Trees_cell	{#ch06.155}

**filename:** `Edges_Trees_cell.tif`	

**layername:** `egv_155`	

**English name:** Edge pixels of Trees within the analysis cell (1 ha)

**Latvian name:** Koku malu garums analīzes šūnā (1 ha)

**Procedure:** First, values larger or equal to 630 and smaller than 700 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Trees_input.tif ----
trees_from630=ifel(simple_landscape>=630 & simple_landscape<700,1,NA)
plot(trees_from630)
trees_from630=cover(trees_from630,nulls10)
plot(trees_from630)

edge_trees_from630=project(trees_from630,template10,
                   filename="./RasterGrids_10m/2024/Edges_Trees_input.tif",
                   overwrite=TRUE)
rm(edge_trees_from630)


# Edges_Trees_cell.tif	egv_155
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Trees_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Trees_cell.tif",
  out_layername  = "egv_155",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_155.png")
```



## Edges_Trees_r500	{#ch06.156}

**filename:** `Edges_Trees_r500.tif`	

**layername:** `egv_156`	

**English name:** Edge pixels of Trees within the 0.5 km landscape

**Latvian name:** Koku malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.155) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif"),
  layer_prefixes = c("Edges_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees_r500.tif	egv_156 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees_r500.tif")
names(slanis)="egv_156"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_156.png")
```


## Edges_Trees_r1250	{#ch06.157}

**filename:** `Edges_Trees_r1250.tif`	

**layername:** `egv_157`	

**English name:** Edge pixels of Trees within the 1.25 km landscape

**Latvian name:** Koku malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.155) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif"),
  layer_prefixes = c("Edges_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees_r1250.tif	egv_157 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees_r1250.tif")
names(slanis)="egv_157"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_157.png")
```



## Edges_Trees_r3000	{#ch06.158}

**filename:** `Edges_Trees_r3000.tif`	

**layername:** `egv_158`	

**English name:** Edge pixels of Trees within the 3 km landscape

**Latvian name:** Koku malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.155) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif"),
  layer_prefixes = c("Edges_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees_r3000.tif	egv_158 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees_r3000.tif")
names(slanis)="egv_158"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_158.png")
```


## Edges_Trees_r10000	{#ch06.159}

**filename:** `Edges_Trees_r10000.tif`	

**layername:** `egv_159`	

**English name:** Edge pixels of Trees within the 10 km landscape

**Latvian name:** Koku malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.155) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif"),
  layer_prefixes = c("Edges_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Trees_r10000.tif	egv_159 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Trees_r10000.tif")
names(slanis)="egv_159"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Trees_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Trees_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_159.png")
```


## Edges_Water_cell	{#ch06.160}

**filename:** `Edges_Water_cell.tif`	

**layername:** `egv_160`	

**English name:** Edge pixels of Water within the analysis cell (1 ha)

**Latvian name:** Ūdenstilpju malu garums nalīzes šūnā (1 ha)

**Procedure:** First, values equal to 200 and from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then, the layer (1=presence) is covered over 
the nulls layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Water_input.tif ----
water=ifel(simple_landscape==200,1,0)
plot(water)
water=cover(water,nulls10)
plot(water)

edge_water=project(water,template10,
                            filename="./RasterGrids_10m/2024/Edges_Water_input.tif",
                            overwrite=TRUE)


# Edges_Water_cell.tif	egv_160 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Water_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Water_cell.tif",
  out_layername  = "egv_160",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_160.png")
```


## Edges_Water_r500	{#ch06.161}

**filename:** `Edges_Water_r500.tif`	

**layername:** `egv_161`	

**English name:** Edge pixels of Water within the 0.5 km landscape

**Latvian name:** Ūdenstilpju malu garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.160) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif"),
  layer_prefixes = c("Edges_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water_r500.tif	egv_161 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water_r500.tif")
names(slanis)="egv_161"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_161.png")
```


## Edges_Water_r1250	{#ch06.162}

**filename:** `Edges_Water_r1250.tif`	

**layername:** `egv_162`	

**English name:** Edge pixels of Water within the 1.25 km landscape

**Latvian name:** Ūdenstilpju malu garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.160) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif"),
  layer_prefixes = c("Edges_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water_r1250.tif	egv_162 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water_r1250.tif")
names(slanis)="egv_162"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_162.png")
```


## Edges_Water_r3000	{#ch06.163}

**filename:** `Edges_Water_r3000.tif`	

**layername:** `egv_163`	

**English name:** Edge pixels of Water within the 3 km landscape

**Latvian name:** Ūdenstilpju malu garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.160) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif"),
  layer_prefixes = c("Edges_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water_r3000.tif	egv_163 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water_r3000.tif")
names(slanis)="egv_163"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_163.png")
```


## Edges_Water_r10000	{#ch06.164}

**filename:** `Edges_Water_r10000.tif`	

**layername:** `egv_164`	

**English name:** Edge pixels of Water within the 10 km landscape

**Latvian name:** Ūdenstilpju malu garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.160) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif"),
  layer_prefixes = c("Edges_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water_r10000.tif	egv_164 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water_r10000.tif")
names(slanis)="egv_164"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_164.png")
```


## Edges_Water-Farmland_cell	{#ch06.165}

**filename:** `Edges_Water-Farmland_cell.tif`	

**layername:** `egv_165`	

**English name:** Edge pixels of Water bordering with Farmland within the analysis cell (1 ha)

**Latvian name:** Ūdenstilpu malu ar lauksaimniecības zemēm garums analīzes šūnā (1 ha)

**Procedure:** First, values larger than 300 and smaller than 400 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then values equal to 200 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Water-Farmland_input.tif ----
water=ifel(simple_landscape==200,0,NA)
plot(water)

farmland=ifel(simple_landscape>300 & simple_landscape<400,1,NA)
plot(farmland)

water_farmland=cover(water,farmland)
plot(water_farmland)

edge_water_farmland=project(water_farmland,template10,
                              filename="./RasterGrids_10m/2024/Edges_Water-Farmland_input.tif",
                              overwrite=TRUE)
rm(edge_water_farmland)
rm(water_farmland)


# Edges_Water-Farmland_cell.tif	egv_165 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Water-Farmland_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Water-Farmland_cell.tif",
  out_layername  = "egv_165",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Farmland_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_165.png")
```


## Edges_Water-Farmland_r500	{#ch06.166}

**filename:** `Edges_Water-Farmland_r500.tif`	

**layername:** `egv_166`	

**English name:** Edge pixels of Water bordering with Farmland within the 0.5 km landscape

**Latvian name:** Ūdenstilpu malu ar lauksaimniecības zemēm garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.165) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif"),
  layer_prefixes = c("Edges_Water-Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Farmland_r500.tif	egv_166 -----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r500.tif")
names(slanis)="egv_166"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Farmland_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_166.png")
```


## Edges_Water-Farmland_r1250	{#ch06.167}

**filename:** `Edges_Water-Farmland_r1250.tif`	

**layername:** `egv_167`	

**English name:** Edge pixels of Water bordering with Farmland within the 1.25 km landscape

**Latvian name:** Ūdenstilpu malu ar lauksaimniecības zemēm garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.165) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif"),
  layer_prefixes = c("Edges_Water-Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Farmland_r1250.tif	egv_167 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r1250.tif")
names(slanis)="egv_167"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Farmland_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_167.png")
```


## Edges_Water-Farmland_r3000	{#ch06.168}

**filename:** `Edges_Water-Farmland_r3000.tif`	

**layername:** `egv_168`	

**English name:** Edge pixels of Water bordering with Farmland within the 3 km landscape

**Latvian name:** Ūdenstilpu malu ar lauksaimniecības zemēm garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.165) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif"),
  layer_prefixes = c("Edges_Water-Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Farmland_r3000.tif	egv_168 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r3000.tif")
names(slanis)="egv_168"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Farmland_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_168.png")
```


## Edges_Water-Farmland_r10000	{#ch06.169}

**filename:** `Edges_Water-Farmland_r10000.tif`	

**layername:** `egv_169`	

**English name:** Edge pixels of Water bordering with Farmland within the 10 km landscape

**Latvian name:** Ūdenstilpu malu ar lauksaimniecības zemēm garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.165) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif"),
  layer_prefixes = c("Edges_Water-Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Farmland_r10000.tif	egv_169 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r10000.tif")
names(slanis)="egv_169"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Farmland_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_169.png")
```


## Edges_Water-Grassland_cell	{#ch06.170}

**filename:** `Edges_Water-Grassland_cell.tif`	

**layername:** `egv_170`	

**English name:** Edge pixels of Water bordering with Grassland within the analysis cell (1 ha)

**Latvian name:** Ūdenstilpu malu ar zālājiem garums analīzes šūnā (1 ha)

**Procedure:** First, values lequal to 330 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then values equal to 200 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_Water-Grassland_input.tif ----
water=ifel(simple_landscape==200,0,NA)
plot(water)

grassland=ifel(simple_landscape==330,1,NA)
plot(grassland)

water_grassland=cover(water,grassland)
plot(water_grassland)

edge_water_grassland=project(water_grassland,template10,
                            filename="./RasterGrids_10m/2024/Edges_Water-Grassland_input.tif",
                            overwrite=TRUE)
rm(edge_water_grassland)
rm(water_grassland)


# Edges_Water-Grassland_cell.tif	egv_170 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_Water-Grassland_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_Water-Grassland_cell.tif",
  out_layername  = "egv_170",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Grassland_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_170.png")
```


## Edges_Water-Grassland_r500	{#ch06.171}

**filename:** `Edges_Water-Grassland_r500.tif`	

**layername:** `egv_171`	

**English name:** Edge pixels of Water bordering with Grassland within the 0.5 km landscape

**Latvian name:** Ūdenstilpu malu ar zālājiem garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.170) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif"),
  layer_prefixes = c("Edges_Water-Grassland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Grassland_r500.tif	egv_171 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r500.tif")
names(slanis)="egv_171"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Grassland_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_171.png")
```


## Edges_Water-Grassland_r1250	{#ch06.172}

**filename:** `Edges_Water-Grassland_r1250.tif`	

**layername:** `egv_172`	

**English name:** Edge pixels of Water bordering with Grassland within the 1.25 km landscape

**Latvian name:** Ūdenstilpu malu ar zālājiem garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.170) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif"),
  layer_prefixes = c("Edges_Water-Grassland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Grassland_r1250.tif	egv_172 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r1250.tif")
names(slanis)="egv_172"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Grassland_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_172.png")
```


## Edges_Water-Grassland_r3000	{#ch06.173}

**filename:** `Edges_Water-Grassland_r3000.tif`	

**layername:** `egv_173`	

**English name:** Edge pixels of Water bordering with Grassland within the 3 km landscape

**Latvian name:** Ūdenstilpu malu ar zālājiem garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.170) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif"),
  layer_prefixes = c("Edges_Water-Grassland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Grassland_r3000.tif	egv_173 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r3000.tif")
names(slanis)="egv_173"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Grassland_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_173.png")
```


## Edges_Water-Grassland_r10000	{#ch06.174}

**filename:** `Edges_Water-Grassland_r10000.tif`	

**layername:** `egv_174`	

**English name:** Edge pixels of Water bordering with Grassland within the 10 km landscape

**Latvian name:** Ūdenstilpu malu ar zālājiem garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.170) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif"),
  layer_prefixes = c("Edges_Water-Grassland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_Water-Grassland_r10000.tif	egv_174 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r10000.tif")
names(slanis)="egv_174"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_Water-Grassland_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_174.png")
```


## Edges_ReedSedgeRushBeds-Water_cell	{#ch06.175}

**filename:** `Edges_ReedSedgeRushBeds-Water_cell.tif`	

**layername:** `egv_175`	

**English name:** Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the analysis cell (1 ha)

**Latvian name:** Niedrāju, grīslāju, meldrāju malu ar ūdeni garums analīzes šūnā (1 ha)

**Procedure:** First, values lequal to 720 from [Landscape classification](#Ch05.03) are coded as 1 and everything else as NA. Then values equal to 200 from [Landscape classification](#Ch05.03) are coded as 0 and everything else as NA. Then, the first layer (1=presence) is covered over 
the second layer (presence=0) and written to file (matching the input). Finally, with 
the function `egvtools::landscape_function()` total edge between the two classes 
is calculated. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}


# Templates -----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")

# simple landscape ----
simple_landscape=rast("./RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# Edges_ReedSedgeRushBeds-Water_input.tif ----
water=ifel(simple_landscape==200,0,NA)
plot(water)

reedsedgerush=ifel(simple_landscape==720,1,NA)
plot(reedsedgerush)


reedsedgerush_water=cover(reedsedgerush,water)
plot(reedsedgerush_water)

edge_reedsedgerush_water=project(reedsedgerush_water,template10,
                             filename="./RasterGrids_10m/2024/Edges_ReedSedgeRushBeds-Water_input.tif",
                             overwrite=TRUE)
rm(edge_reedsedgerush_water)
rm(reedsedgerush_water)


# Edges_ReedSedgeRushBeds-Water_cell.tif	egv_175 ----
landscape_function(
  landscape      = "./RasterGrids_10m/2024/Edges_ReedSedgeRushBeds-Water_input.tif",
  zones          = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  id_field       = "id",
  tile_field     = "tks50km",
  template       = "./Templates/TemplateRasters/LV100m_10km.tif",
  out_dir        = "./RasterGrids_100m/2024/RAW",
  out_filename   = "Edges_ReedSedgeRushBeds-Water_cell.tif",
  out_layername  = "egv_175",
  what             = "lsm_l_te",
  lm_args          = list(count_boundary = FALSE),
  rasterize_engine = "fasterize",
  n_workers      = 12,
  future_max_size = 20 * 1024^3,
  fill_gaps      = TRUE,
  plot_gaps      = FALSE,
  plot_result    = FALSE
)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_ReedSedgeRushBeds-Water_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_175.png")
```


## Edges_ReedSedgeRushBeds-Water_r500	{#ch06.176}

**filename:** `Edges_ReedSedgeRushBeds-Water_r500.tif`	

**layername:** `egv_176`	

**English name:** Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 0.5 km landscape

**Latvian name:** Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 0,5 km ainavā

**Procedure:** Total edge at 500 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.175) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif"),
  layer_prefixes = c("Edges_ReedSedgeRushBeds-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_ReedSedgeRushBeds-Water_r500.tif	egv_176 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r500.tif")
names(slanis)="egv_176"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_ReedSedgeRushBeds-Water_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_176.png")
```


## Edges_ReedSedgeRushBeds-Water_r1250	{#ch06.177}

**filename:** `Edges_ReedSedgeRushBeds-Water_r1250.tif`	

**layername:** `egv_177`	

**English name:** Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 1.25 km landscape

**Latvian name:** Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 1,25 km ainavā

**Procedure:** Total edge at 1250 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.175) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif"),
  layer_prefixes = c("Edges_ReedSedgeRushBeds-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_ReedSedgeRushBeds-Water_r1250.tif	egv_177 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r1250.tif")
names(slanis)="egv_177"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_ReedSedgeRushBeds-Water_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_177.png")
```


## Edges_ReedSedgeRushBeds-Water_r3000	{#ch06.178}

**filename:** `Edges_ReedSedgeRushBeds-Water_r3000.tif`	

**layername:** `egv_178`	

**English name:** Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 3 km landscape

**Latvian name:** Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 3 km ainavā

**Procedure:** Total edge at 3000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.175) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif"),
  layer_prefixes = c("Edges_ReedSedgeRushBeds-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_ReedSedgeRushBeds-Water_r3000.tif	egv_178 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r3000.tif")
names(slanis)="egv_178"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_ReedSedgeRushBeds-Water_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_178.png")
```


## Edges_ReedSedgeRushBeds-Water_r10000	{#ch06.179}

**filename:** `Edges_ReedSedgeRushBeds-Water_r10000.tif`	

**layername:** `egv_179`	

**English name:** Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 10 km landscape

**Latvian name:** Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 10 km ainavā

**Procedure:** Total edge at 10000 m radius around the analysis grid cell, is calculated as the area-weighted sum of [analysis cells](#ch06.175) inside the buffer with `egvtools::radius_function`. During calculation of landscape metric, inverse distance weighted (power = 2) gap filling on the output is initialized to ensure no missing values at the edges. Finally, layer is rewritten to ensure layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif"),
  layer_prefixes = c("Edges_ReedSedgeRushBeds-Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "sum",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Edges_ReedSedgeRushBeds-Water_r10000.tif	egv_179 ----
slanis=rast("./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r10000.tif")
names(slanis)="egv_179"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Edges_ReedSedgeRushBeds-Water_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_179.png")
```


## FarmlandCrops_CropsAll_cell	{#ch06.180}

**filename:** `FarmlandCrops_CropsAll_cell.tif`	

**layername:** `egv_180`	

**English name:** Fractional cover of Crops (all types) within the analysis cell (1 ha)

**Latvian name:** Aramzemju (dažādu lauksaimniecības kultūru) platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with any type of crops are selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_CropsAll_cell.tif	egv_180 ----
aramzemes=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"aramz"))

p2i_rez=egvtools::polygon2input(vector_data = aramzemes,
                        template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                        out_path = "./RasterGrids_10m/2024/",
                        file_name = "FarmlandCrops_CropsAll_input.tif",
                        value_field = "yes",
                        prepare=FALSE,
                        background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                        plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_CropsAll_input.tif"),
                    egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                    summary_function = "average",
                    missing_job = "FillOutput",
                    outlocation = "./RasterGrids_100m/2024/RAW/",
                    outfilename = "FarmlandCrops_CropsAll_cell.tif",
                    layername = "egv_180",
                    idw_weight = 2,
                    plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(aramzemes)
unlink("./RasterGrids_10m/2024/FarmlandCrops_CropsAll_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsAll_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_180.png")
```


## FarmlandCrops_CropsAll_r500	{#ch06.181}

**filename:** `FarmlandCrops_CropsAll_r500.tif`	

**layername:** `egv_181`	

**English name:** Fractional cover of Crops (all types) within the 0.5 km landscape

**Latvian name:** Aramzemju (dažādu lauksaimniecības kultūru) platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.180) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)



# FarmlandCrops_CropsAll_r500.tif	egv_181 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r500.tif")
names(slanis)="egv_181"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsAll_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_181.png")
```


## FarmlandCrops_CropsAll_r1250	{#ch06.182}

**filename:** `FarmlandCrops_CropsAll_r1250.tif`	

**layername:** `egv_182`	

**English name:** Fractional cover of Crops (all types) within the 1.25 km landscape

**Latvian name:** Aramzemju (dažādu lauksaimniecības kultūru) platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.180) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)



# FarmlandCrops_CropsAll_r1250.tif	egv_182 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r1250.tif")
names(slanis)="egv_182"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsAll_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_182.png")
```


## FarmlandCrops_CropsAll_r3000	{#ch06.183}

**filename:** `FarmlandCrops_CropsAll_r3000.tif`	

**layername:** `egv_183`	

**English name:** Fractional cover of Crops (all types) within the 3 km landscape

**Latvian name:** Aramzemju (dažādu lauksaimniecības kultūru) platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.180) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)



# FarmlandCrops_CropsAll_r3000.tif	egv_183 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r3000.tif")
names(slanis)="egv_183"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsAll_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_183.png")
```


## FarmlandCrops_CropsAll_r10000	{#ch06.184}

**filename:** `FarmlandCrops_CropsAll_r10000.tif`	

**layername:** `egv_184`	

**English name:** Fractional cover of Crops (all types) within the 10 km landscape

**Latvian name:** Aramzemju (dažādu lauksaimniecības kultūru) platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.180) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)



# FarmlandCrops_CropsAll_r10000.tif	egv_184 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r10000.tif")
names(slanis)="egv_184"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsAll_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_184.png")
```


## FarmlandCrops_CropsHoed_cell	{#ch06.185}

**filename:** `FarmlandCrops_CropsHoed_cell.tif`	

**layername:** `egv_185`	

**English name:** Fractional cover of Hoed Crops within the analysis cell (1 ha)

**Latvian name:** Vagu un rušināmkultūru platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with hoed crops were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_CropsHoed_cell.tif	egv_185 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"ruši"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_CropsHoed_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_CropsHoed_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_CropsHoed_cell.tif",
                            layername = "egv_185",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_CropsHoed_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsHoed_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_185.png")
```


## FarmlandCrops_CropsHoed_r500	{#ch06.186}

**filename:** `FarmlandCrops_CropsHoed_r500.tif`	

**layername:** `egv_186`	

**English name:** Fractional cover of Hoed Crops within the 0.5 km landscape

**Latvian name:** Vagu un rušināmkultūru platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.185) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsHoed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsHoed_r500.tif	egv_186 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r500.tif")
names(slanis)="egv_186"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsHoed_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_186.png")
```


## FarmlandCrops_CropsHoed_r1250	{#ch06.187}

**filename:** `FarmlandCrops_CropsHoed_r1250.tif`	

**layername:** `egv_187`	

**English name:** Fractional cover of Hoed Crops within the 1.25 km landscape

**Latvian name:** Vagu un rušināmkultūru platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.185) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsHoed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsHoed_r1250.tif	egv_187 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r1250.tif")
names(slanis)="egv_187"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsHoed_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_187.png")
```


## FarmlandCrops_CropsHoed_r3000	{#ch06.188}

**filename:** `FarmlandCrops_CropsHoed_r3000.tif`	

**layername:** `egv_188`	

**English name:** Fractional cover of Hoed Crops within the 3 km landscape

**Latvian name:** Vagu un rušināmkultūru platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.185) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsHoed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsHoed_r3000.tif	egv_188 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r3000.tif")
names(slanis)="egv_188"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsHoed_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_188.png")
```


## FarmlandCrops_CropsHoed_r10000	{#ch06.189}

**filename:** `FarmlandCrops_CropsHoed_r10000.tif`	

**layername:** `egv_189`	

**English name:** Fractional cover of Hoed Crops within the 10 km landscape

**Latvian name:** Vagu un rušināmkultūru platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.185) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsHoed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsHoed_r10000.tif	egv_189 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r10000.tif")
names(slanis)="egv_189"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsHoed_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_189.png")
```


## FarmlandCrops_CropsOther_cell	{#ch06.190}

**filename:** `FarmlandCrops_CropsOther_cell.tif`	

**layername:** `egv_190`	

**English name:** Fractional cover of Other Crops within the analysis cell (1 ha)

**Latvian name:** Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with otherwise not differentiated crops were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_CropsOther_cell.tif	egv_190 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"citur neie"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_CropsOther_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_CropsOther_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_CropsOther_cell.tif",
                            layername = "egv_190",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_CropsOther_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsOther_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_190.png")
```



## FarmlandCrops_CropsOther_r500	{#ch06.191}

**filename:** `FarmlandCrops_CropsOther_r500.tif`	

**layername:** `egv_191`	

**English name:** Fractional cover of Other Crops within the 0.5 km landscape

**Latvian name:** Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.190) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsOther"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsOther_r500.tif	egv_191 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r500.tif")
names(slanis)="egv_191"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsOther_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_191.png")
```


## FarmlandCrops_CropsOther_r1250	{#ch06.192}

**filename:** `FarmlandCrops_CropsOther_r1250.tif`	

**layername:** `egv_192`	

**English name:** Fractional cover of Other Crops within the 1.25 km landscape

**Latvian name:** Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.190) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsOther"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsOther_r1250.tif	egv_192 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r1250.tif")
names(slanis)="egv_192"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsOther_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_192.png")
```


## FarmlandCrops_CropsOther_r3000	{#ch06.193}

**filename:** `FarmlandCrops_CropsOther_r3000.tif`	

**layername:** `egv_193`	

**English name:** Fractional cover of Other Crops within the 3 km landscape

**Latvian name:** Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.190) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsOther"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsOther_r3000.tif	egv_193 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r3000.tif")
names(slanis)="egv_193"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsOther_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_193.png")
```


## FarmlandCrops_CropsOther_r10000	{#ch06.194}

**filename:** `FarmlandCrops_CropsOther_r10000.tif`	

**layername:** `egv_194`	

**English name:** Fractional cover of Other Crops within the 10 km landscape

**Latvian name:** Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.190) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsOther"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsOther_r10000.tif	egv_194 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r10000.tif")
names(slanis)="egv_194"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsOther_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_194.png")
```


## FarmlandCrops_CropsSpring_cell	{#ch06.195}

**filename:** `FarmlandCrops_CropsSpring_cell.tif`	

**layername:** `egv_195`	

**English name:** Fractional cover of Spring Sown Crops within the analysis cell (1 ha)

**Latvian name:** Vasarāju aramzemēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with declared as spring sawn crops were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_CropsSpring_cell.tif	egv_195 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"labība-vasarāji"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_CropsSpring_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_CropsSpring_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_CropsSpring_cell.tif",
                            layername = "egv_195",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_CropsSpring_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsSpring_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_195.png")
```


## FarmlandCrops_CropsSpring_r500	{#ch06.196}

**filename:** `FarmlandCrops_CropsSpring_r500.tif`	

**layername:** `egv_196`	

**English name:** Fractional cover of Spring Sown Crops within the 0.5 km landscape

**Latvian name:** Vasarāju aramzemēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.195) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsSpring_r500.tif	egv_196 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r500.tif")
names(slanis)="egv_196"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsSpring_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_196.png")
```


## FarmlandCrops_CropsSpring_r1250	{#ch06.197}

**filename:** `FarmlandCrops_CropsSpring_r1250.tif`	

**layername:** `egv_197`	

**English name:** Fractional cover of Spring Sown Crops within the 1.25 km landscape

**Latvian name:** Vasarāju aramzemēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.195) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsSpring_r1250.tif	egv_197 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r1250.tif")
names(slanis)="egv_197"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsSpring_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_197.png")
```


## FarmlandCrops_CropsSpring_r3000	{#ch06.198}

**filename:** `FarmlandCrops_CropsSpring_r3000.tif`	

**layername:** `egv_198`	

**English name:** Fractional cover of Spring Sown Crops within the 3 km landscape

**Latvian name:** Vasarāju aramzemēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.195) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsSpring_r3000.tif	egv_198 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r3000.tif")
names(slanis)="egv_198"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsSpring_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_198.png")
```


## FarmlandCrops_CropsSpring_r10000	{#ch06.199}

**filename:** `FarmlandCrops_CropsSpring_r10000.tif`	

**layername:** `egv_199`	

**English name:** Fractional cover of Spring Sown Crops within the 10 km landscape

**Latvian name:** Vasarāju aramzemēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.195) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsSpring_r10000.tif	egv_199 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r10000.tif")
names(slanis)="egv_199"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsSpring_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_199.png")
```


## FarmlandCrops_CropsWinter_cell	{#ch06.200}

**filename:** `FarmlandCrops_CropsWinter_cell.tif`	

**layername:** `egv_200`	

**English name:** Fractional cover of Winter Crops within the analysis cell (1 ha)

**Latvian name:** Ziemāju aramzemēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with declared as winter crops were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_CropsWinter_cell.tif	egv_200 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"labība-ziemāji"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_CropsWinter_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_CropsWinter_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_CropsWinter_cell.tif",
                            layername = "egv_200",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_CropsWinter_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsWinter_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_200.png")
```


## FarmlandCrops_CropsWinter_r500	{#ch06.201}

**filename:** `FarmlandCrops_CropsWinter_r500.tif`	

**layername:** `egv_201`	

**English name:** Fractional cover of Winter Crops within the 0.5 km landscape

**Latvian name:** Ziemāju aramzemēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.200) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsWinter_r500.tif	egv_201 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r500.tif")
names(slanis)="egv_201"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsWinter_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_201.png")
```


## FarmlandCrops_CropsWinter_r1250	{#ch06.202}

**filename:** `FarmlandCrops_CropsWinter_r1250.tif`	

**layername:** `egv_202`	

**English name:** Fractional cover of Winter Crops within the 1.25 km landscape

**Latvian name:** Ziemāju aramzemēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.200) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsWinter_r1250.tif	egv_202 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r1250.tif")
names(slanis)="egv_202"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsWinter_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_202.png")
```


## FarmlandCrops_CropsWinter_r3000	{#ch06.203}

**filename:** `FarmlandCrops_CropsWinter_r3000.tif`	

**layername:** `egv_203`	

**English name:** Fractional cover of Winter Crops within the 3 km landscape

**Latvian name:** Ziemāju aramzemēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.200) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsWinter_r3000.tif	egv_203 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r3000.tif")
names(slanis)="egv_203"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsWinter_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_203.png")
```


## FarmlandCrops_CropsWinter_r10000	{#ch06.204}

**filename:** `FarmlandCrops_CropsWinter_r10000.tif`	

**layername:** `egv_204`	

**English name:** Fractional cover of Winter Crops within the 10 km landscape

**Latvian name:** Ziemāju aramzemēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.200) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_CropsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_CropsWinter_r10000.tif	egv_204 ----
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r10000.tif")
names(slanis)="egv_204"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_CropsWinter_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_204.png")
```


## FarmlandCrops_RapeseedsSpring_cell	{#ch06.205}

**filename:** `FarmlandCrops_RapeseedsSpring_cell.tif`	

**layername:** `egv_205`	

**English name:** Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the analysis cell (1 ha)

**Latvian name:** Vasaras rapša, ripša, kukurūzas platība analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with declared as spring sawn rapeseed, turnip or corn were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_RapeseedsSpring_cell.tif	egv_205 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"vasaras rapsis"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_RapeseedsSpring_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_RapeseedsSpring_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_RapeseedsSpring_cell.tif",
                            layername = "egv_205",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_RapeseedsSpring_input.tif")



# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsSpring_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_205.png")
```


## FarmlandCrops_RapeseedsSpring_r500	{#ch06.206}

**filename:** `FarmlandCrops_RapeseedsSpring_r500.tif`	

**layername:** `egv_206`	

**English name:** Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 0.5 km landscape

**Latvian name:** Vasaras rapša, ripša, kukurūzas platība 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.205) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsSpring_r500.tif	egv_206
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r500.tif")
names(slanis)="egv_206"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsSpring_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_206.png")
```


## FarmlandCrops_RapeseedsSpring_r1250	{#ch06.207}

**filename:** `FarmlandCrops_RapeseedsSpring_r1250.tif`	

**layername:** `egv_207`	

**English name:** Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 1.25 km landscape

**Latvian name:** Vasaras rapša, ripša, kukurūzas platība 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.205) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsSpring_r1250.tif	egv_207
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r1250.tif")
names(slanis)="egv_207"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsSpring_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_207.png")
```


## FarmlandCrops_RapeseedsSpring_r3000	{#ch06.208}

**filename:** `FarmlandCrops_RapeseedsSpring_r3000.tif`	

**layername:** `egv_208`	

**English name:** Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 3 km landscape

**Latvian name:** Vasaras rapša, ripša, kukurūzas platība 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.205) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsSpring_r3000.tif	egv_208
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r3000.tif")
names(slanis)="egv_208"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsSpring_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_208.png")
```


## FarmlandCrops_RapeseedsSpring_r10000	{#ch06.209}

**filename:** `FarmlandCrops_RapeseedsSpring_r10000.tif`	

**layername:** `egv_209`	

**English name:** Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 10 km landscape

**Latvian name:** Vasaras rapša, ripša, kukurūzas platība 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.205) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsSpring"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsSpring_r10000.tif	egv_209
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r10000.tif")
names(slanis)="egv_209"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsSpring_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_209.png")
```


## FarmlandCrops_RapeseedsWinter_cell	{#ch06.210}

**filename:** `FarmlandCrops_RapeseedsWinter_cell.tif`	

**layername:** `egv_210`	

**English name:** Fractional cover of Winter Rapeseed, Turnip within the analysis cell (1 ha)

**Latvian name:** Ziemas rapša, ripša platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels with declared as winter rapeseed or turnip were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandCrops_RapeseedsWinter_cell.tif	egv_210 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"ziemas rapsis"))
table(dati$SDM_grupa_sakums,useNA="always")


p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandCrops_RapeseedsWinter_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandCrops_RapeseedsWinter_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandCrops_RapeseedsWinter_cell.tif",
                            layername = "egv_210",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandCrops_RapeseedsWinter_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsWinter_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_210.png")
```


## FarmlandCrops_RapeseedsWinter_r500	{#ch06.211}

**filename:** `FarmlandCrops_RapeseedsWinter_r500.tif`	

**layername:** `egv_211`	

**English name:** Fractional cover of Winter Rapeseed, Turnip within the 0.5 km landscape

**Latvian name:** Ziemas rapša, ripša platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.210) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsWinter_r500.tif	egv_211
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r500.tif")
names(slanis)="egv_211"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsWinter_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_211.png")
```


## FarmlandCrops_RapeseedsWinter_r1250	{#ch06.212}

**filename:** `FarmlandCrops_RapeseedsWinter_r1250.tif`	

**layername:** `egv_212`	

**English name:** Fractional cover of Winter Rapeseed, Turnip within the 1.25 km landscape

**Latvian name:** Ziemas rapša, ripša platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.210) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsWinter_r1250.tif	egv_212
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r1250.tif")
names(slanis)="egv_212"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsWinter_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_212.png")
```


## FarmlandCrops_RapeseedsWinter_r3000	{#ch06.213}

**filename:** `FarmlandCrops_RapeseedsWinter_r3000.tif`	

**layername:** `egv_213`	

**English name:** Fractional cover of Winter Rapeseed, Turnip within the 3 km landscape

**Latvian name:** Ziemas rapša, ripša platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.210) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsWinter_r3000.tif	egv_213
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r3000.tif")
names(slanis)="egv_213"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsWinter_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_213.png")
```


## FarmlandCrops_RapeseedsWinter_r10000	{#ch06.214}

**filename:** `FarmlandCrops_RapeseedsWinter_r10000.tif`	

**layername:** `egv_214`	

**English name:** Fractional cover of Winter Rapeseed, Turnip within the 10 km landscape

**Latvian name:** Ziemas rapša, ripša platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.210) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif"),
  layer_prefixes = c("FarmlandCrops_RapeseedsWinter"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandCrops_RapeseedsWinter_r10000.tif	egv_214
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r10000.tif")
names(slanis)="egv_214"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandCrops_RapeseedsWinter_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_214.png")
```


## FarmlandGrassland_GrasslandsAbandoned_cell	{#ch06.215}

**filename:** `FarmlandGrassland_GrasslandsAbandoned_cell.tif`	

**layername:** `egv_215`	

**English name:** Fractional cover of Abandoned Grassland within the analysis cell (1 ha)

**Latvian name:** Neapsaimniekotu zālāju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, grasslands from [Landscape classification](#Ch05.03) were selected (value 330 reclassified to
value 1, others as NA). Then agricultural parcels declared as grasslands were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). Then cells with 
grasslands in [Landscape classification](#Ch05.03) but not in [Rural Support Service's information on declared fields](#Ch04.02) were selected and matched to input layer. 
Once matched, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandGrassland_GrasslandsAbandoned_cell.tif	egv_215 ----
landscape_grasslands=ifel(simple_landscape==330,1,0)

dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"zālāji"))
table(dati$SDM_grupa_sakums,useNA="always")

lad_zalajiem=fasterize(dati,rastrs10,field="yes",fun="first")
lad_zalaji=rast(lad_zalajiem)

abandoned=ifel(landscape_grasslands==1&is.na(lad_zalaji),1,0)
plot(abandoned)

i2e_rez=egvtools::input2egv(input=abandoned,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandGrassland_GrasslandsAbandoned_cell.tif",
                            layername = "egv_215",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(i2e_rez)
rm(dati)
rm(lad_zalajiem)
rm(lad_zalaji)


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAbandoned_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_215.png")
```


## FarmlandGrassland_GrasslandsAbandoned_r500	{#ch06.216}

**filename:** `FarmlandGrassland_GrasslandsAbandoned_r500.tif`	

**layername:** `egv_216`	

**English name:** Fractional cover of Abandoned Grassland within the 0.5 km landscape

**Latvian name:** Neapsaimniekotu zālāju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.215) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAbandoned"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAbandoned_r500.tif	egv_216
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r500.tif")
names(slanis)="egv_216"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAbandoned_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_216.png")
```


## FarmlandGrassland_GrasslandsAbandoned_r1250	{#ch06.217}

**filename:** `FarmlandGrassland_GrasslandsAbandoned_r1250.tif`	

**layername:** `egv_217`	

**English name:** Fractional cover of Abandoned Grassland within the 1.25 km landscape

**Latvian name:** Neapsaimniekotu zālāju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.215) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAbandoned"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAbandoned_r1250.tif	egv_217
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r1250.tif")
names(slanis)="egv_217"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAbandoned_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_217.png")
```


## FarmlandGrassland_GrasslandsAbandoned_r3000	{#ch06.218}

**filename:** `FarmlandGrassland_GrasslandsAbandoned_r3000.tif`	

**layername:** `egv_218`	

**English name:** Fractional cover of Abandoned Grassland within the 3 km landscape

**Latvian name:** Neapsaimniekotu zālāju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.215) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAbandoned"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAbandoned_r3000.tif	egv_218
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r3000.tif")
names(slanis)="egv_218"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAbandoned_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_218.png")
```


## FarmlandGrassland_GrasslandsAbandoned_r10000	{#ch06.219}

**filename:** `FarmlandGrassland_GrasslandsAbandoned_r10000.tif`	

**layername:** `egv_219`	

**English name:** Fractional cover of Abandoned Grassland within the 10 km landscape

**Latvian name:** Neapsaimniekotu zālāju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.215) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAbandoned"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAbandoned_r10000.tif	egv_219
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r10000.tif")
names(slanis)="egv_219"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAbandoned_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_219.png")
```


## FarmlandGrassland_GrasslandsAll_cell	{#ch06.220}

**filename:** `FarmlandGrassland_GrasslandsAll_cell.tif`	

**layername:** `egv_220`	

**English name:** Fractional cover of any Grassland within the analysis cell (1 ha)

**Latvian name:** Zālāju (visu veidu) platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, grasslands from [Landscape classification](#Ch05.03) were selected (value 330 reclassified to
value 1, others as 0). 
Once selected, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandGrassland_GrasslandsAll_cell.tif	egv_220 ----
landscape_grasslands=ifel(simple_landscape==330,1,0)

i2e_rez=egvtools::input2egv(input=landscape_grasslands,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandGrassland_GrasslandsAll_cell.tif",
                            layername = "egv_220",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(i2e_rez)
rm(landscape_grasslands)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAll_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_220.png")
```


## FarmlandGrassland_GrasslandsAll_r500	{#ch06.221}

**filename:** `FarmlandGrassland_GrasslandsAll_r500.tif`	

**layername:** `egv_221`	

**English name:** Fractional cover of any Grassland within the 0.5 km landscape

**Latvian name:** Zālāju (visu veidu) platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.220) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAll_r500.tif	egv_221
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r500.tif")
names(slanis)="egv_221"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAll_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_221.png")
```


## FarmlandGrassland_GrasslandsAll_r1250	{#ch06.222}

**filename:** `FarmlandGrassland_GrasslandsAll_r1250.tif`	

**layername:** `egv_222`	

**English name:** Fractional cover of any Grassland within the 1.25 km landscape

**Latvian name:** Zālāju (visu veidu) platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.220) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAll_r1250.tif	egv_222
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r1250.tif")
names(slanis)="egv_222"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAll_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_222.png")
```


## FarmlandGrassland_GrasslandsAll_r3000	{#ch06.223}

**filename:** `FarmlandGrassland_GrasslandsAll_r3000.tif`	

**layername:** `egv_223`	

**English name:** Fractional cover of any Grassland within the 3 km landscape

**Latvian name:** Zālāju (visu veidu) platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.220) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAll_r3000.tif	egv_223
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r3000.tif")
names(slanis)="egv_223"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAll_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_223.png")
```


## FarmlandGrassland_GrasslandsAll_r10000	{#ch06.224}

**filename:** `FarmlandGrassland_GrasslandsAll_r10000.tif`	

**layername:** `egv_224`	

**English name:** Fractional cover of any Grassland within the 10 km landscape

**Latvian name:** Zālāju (visu veidu) platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.220) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsAll"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsAll_r10000.tif	egv_224
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r10000.tif")
names(slanis)="egv_224"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsAll_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_224.png")
```


## FarmlandGrassland_GrasslandsPermanent_cell	{#ch06.225}

**filename:** `FarmlandGrassland_GrasslandsPermanent_cell.tif`	

**layername:** `egv_225`	

**English name:** Fractional cover of Permanent Grassland within the analysis cell (1 ha)

**Latvian name:** Ilggadīgu zālāju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as permanent grasslands were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandGrassland_GrasslandsPermanent_cell.tif	egv_225 ----
dati=lad %>% 
  filter(SDM_grupa_sakums=="zālāji (ilggadīgie)")
  
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandGrassland_GrasslandsPermanent_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandGrassland_GrasslandsPermanent_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandGrassland_GrasslandsPermanent_cell.tif",
                            layername = "egv_225",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandGrassland_GrasslandsPermanent_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsPermanent_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_225.png")
```


## FarmlandGrassland_GrasslandsPermanent_r500	{#ch06.226}

**filename:** `FarmlandGrassland_GrasslandsPermanent_r500.tif`	

**layername:** `egv_226`	

**English name:** Fractional cover of Permanent Grassland within the 0.5 km landscape

**Latvian name:** Ilggadīgu zālāju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.225) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsPermanent"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsPermanent_r500.tif	egv_226
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r500.tif")
names(slanis)="egv_226"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsPermanent_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_226.png")
```


## FarmlandGrassland_GrasslandsPermanent_r1250	{#ch06.227}

**filename:** `FarmlandGrassland_GrasslandsPermanent_r1250.tif`	

**layername:** `egv_227`	

**English name:** Fractional cover of Permanent Grassland within the 1.25 km landscape

**Latvian name:** Ilggadīgu zālāju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.225) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsPermanent"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsPermanent_r1250.tif	egv_227
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r1250.tif")
names(slanis)="egv_227"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsPermanent_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_227.png")
```


## FarmlandGrassland_GrasslandsPermanent_r3000	{#ch06.228}

**filename:** `FarmlandGrassland_GrasslandsPermanent_r3000.tif`	

**layername:** `egv_228`	

**English name:** Fractional cover of Permanent Grassland within the 3 km landscape

**Latvian name:** Ilggadīgu zālāju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.225) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsPermanent"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsPermanent_r3000.tif	egv_228
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r3000.tif")
names(slanis)="egv_228"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsPermanent_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_228.png")
```


## FarmlandGrassland_GrasslandsPermanent_r10000	{#ch06.229}

**filename:** `FarmlandGrassland_GrasslandsPermanent_r10000.tif`	

**layername:** `egv_229`	

**English name:** Fractional cover of Permanent Grassland within the 10 km landscape

**Latvian name:** Ilggadīgu zālāju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.225) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsPermanent"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsPermanent_r10000.tif	egv_229
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r10000.tif")
names(slanis)="egv_229"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsPermanent_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_229.png")
```


## FarmlandGrassland_GrasslandsTemporary_cell	{#ch06.230}

**filename:** `FarmlandGrassland_GrasslandsTemporary_cell.tif`	

**layername:** `egv_230`	

**English name:** Fractional cover of Temporary Grassland within the analysis cell (1 ha)

**Latvian name:** Zālāju-aramzemē platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as grasslands in arable lands were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). These geometries 
were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandGrassland_GrasslandsTemporary_cell.tif	egv_230 ----
dati=lad %>% 
  filter(str_detect(SDM_grupa_sakums,"kultivēt"))
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandGrassland_GrasslandsTemporary_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandGrassland_GrasslandsTemporary_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandGrassland_GrasslandsTemporary_cell.tif",
                            layername = "egv_230",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandGrassland_GrasslandsTemporary_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsTemporary_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_230.png")
```


## FarmlandGrassland_GrasslandsTemporary_r500	{#ch06.231}

**filename:** `FarmlandGrassland_GrasslandsTemporary_r500.tif`	

**layername:** `egv_231`	

**English name:** Fractional cover of Temporary Grassland within the 0.5 km landscape

**Latvian name:** Zālāju-aramzemē platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.230) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsTemporary"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsTemporary_r500.tif	egv_231
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r500.tif")
names(slanis)="egv_231"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsTemporary_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_231.png")
```


## FarmlandGrassland_GrasslandsTemporary_r1250	{#ch06.232}

**filename:** `FarmlandGrassland_GrasslandsTemporary_r1250.tif`	

**layername:** `egv_232`	

**English name:** Fractional cover of Temporary Grassland within the 1.25 km landscape

**Latvian name:** Zālāju-aramzemē platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.230) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsTemporary"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsTemporary_r1250.tif	egv_232
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r1250.tif")
names(slanis)="egv_232"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsTemporary_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_232.png")
```


## FarmlandGrassland_GrasslandsTemporary_r3000	{#ch06.233}

**filename:** `FarmlandGrassland_GrasslandsTemporary_r3000.tif`	

**layername:** `egv_233`	

**English name:** Fractional cover of Temporary Grassland within the 3 km landscape

**Latvian name:** Zālāju-aramzemē platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.230) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsTemporary"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsTemporary_r3000.tif	egv_233
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r3000.tif")
names(slanis)="egv_233"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsTemporary_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_233.png")
```


## FarmlandGrassland_GrasslandsTemporary_r10000	{#ch06.234}

**filename:** `FarmlandGrassland_GrasslandsTemporary_r10000.tif`	

**layername:** `egv_234`	

**English name:** Fractional cover of Temporary Grassland within the 10 km landscape

**Latvian name:** Zālāju-aramzemē platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.230) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif"),
  layer_prefixes = c("FarmlandGrassland_GrasslandsTemporary"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandGrassland_GrasslandsTemporary_r10000.tif	egv_234
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r10000.tif")
names(slanis)="egv_234"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandGrassland_GrasslandsTemporary_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_234.png")
```


## FarmlandParcels_FieldsActive_cell	{#ch06.235}

**filename:** `FarmlandParcels_FieldsActive_cell.tif`	

**layername:** `egv_235`	

**English name:** Fractional cover of Agricultural Land Parcels within the analysis cell (1 ha)

**Latvian name:** Lauku bloku platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels from 
[Rural Support Service's information on declared fields](#Ch04.02) 
were rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandParcels_FieldsActive_cell.tif	egv_235 ----
p2i_rez=egvtools::polygon2input(vector_data = lad,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandParcels_FieldsActive_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandParcels_FieldsActive_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandParcels_FieldsActive_cell.tif",
                            layername = "egv_235",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandParcels_FieldsActive_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandParcels_FieldsActive_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_235.png")
```


## FarmlandParcels_FieldsActive_r500	{#ch06.236}

**filename:** `FarmlandParcels_FieldsActive_r500.tif`	

**layername:** `egv_236`	

**English name:** Fractional cover of Agricultural Land Parcels within the 0.5 km landscape

**Latvian name:** Lauku bloku platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.235) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif"),
  layer_prefixes = c("FarmlandParcels_FieldsActive"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandParcels_FieldsActive_r500.tif	egv_236
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r500.tif")
names(slanis)="egv_236"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandParcels_FieldsActive_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_236.png")
```


## FarmlandParcels_FieldsActive_r1250	{#ch06.237}

**filename:** `FarmlandParcels_FieldsActive_r1250.tif`	

**layername:** `egv_237`	

**English name:** Fractional cover of Agricultural Land Parcels within the 1.25 km landscape

**Latvian name:** Lauku bloku platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.235) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif"),
  layer_prefixes = c("FarmlandParcels_FieldsActive"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandParcels_FieldsActive_r1250.tif	egv_237
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r1250.tif")
names(slanis)="egv_237"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandParcels_FieldsActive_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_237.png")
```


## FarmlandParcels_FieldsActive_r3000	{#ch06.238}

**filename:** `FarmlandParcels_FieldsActive_r3000.tif`	

**layername:** `egv_238`	

**English name:** Fractional cover of Agricultural Land Parcels within the 3 km landscape

**Latvian name:** Lauku bloku platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.235) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif"),
  layer_prefixes = c("FarmlandParcels_FieldsActive"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandParcels_FieldsActive_r3000.tif	egv_238
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r3000.tif")
names(slanis)="egv_238"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandParcels_FieldsActive_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_238.png")
```


## FarmlandParcels_FieldsActive_r10000	{#ch06.239}

**filename:** `FarmlandParcels_FieldsActive_r10000.tif`	

**layername:** `egv_239`	

**English name:** Fractional cover of Agricultural Land Parcels within the 10 km landscape

**Latvian name:** Lauku bloku platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.235) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif"),
  layer_prefixes = c("FarmlandParcels_FieldsActive"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandParcels_FieldsActive_r10000.tif	egv_239
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r10000.tif")
names(slanis)="egv_239"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandParcels_FieldsActive_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_239.png")
```


## FarmlandPloughed_CropsFallow_cell	{#ch06.240}

**filename:** `FarmlandPloughed_CropsFallow_cell.tif`	

**layername:** `egv_240`	

**English name:** Fractional cover of Crop-, Fallow- Land within the analysis cell (1 ha)

**Latvian name:** Aramzemju, papuvju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as crops or fallow land were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandPloughed_CropsFallow_cell.tif	egv_240 ----
dati=lad %>% 
  filter(SDM_grupa_sakums %in% c("aramzemes (citur neiekļautās)",
                                 "aramzemes (labība-vasarāji)",
                                 "aramzemes (labība-ziemāji)",
                                 "aramzemes (vagu un rušināmkultūru)",
                                 "aramzemes (vasaras rapsis un rispsis, kukurūzas, zirņi un pupas, soja, kaņepes)",
                                 "aramzemes (ziemas rapsis un ripsis)",
                                 "papuves"))
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandPloughed_CropsFallow_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandPloughed_CropsFallow_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandPloughed_CropsFallow_cell.tif",
                            layername = "egv_240",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandPloughed_CropsFallow_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallow_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_240.png")
```


## FarmlandPloughed_CropsFallow_r500	{#ch06.241}

**filename:** `FarmlandPloughed_CropsFallow_r500.tif`	

**layername:** `egv_241`	

**English name:** Fractional cover of Crop-, Fallow- Land within the 0.5 km landscape

**Latvian name:** Aramzemju, papuvju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.240) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallow_r500.tif	egv_241
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r500.tif")
names(slanis)="egv_241"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallow_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_241.png")
```


## FarmlandPloughed_CropsFallow_r1250	{#ch06.242}

**filename:** `FarmlandPloughed_CropsFallow_r1250.tif`	

**layername:** `egv_242`	

**English name:** Fractional cover of Crop-, Fallow- Land within the 1.25 km landscape

**Latvian name:** Aramzemju, papuvju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.240) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallow_r1250.tif	egv_242
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r1250.tif")
names(slanis)="egv_242"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallow_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_242.png")
```


## FarmlandPloughed_CropsFallow_r3000	{#ch06.243}

**filename:** `FarmlandPloughed_CropsFallow_r3000.tif`	

**layername:** `egv_243`	

**English name:** Fractional cover of Crop-, Fallow- Land within the 3 km landscape

**Latvian name:** Aramzemju, papuvju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.240) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallow_r3000.tif	egv_243
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r3000.tif")
names(slanis)="egv_243"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallow_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_243.png")
```


## FarmlandPloughed_CropsFallow_r10000	{#ch06.244}

**filename:** `FarmlandPloughed_CropsFallow_r10000.tif`	

**layername:** `egv_244`	

**English name:** Fractional cover of Crop-, Fallow- Land within the 10 km landscape

**Latvian name:** Aramzemju, papuvju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.240) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallow_r10000.tif	egv_244
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r10000.tif")
names(slanis)="egv_244"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallow_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_244.png")
```


## FarmlandPloughed_CropsFallowTempGrass_cell	{#ch06.245}

**filename:** `FarmlandPloughed_CropsFallowTempGrass_cell.tif`	

**layername:** `egv_245`	

**English name:** Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the analysis cell (1 ha)

**Latvian name:** Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as crops, fallow land or grasslands in arable land were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandPloughed_CropsFallowTempGrass_cell.tif	egv_245 ----
dati=lad %>% 
  filter(SDM_grupa_sakums %in% c("aramzemes (citur neiekļautās)",
                                 "aramzemes (labība-vasarāji)",
                                 "aramzemes (labība-ziemāji)",
                                 "aramzemes (vagu un rušināmkultūru)",
                                 "aramzemes (vasaras rapsis un rispsis, kukurūzas, zirņi un pupas, soja, kaņepes)",
                                 "aramzemes (ziemas rapsis un ripsis)",
                                 "papuves",
                                 "zālāji (kultivētie)"))
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandPloughed_CropsFallowTempGrass_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandPloughed_CropsFallowTempGrass_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandPloughed_CropsFallowTempGrass_cell.tif",
                            layername = "egv_245",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandPloughed_CropsFallowTempGrass_input.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallowTempGrass_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_245.png")
```


## FarmlandPloughed_CropsFallowTempGrass_r500	{#ch06.246}

**filename:** `FarmlandPloughed_CropsFallowTempGrass_r500.tif`	

**layername:** `egv_246`	

**English name:** Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 0.5 km landscape

**Latvian name:** Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.245) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallowTempGrass"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallowTempGrass_r500.tif	egv_246
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r500.tif")
names(slanis)="egv_246"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallowTempGrass_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_246.png")
```


## FarmlandPloughed_CropsFallowTempGrass_r1250	{#ch06.247}

**filename:** `FarmlandPloughed_CropsFallowTempGrass_r1250.tif`	

**layername:** `egv_247`	

**English name:** Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 1.25 km landscape

**Latvian name:** Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.245) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallowTempGrass"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallowTempGrass_r1250.tif	egv_247
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r1250.tif")
names(slanis)="egv_247"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallowTempGrass_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_247.png")
```


## FarmlandPloughed_CropsFallowTempGrass_r3000	{#ch06.248}

**filename:** `FarmlandPloughed_CropsFallowTempGrass_r3000.tif`	

**layername:** `egv_248`	

**English name:** Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 3 km landscape

**Latvian name:** Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.245) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallowTempGrass"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallowTempGrass_r3000.tif	egv_248
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r3000.tif")
names(slanis)="egv_248"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallowTempGrass_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_248.png")
```


## FarmlandPloughed_CropsFallowTempGrass_r10000	{#ch06.249}

**filename:** `FarmlandPloughed_CropsFallowTempGrass_r10000.tif`	

**layername:** `egv_249`	

**English name:** Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 10 km landscape

**Latvian name:** Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.245) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_CropsFallowTempGrass"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_CropsFallowTempGrass_r10000.tif	egv_249
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r10000.tif")
names(slanis)="egv_249"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_CropsFallowTempGrass_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_249.png")
```


## FarmlandPloughed_Fallow_cell	{#ch06.250}

**filename:** `FarmlandPloughed_Fallow_cell.tif`	

**layername:** `egv_250`	

**English name:** Fractional cover of Fallow Land within the analysis cell (1 ha)

**Latvian name:** Papuvju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as fallow land were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandPloughed_Fallow_cell.tif	egv_250 ----
dati=lad %>% 
  filter(SDM_grupa_sakums == "papuves")
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandPloughed_Fallow_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandPloughed_Fallow_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandPloughed_Fallow_cell.tif",
                            layername = "egv_250",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandPloughed_Fallow_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_Fallow_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_250.png")
```


## FarmlandPloughed_Fallow_r500	{#ch06.251}

**filename:** `FarmlandPloughed_Fallow_r500.tif`	

**layername:** `egv_251`	

**English name:** Fractional cover of Fallow Land within the 0.5 km landscape

**Latvian name:** Papuvju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.250) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_Fallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_Fallow_r500.tif	egv_251
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r500.tif")
names(slanis)="egv_251"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_Fallow_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_251.png")
```


## FarmlandPloughed_Fallow_r1250	{#ch06.252}

**filename:** `FarmlandPloughed_Fallow_r1250.tif`	

**layername:** `egv_252`	

**English name:** Fractional cover of Fallow Land within the 1.25 km landscape

**Latvian name:** Papuvju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.250) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_Fallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_Fallow_r1250.tif	egv_252
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r1250.tif")
names(slanis)="egv_252"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_Fallow_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_252.png")
```


## FarmlandPloughed_Fallow_r3000	{#ch06.253}

**filename:** `FarmlandPloughed_Fallow_r3000.tif`	

**layername:** `egv_253`	

**English name:** Fractional cover of Fallow Land within the 3 km landscape

**Latvian name:** Papuvju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.250) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_Fallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_Fallow_r3000.tif	egv_253
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r3000.tif")
names(slanis)="egv_253"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_Fallow_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_253.png")
```


## FarmlandPloughed_Fallow_r10000	{#ch06.254}

**filename:** `FarmlandPloughed_Fallow_r10000.tif`	

**layername:** `egv_254`	

**English name:** Fractional cover of Fallow Land within the 10 km landscape

**Latvian name:** Papuvju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.250) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif"),
  layer_prefixes = c("FarmlandPloughed_Fallow"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandPloughed_Fallow_r10000.tif	egv_254
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r10000.tif")
names(slanis)="egv_254"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandPloughed_Fallow_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_254.png")
```


## FarmlandSubsidies_BiologicalSubsidies_cell	{#ch06.255}

**filename:** `FarmlandSubsidies_BiologicalSubsidies_cell.tif`	

**layername:** `egv_255`	

**English name:** Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the analysis cell (1 ha)

**Latvian name:** Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as receiving subsidies for biological agriculture were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandSubsidies_BiologicalSubsidies_cell.tif	egv_255 ----
dati=lad %>% 
  filter(str_detect(AID_FORMS,"BLA"))
table(dati$AID_FORMS,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandSubsidies_BiologicalSubsidies_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandSubsidies_BiologicalSubsidies_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandSubsidies_BiologicalSubsidies_cell.tif",
                            layername = "egv_255",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandSubsidies_BiologicalSubsidies_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandSubsidies_BiologicalSubsidies_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_255.png")
```


## FarmlandSubsidies_BiologicalSubsidies_r500	{#ch06.256}

**filename:** `FarmlandSubsidies_BiologicalSubsidies_r500.tif`	

**layername:** `egv_256`	

**English name:** Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 0.5 km landscape

**Latvian name:** Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.255) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif"),
  layer_prefixes = c("FarmlandSubsidies_BiologicalSubsidies"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandSubsidies_BiologicalSubsidies_r500.tif	egv_256
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r500.tif")
names(slanis)="egv_256"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandSubsidies_BiologicalSubsidies_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_256.png")
```


## FarmlandSubsidies_BiologicalSubsidies_r1250	{#ch06.257}

**filename:** `FarmlandSubsidies_BiologicalSubsidies_r1250.tif`	

**layername:** `egv_257`	

**English name:** Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 1.25 km landscape

**Latvian name:** Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.255) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif"),
  layer_prefixes = c("FarmlandSubsidies_BiologicalSubsidies"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandSubsidies_BiologicalSubsidies_r1250.tif	egv_257
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r1250.tif")
names(slanis)="egv_257"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandSubsidies_BiologicalSubsidies_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_257.png")
```


## FarmlandSubsidies_BiologicalSubsidies_r3000	{#ch06.258}

**filename:** `FarmlandSubsidies_BiologicalSubsidies_r3000.tif`	

**layername:** `egv_258`	

**English name:** Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 3 km landscape

**Latvian name:** Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.255) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif"),
  layer_prefixes = c("FarmlandSubsidies_BiologicalSubsidies"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandSubsidies_BiologicalSubsidies_r3000.tif	egv_258
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r3000.tif")
names(slanis)="egv_258"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandSubsidies_BiologicalSubsidies_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_258.png")
```


## FarmlandSubsidies_BiologicalSubsidies_r10000	{#ch06.259}

**filename:** `FarmlandSubsidies_BiologicalSubsidies_r10000.tif`	

**layername:** `egv_259`	

**English name:** Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 10 km landscape

**Latvian name:** Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.255) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif"),
  layer_prefixes = c("FarmlandSubsidies_BiologicalSubsidies"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandSubsidies_BiologicalSubsidies_r10000.tif	egv_259
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r10000.tif")
names(slanis)="egv_259"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandSubsidies_BiologicalSubsidies_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_259.png")
```


## FarmlandTrees_PermanentCrops_cell	{#ch06.260}

**filename:** `FarmlandTrees_PermanentCrops_cell.tif`	

**layername:** `egv_260`	

**English name:** Fractional cover of Permanent Crops within the analysis cell (1 ha)

**Latvian name:** Augļudārzu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as permanent crops were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandTrees_PermanentCrops_cell.tif	egv_260 ----
dati=lad %>% 
  filter(SDM_grupa_sakums == "augļudārzi")
table(dati$SDM_grupa_sakums,useNA="always")
dati=dati %>% 
  dplyr::select(yes)

topo=sfarrow::st_read_parquet("./Geodata/2024/TopographicMap/LandusA_COMB.parquet")
dati_topo= topo %>% 
  filter(FNAME %in% c("poligons_Augludarzs","poligons_Augļudārzs",
                      "poligons_Ogulājs","poligons_Ogulajs")) %>% 
  mutate(yes=1) %>% 
  dplyr::select(yes)
abidati=rbind(dati,dati_topo)

p2i_rez=egvtools::polygon2input(vector_data = abidati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandTrees_PermanentCrops_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandTrees_PermanentCrops_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandTrees_PermanentCrops_cell.tif",
                            layername = "egv_260",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
rm(topo)
rm(dati_topo)
rm(abidati)
unlink("./RasterGrids_10m/2024/FarmlandTrees_PermanentCrops_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_PermanentCrops_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_260.png")
```


## FarmlandTrees_PermanentCrops_r500	{#ch06.261}

**filename:** `FarmlandTrees_PermanentCrops_r500.tif`	

**layername:** `egv_261`	

**English name:** Fractional cover of Permanent Crops within the 0.5 km landscape

**Latvian name:** Augļudārzu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.260) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif"),
  layer_prefixes = c("FarmlandTrees_PermanentCrops"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_PermanentCrops_r500.tif	egv_261
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r500.tif")
names(slanis)="egv_261"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_PermanentCrops_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_261.png")
```


## FarmlandTrees_PermanentCrops_r1250	{#ch06.262}

**filename:** `FarmlandTrees_PermanentCrops_r1250.tif`	

**layername:** `egv_262`	

**English name:** Fractional cover of Permanent Crops within the 1.25 km landscape

**Latvian name:** Augļudārzu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.260) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif"),
  layer_prefixes = c("FarmlandTrees_PermanentCrops"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_PermanentCrops_r1250.tif	egv_262
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r1250.tif")
names(slanis)="egv_262"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_PermanentCrops_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_262.png")
```


## FarmlandTrees_PermanentCrops_r3000	{#ch06.263}

**filename:** `FarmlandTrees_PermanentCrops_r3000.tif`	

**layername:** `egv_263`	

**English name:** Fractional cover of Permanent Crops within the 3 km landscape

**Latvian name:** Augļudārzu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.260) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif"),
  layer_prefixes = c("FarmlandTrees_PermanentCrops"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_PermanentCrops_r3000.tif	egv_263
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r3000.tif")
names(slanis)="egv_263"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_PermanentCrops_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_263.png")
```



## FarmlandTrees_PermanentCrops_r10000	{#ch06.264}

**filename:** `FarmlandTrees_PermanentCrops_r10000.tif`	

**layername:** `egv_264`	

**English name:** Fractional cover of Permanent Crops within the 10 km landscape

**Latvian name:** Augļudārzu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.260) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif"),
  layer_prefixes = c("FarmlandTrees_PermanentCrops"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_PermanentCrops_r10000.tif	egv_264
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r10000.tif")
names(slanis)="egv_264"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_PermanentCrops_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_264.png")
```


## FarmlandTrees_ShortRotationCoppice_cell	{#ch06.265}

**filename:** `FarmlandTrees_ShortRotationCoppice_cell.tif`	

**layername:** `egv_265`	

**English name:** Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the analysis cell (1 ha)

**Latvian name:** Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as short rotation coppice were selected from 
[Rural Support Service's information on declared fields](#Ch04.02). 
Geometries were then rasterized to input resolution, ensuring value 1 at the polygon locations 
and value 0 elsewhere. Rasterization was performed with `egvtools::polygon2input()`. 
Once rasterized, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# FarmlandTrees_ShortRotationCoppice_cell.tif	egv_265 ----
dati=lad %>% 
  filter(SDM_grupa_sakums == "krūmveida ilggadīgie stādījumi")
table(dati$SDM_grupa_sakums,useNA="always")

p2i_rez=egvtools::polygon2input(vector_data = dati,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "FarmlandTrees_ShortRotationCoppice_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "FarmlandTrees_ShortRotationCoppice_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "FarmlandTrees_ShortRotationCoppice_cell.tif",
                            layername = "egv_265",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(p2i_rez)
rm(i2e_rez)
rm(dati)
unlink("./RasterGrids_10m/2024/FarmlandTrees_ShortRotationCoppice_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_ShortRotationCoppice_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_265.png")
```


## FarmlandTrees_ShortRotationCoppice_r500	{#ch06.266}

**filename:** `FarmlandTrees_ShortRotationCoppice_r500.tif`	

**layername:** `egv_266`	

**English name:** Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 0.5 km landscape

**Latvian name:** Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.265) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif"),
  layer_prefixes = c("FarmlandTrees_ShortRotationCoppice"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_ShortRotationCoppice_r500.tif	egv_266
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r500.tif")
names(slanis)="egv_266"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_ShortRotationCoppice_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_266.png")
```


## FarmlandTrees_ShortRotationCoppice_r1250	{#ch06.267}

**filename:** `FarmlandTrees_ShortRotationCoppice_r1250.tif`	

**layername:** `egv_267`	

**English name:** Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 1.25 km landscape

**Latvian name:** Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.265) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif"),
  layer_prefixes = c("FarmlandTrees_ShortRotationCoppice"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_ShortRotationCoppice_r1250.tif	egv_267
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r1250.tif")
names(slanis)="egv_267"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_ShortRotationCoppice_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_267.png")
```


## FarmlandTrees_ShortRotationCoppice_r3000	{#ch06.268}

**filename:** `FarmlandTrees_ShortRotationCoppice_r3000.tif`	

**layername:** `egv_268`	

**English name:** Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 3 km landscape

**Latvian name:** Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.265) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif"),
  layer_prefixes = c("FarmlandTrees_ShortRotationCoppice"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_ShortRotationCoppice_r3000.tif	egv_268
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r3000.tif")
names(slanis)="egv_268"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
nosaukums="FarmlandTrees_ShortRotationCoppice_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_268.png")
```


## FarmlandTrees_ShortRotationCoppice_r10000	{#ch06.269}

**filename:** `FarmlandTrees_ShortRotationCoppice_r10000.tif`	

**layername:** `egv_269`	

**English name:** Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 10 km landscape

**Latvian name:** Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.265) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif"),
  layer_prefixes = c("FarmlandTrees_ShortRotationCoppice"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# FarmlandTrees_ShortRotationCoppice_r10000.tif	egv_269
slanis=rast("./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r10000.tif")
names(slanis)="egv_269"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="FarmlandTrees_ShortRotationCoppice_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_269.png")
```


## ForestsAge_ClearcutsLowStands_cell	{#ch06.270}

**filename:** `ForestsAge_ClearcutsLowStands_cell.tif`	

**layername:** `egv_270`	

**English name:** Fractional cover of Clearcuts and Stands lower than 5 m within the analysis cell (1 ha)	

**Latvian name:** Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 
To prepare this EGV, stands in land category 10 and 
lower than 5 m were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized. After rasterization, this layer was covered over 
clear cut mask. The resulting layer was then aggregated to EGV resolution 
with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsAge_ClearcutsLowStands_cell.tif	egv_270 ----
zemas_audzes=mvr %>% 
  filter(zkat=="10") %>% 
  filter(h10<5) %>% 
  dplyr::select(yes)
r_zemasaudzes=fasterize(zemas_audzes,rastrs10,field="yes")
t_zemasaudzes=rast(r_zemasaudzes)
plot(t_zemasaudzes)

cleacuts_low=cover(t_zemasaudzes,clearcut_mask)
plot(cleacuts_low)

i2e_rez=egvtools::input2egv(input=cleacuts_low,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsAge_ClearcutsLowStands_cell.tif",
                            layername = "egv_270",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(i2e_rez)
rm(zemas_audzes)
rm(r_zemasaudzes)
rm(t_zemasaudzes)
rm(cleacuts_low)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_ClearcutsLowStands_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_270.png")
```


## ForestsAge_ClearcutsLowStands_r500	{#ch06.271}

**filename:** `ForestsAge_ClearcutsLowStands_r500.tif`	

**layername:** `egv_271`	

**English name:** Fractional cover of Clearcuts and Stands lower than 5 m within the 0.5 km landscape	

**Latvian name:** Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.270) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif"),
  layer_prefixes = c("ForestsAge_ClearcutsLowStands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_ClearcutsLowStands_r500.tif	egv_271
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r500.tif")
names(slanis)="egv_271"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_ClearcutsLowStands_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_271.png")
```


## ForestsAge_ClearcutsLowStands_r1250	{#ch06.272}

**filename:** `ForestsAge_ClearcutsLowStands_r1250.tif`	

**layername:** `egv_272`	

**English name:** Fractional cover of Clearcuts and Stands lower than 5 m within the 1.25 km landscape	

**Latvian name:** Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.270) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif"),
  layer_prefixes = c("ForestsAge_ClearcutsLowStands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_ClearcutsLowStands_r1250.tif	egv_272
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r1250.tif")
names(slanis)="egv_272"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_ClearcutsLowStands_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_272.png")
```


## ForestsAge_ClearcutsLowStands_r3000	{#ch06.273}

**filename:** `ForestsAge_ClearcutsLowStands_r3000.tif`	

**layername:** `egv_273`	

**English name:** Fractional cover of Clearcuts and Stands lower than 5 m within the 3 km landscape	

**Latvian name:** Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.270) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif"),
  layer_prefixes = c("ForestsAge_ClearcutsLowStands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_ClearcutsLowStands_r3000.tif	egv_273
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r3000.tif")
names(slanis)="egv_273"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_ClearcutsLowStands_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_273.png")
```


## ForestsAge_ClearcutsLowStands_r10000	{#ch06.274}

**filename:** `ForestsAge_ClearcutsLowStands_r10000.tif`	

**layername:** `egv_274`	

**English name:** Fractional cover of Clearcuts and Stands lower than 5 m within the 10 km landscape	

**Latvian name:** Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.270) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif"),
  layer_prefixes = c("ForestsAge_ClearcutsLowStands"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_ClearcutsLowStands_r10000.tif	egv_274
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r10000.tif")
names(slanis)="egv_274"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_ClearcutsLowStands_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_274.png")
```


## ForestsAge_Middle_cell	{#ch06.275}

**filename:** `ForestsAge_Middle_cell.tif`	

**layername:** `egv_275`	

**English name:** Fractional cover of Middle-Aged Forests within the analysis cell (1 ha)	

**Latvian name:** Vidēja vecuma un briestaudžu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 
To prepare this EGV, stands in land category 10 and 
age groups two and three were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized. Rasterization was performed with 
`egvtools::polygon2input()` (presence = 1, absence = 0) restricting presence 
locations only outside the clear cut mask. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsAge_Middle_cell.tif	egv_275 ----
videjas_audzes=mvr %>% 
  filter(zkat=="10") %>% 
  #filter(h10>=5) %>% 
  filter(vgr %in% c("2","3")) %>% 
  dplyr::select(yes)

p2i_rez=egvtools::polygon2input(vector_data = videjas_audzes,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsAge_Middle_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsAge_Middle_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsAge_Middle_cell.tif",
                            layername = "egv_275",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(videjas_audzes)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsAge_Middle_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Middle_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_275.png")
```


## ForestsAge_Middle_r500	{#ch06.276}

**filename:** `ForestsAge_Middle_r500.tif`	

**layername:** `egv_276`	

**English name:** Fractional cover of Middle-Aged Forests within the 0.5 km landscape	

**Latvian name:** Vidēja vecuma un briestaudžu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.275) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif"),
  layer_prefixes = c("ForestsAge_Middle"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Middle_r500.tif	egv_276
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r500.tif")
names(slanis)="egv_276"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Middle_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_276.png")
```


## ForestsAge_Middle_r1250	{#ch06.277}

**filename:** `ForestsAge_Middle_r1250.tif`	

**layername:** `egv_277`	

**English name:** Fractional cover of Middle-Aged Forests within the 1.25 km landscape	

**Latvian name:** Vidēja vecuma un briestaudžu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.275) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif"),
  layer_prefixes = c("ForestsAge_Middle"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Middle_r1250.tif	egv_277
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r1250.tif")
names(slanis)="egv_277"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Middle_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_277.png")
```


## ForestsAge_Middle_r3000	{#ch06.278}

**filename:** `ForestsAge_Middle_r3000.tif`	

**layername:** `egv_278`	

**English name:** Fractional cover of Middle-Aged Forests within the 3 km landscape	

**Latvian name:** Vidēja vecuma un briestaudžu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.275) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif"),
  layer_prefixes = c("ForestsAge_Middle"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Middle_r3000.tif	egv_278
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r3000.tif")
names(slanis)="egv_278"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Middle_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_278.png")
```


## ForestsAge_Middle_r10000	{#ch06.279}

**filename:** `ForestsAge_Middle_r10000.tif`	

**layername:** `egv_279`	

**English name:** Fractional cover of Middle-Aged Forests within the 10 km landscape	

**Latvian name:** Vidēja vecuma un briestaudžu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.275) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif"),
  layer_prefixes = c("ForestsAge_Middle"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Middle_r10000.tif	egv_279
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r10000.tif")
names(slanis)="egv_279"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Middle_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_279.png")
```


## ForestsAge_Old_cell	{#ch06.280}

**filename:** `ForestsAge_Old_cell.tif`	

**layername:** `egv_280`	

**English name:** Fractional cover of Old (over rotation age) Forests within the analysis cell (1 ha)	

**Latvian name:** Vecu (kopš cirtmeta) mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 
To prepare this EGV, stands in land category 10 and 
age groups four and five were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized. Rasterization was performed with 
`egvtools::polygon2input()` (presence = 1, absence = 0) restricting presence 
locations only outside the clear cut mask. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsAge_Old_cell.tif	egv_280 ----
vecas=mvr %>% 
  filter(zkat=="10") %>% 
  #filter(h10>=5) %>% 
  filter(vgr %in% c("4","5")) %>% 
  dplyr::select(yes)

p2i_rez=egvtools::polygon2input(vector_data = vecas,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsAge_Old_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsAge_Old_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsAge_Old_cell.tif",
                            layername = "egv_280",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(vecas)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsAge_Old_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Old_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_280.png")
```


## ForestsAge_Old_r500	{#ch06.281}

**filename:** `ForestsAge_Old_r500.tif`	

**layername:** `egv_281`	

**English name:** Fractional cover of Old (over rotation age) Forests within the 0.5 km landscape		

**Latvian name:** Vecu (kopš cirtmeta) mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.280) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif"),
  layer_prefixes = c("ForestsAge_Old"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Old_r500.tif	egv_281
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Old_r500.tif")
names(slanis)="egv_281"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Old_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Old_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_281.png")
```


## ForestsAge_Old_r1250	{#ch06.282}

**filename:** `ForestsAge_Old_r1250.tif`	

**layername:** `egv_282`	

**English name:** Fractional cover of Old (over rotation age) Forests within the 1.25 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.280) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif"),
  layer_prefixes = c("ForestsAge_Old"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Old_r1250.tif	egv_282
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Old_r1250.tif")
names(slanis)="egv_282"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Old_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Old_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_282.png")
```


## ForestsAge_Old_r3000	{#ch06.283}

**filename:** `ForestsAge_Old_r3000.tif`	

**layername:** `egv_283`	

**English name:** Fractional cover of Old (over rotation age) Forests within the 3 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.280) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif"),
  layer_prefixes = c("ForestsAge_Old"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Old_r3000.tif	egv_283
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Old_r3000.tif")
names(slanis)="egv_283"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Old_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Old_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_283.png")
```


## ForestsAge_Old_r10000	{#ch06.284}

**filename:** `ForestsAge_Old_r10000.tif`	

**layername:** `egv_284`	

**English name:** Fractional cover of Old (over rotation age) Forests within the 10 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.280) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif"),
  layer_prefixes = c("ForestsAge_Old"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_Old_r10000.tif	egv_284
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_Old_r10000.tif")
names(slanis)="egv_284"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_Old_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_Old_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_284.png")
```


## ForestsAge_YoungTallStandsShrubs_cell	{#ch06.285}

**filename:** `ForestsAge_YoungTallStandsShrubs_cell.tif`	

**layername:** `egv_285`	

**English name:** Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the analysis cell (1 ha)	

**Latvian name:** Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 
To prepare this EGV, stands in land category 10 and 
age group 1 with height above 5 m were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). This layer was then covered category 
620 from [Landscape classification](#Ch05.03) (presence = 1, 0 otherwise). Values 
in pixels matching clearcut mask were set to 0. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsAge_YoungTallStandsShrubs_cell.tif	egv_285 ----
jaunasaugstas=mvr %>% 
  filter(zkat=="10") %>% 
  filter(h10>=5) %>% 
  filter(vgr %in% c("1")) %>% 
  dplyr::select(yes)
r_jaunasaugstas=fasterize(jaunasaugstas,rastrs10,field="yes")
t_jaunasaugstas=rast(r_jaunasaugstas)
plot(t_jaunasaugstas)

shrubs=ifel(simple_landscape==620,1,0)

younshrubs=cover(t_jaunasaugstas,shrubs)
plot(younshrubs)

younshrubs2=ifel(younshrubs==1&clearcut_mask==0,1,0)
plot(younshrubs2)

i2e_rez=egvtools::input2egv(input=younshrubs2,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsAge_YoungTallStandsShrubs_cell.tif",
                            layername = "egv_285",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(jaunasaugstas)
rm(r_jaunasaugstas)
rm(t_jaunasaugstas)
rm(shrubs)
rm(younshrubs)
rm(younshrubs2)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_YoungTallStandsShrubs_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_285.png")
```


## ForestsAge_YoungTallStandsShrubs_r500	{#ch06.286}

**filename:** `ForestsAge_YoungTallStandsShrubs_r500.tif`	

**layername:** `egv_286`	

**English name:** Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 0.5 km landscape	

**Latvian name:** Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.285) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif"),
  layer_prefixes = c("ForestsAge_YoungTallStandsShrubs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_YoungTallStandsShrubs_r500.tif	egv_286
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r500.tif")
names(slanis)="egv_286"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_YoungTallStandsShrubs_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_286.png")
```


## ForestsAge_YoungTallStandsShrubs_r1250	{#ch06.287}

**filename:** `ForestsAge_YoungTallStandsShrubs_r1250.tif`	

**layername:** `egv_287`	

**English name:** Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 1.25 km landscape	

**Latvian name:** Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.285) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif"),
  layer_prefixes = c("ForestsAge_YoungTallStandsShrubs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_YoungTallStandsShrubs_r1250.tif	egv_287
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r1250.tif")
names(slanis)="egv_287"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_YoungTallStandsShrubs_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_287.png")
```


## ForestsAge_YoungTallStandsShrubs_r3000	{#ch06.288}

**filename:** `ForestsAge_YoungTallStandsShrubs_r3000.tif`	

**layername:** `egv_288`	

**English name:** Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 3 km landscape	

**Latvian name:** Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.285) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif"),
  layer_prefixes = c("ForestsAge_YoungTallStandsShrubs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_YoungTallStandsShrubs_r3000.tif	egv_288
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r3000.tif")
names(slanis)="egv_288"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_YoungTallStandsShrubs_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_288.png")
```


## ForestsAge_YoungTallStandsShrubs_r10000	{#ch06.289}

**filename:** `ForestsAge_YoungTallStandsShrubs_r10000.tif`	

**layername:** `egv_289`	

**English name:** Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 10 km landscape	

**Latvian name:** Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.285) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif"),
  layer_prefixes = c("ForestsAge_YoungTallStandsShrubs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsAge_YoungTallStandsShrubs_r10000.tif	egv_289
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r10000.tif")
names(slanis)="egv_289"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsAge_YoungTallStandsShrubs_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_289.png")
```


## ForestsQuant_AgeProp-average_cell	{#ch06.290}

**filename:** `ForestsQuant_AgeProp-average_cell.tif`	

**layername:** `egv_290`	

**English name:** Average stand age relative to rotation age within the analysis cell (1 ha)	

**Latvian name:** Mežaudzes vecuma attiecība pret cirtmetu, vidējais analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, every forest stand had assigned [legal rotation age](https://likumi.lv/ta/id/2825#p9), based on dominant tree species and bonity class 
as registered in the [State Forest Service's State Forest Registry](#Ch04.01). 35 years 
were assumed for grey alder. 
The registered age of dominant tree group was then divided by the stand specific 
legal rotation age. However, this introduced some extreme values that were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv290.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_AgeProp-average_cell.tif	egv_290 ----

#Meža likums, 9. pants. https://likumi.lv/ta/id/2825#p9
ozoli=c("10","61")
priedes_lapegles=c("1","13","14","22")
eolgvk=c("3","15","23","11","64","12","62","16","65","24","63")
berzi=c("4")
melnalksni=c("6")
apses=c("8","19","68")

bonA=c("0","1")
bonB=c("2","3")
bonC=c("4","5","6")
bonAB=c("0","1","2","3")

nogabali=mvr %>% 
  mutate(cirtmets=ifelse((s10 %in% ozoli)&(bon %in% bonA),101,
                         ifelse((s10 %in% ozoli),121,NA))) %>% 
  mutate(cirtmets=ifelse((s10 %in% priedes_lapegles)&(bon %in% bonAB),101,
                         ifelse((s10 %in% priedes_lapegles),121,cirtmets))) %>% 
  mutate(cirtmets=ifelse((s10 %in% eolgvk),81,cirtmets)) %>% 
  mutate(cirtmets=ifelse((s10 %in% berzi)&(bon %in% bonAB),71,
                         ifelse((s10 %in% berzi),51,cirtmets))) %>% 
  mutate(cirtmets=ifelse((s10 %in% melnalksni),71,cirtmets))  %>% 
  mutate(cirtmets=ifelse((s10 %in% apses),41,cirtmets))   %>% 
  mutate(cirtmets=ifelse(is.na(cirtmets)&zkat=="10",35,cirtmets)) %>% 
  mutate(nogvec=a10/cirtmets) %>% 
  mutate(nogvec2=ifelse(nogvec>3,3,nogvec)) %>% 
  filter(!is.na(nogvec2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$nogvec,main="Original",xlab="Relative age")
hist(nogabali$nogvec2,main="Limited",xlab="Relative age")
par(mfrow=c(1,1))
options(scipen=0)
# 700*400

p2i_rez=polygon2input(vector_data=nogabali,
                  template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                  out_path = "./RasterGrids_10m/2024/",
                  file_name = "ForestQuant_AgeProp.tif",
                  value_field = "nogvec2",
                  fun="max",
                  prepare=FALSE,
                  restrict_to = clearcut_mask,
                  restrict_values = 0,
                  plot_result=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestQuant_AgeProp.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "average",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_AgeProp-average_cell.tif",
                  layername = "egv_290",
                  plot_final=TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestQuant_AgeProp.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_AgeProp-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_290.png")
```


## ForestsQuant_DominantDiameter-max_cell	{#ch06.291}

**filename:** `ForestsQuant_DominantDiameter-max_cell.tif`	

**layername:** `egv_291`	

**English name:** Dominant tree trunk diameter, maximum within the analysis cell (1 ha)	

**Latvian name:** Koku stumbra diametrs, valdaudzes maksimālais analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of dominant tree species per 
inventoried forest stand - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv291.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating maximum value. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_DominantDiameter-max_cell.tif	egv_291 ----
nogabali=mvr %>% 
  mutate(valddiam=ifelse(d10>70,70,d10)) %>% 
  filter(!is.na(valddiam))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$d10,main="Original",xlab="Dominant diameter")
hist(nogabali$valddiam,main="Limited",xlab="Dominant diameter")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestQuant_DominantDiameter.tif",
                      value_field = "valddiam",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestQuant_DominantDiameter.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "max",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_DominantDiameter-max_cell.tif",
                  layername = "egv_291",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestQuant_DominantDiameter.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_DominantDiameter-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_291.png")
```


## ForestsQuant_LargestDiameter-max_cell	{#ch06.292}

**filename:** `ForestsQuant_LargestDiameter-max_cell.tif`	

**layername:** `egv_292`	

**English name:** Largest tree trunk diameter within the analysis cell (1 ha)	

**Latvian name:** Lielākais koka stumbra diametrs analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of the largest tree diameter per 
inventoried forest stand - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv292.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating maximum value. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_LargestDiameter-max_cell.tif	egv_292 ----
nogabali=mvr %>%
  rowwise() %>% 
  mutate(maxDiam=max(c(d10,d11,d12,d13,d14,d22,d23,d24),na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(maxDiam2=ifelse(maxDiam>100,100,maxDiam)) %>% 
  filter(!is.na(maxDiam2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$maxDiam,main="Original",xlab="Largest diameter")
hist(nogabali$maxDiam2,main="Limited",xlab="Largest diameter")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_LargestDiameter.tif",
                      value_field = "maxDiam2",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_LargestDiameter.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "max",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_LargestDiameter-max_cell.tif",
                  layername = "egv_292",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_LargestDiameter.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_LargestDiameter-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_292.png")
```


## ForestsQuant_TimeSinceDisturbance-average_cell	{#ch06.293}

**filename:** `ForestsQuant_TimeSinceDisturbance-average_cell.tif`	

**layername:** `egv_293`	

**English name:** Time since last disturbance affecting tree growing within the analysis cell (1 ha)	

**Latvian name:** Laiks kopš pēdējā ar koku augšanu saistītā traucējuma analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared primarily based on the information of the forestry related 
disturbances as registered per 
inventoried forest stand - [State Forest Service's State Forest Registry](#Ch04.01). 
The regiter however includes obvious errors - values later than 2024 and earlier than 
1500 were set to NA. Other values were subtracted from 2024. In stands were no 
disturbance was registered, the age of dominant tree group was used to calculate 
minimum difference (age of time since disturbance) from the year 2024. 
As values in this attribute had some extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv293.png")
```

Resulting values at polygon geometries were rasterized (presence only). This raster 
layer was then overlaid with reclassified year of tree cover loss (reclassified to 
difference from the year 2024) and per pixel minimum value was retained. As not all 
the forests or tree covered areas are inventoried, classes from [Landscape classification](#Ch05.03) 
were used to impute assumption of time since tree growing disturbance - for class 620 
five years were assumed, whereas for classes 630 and 640 - 50 years and 0 otherwise. 
Per pixel minimum layer was then overlaid the assumed time since disturbance layer. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean value. After the aggregation, inverse distance 
weighted (power = 2) gap filling was initialized to avoid possible gaps at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_TimeSinceDisturbance-average_cell.tif	egv_293 ----
nogabali=mvr %>% 
  mutate(new_PDG=ifelse(p_darbg>2024,NA,
                        ifelse(p_darbv %in% c("1","4","5","6","7","10","11"),p_darbg,NA)),
         new_PDG2=ifelse(new_PDG<1500,NA,new_PDG),
         new_PCG=ifelse(p_cirg>2024,NA,p_cirg),
         new_PCG2=ifelse(new_PCG<1500,NA,new_PCG),
         vecumam=ifelse(a10==0,NA,a10),
         new_PCG3=2024-new_PCG2,
         new_PDG3=2024-new_PDG2) %>% 
  rowwise() %>% 
  mutate(Laikam=min(c(vecumam,new_PDG3,new_PCG3),na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(KopsTraucejuma=ifelse(is.infinite(Laikam),NA,Laikam)) %>% 
  mutate(KopsTraucejuma2=ifelse(KopsTraucejuma>200,200,KopsTraucejuma)) %>% 
  filter(!is.na(KopsTraucejuma2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$KopsTraucejuma,main="Original",xlab="Time since disturbance")
hist(nogabali$KopsTraucejuma2,main="Limited",xlab="Time since disturbance")
par(mfrow=c(1,1))
options(scipen=0)

mvr_trauclaiks=fasterize::fasterize(nogabali,rastrs10,field="KopsTraucejuma2",fun = "min")
t_MVRtrauclaiks=rast(mvr_trauclaiks)
plot(t_MVRtrauclaiks)

gfw=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
plot(gfw)
gfw2=ifel(gfw>=0,24-gfw,NA)
plot(gfw2)


# No ainavas:
## Mežaudzes un koki = 50
## Krūmāji un parki = 5
## pārējais = 0
aizpildisanai=ifel(simple_landscape==630|simple_landscape==640,50,
                   ifel(simple_landscape==620,5,0))
freq(aizpildisanai)

trauclaiks1=terra::app(c(gfw2,t_MVRtrauclaiks),fun="min",na.rm=TRUE)
plot(trauclaiks1)
trauclaiks2=cover(trauclaiks1,aizpildisanai)
plot(trauclaiks2)

i2e_rez=input2egv(input=trauclaiks2,
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "average",
                  missing_job = "FillOutput",
                  idw_weight = 2,
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_TimeSinceDisturbance-average_cell.tif",
                  layername = "egv_293",
                  plot_final=TRUE)
i2e_rez
rm(nogabali)
rm(mvr_trauclaiks)
rm(t_MVRtrauclaiks)
rm(gfw)
rm(gfw2)
rm(aizpildisanai)
rm(trauclaiks1)
rm(trauclaiks2)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_TimeSinceDisturbance-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_293.png")
```


## ForestsQuant_VolumeAspen-sum_cell	{#ch06.294}

**filename:** `ForestsQuant_VolumeAspen-sum_cell.tif`	

**layername:** `egv_294`	

**English name:** Timber volume of Aspens, Poplars within the analysis cell (1 ha)	

**Latvian name:** Apšu, papeļu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
aspen (species codes: 8, 19, 68; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv294.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeAspen-sum_cell.tif	egv_294 ----

apses=c("8","19","68")
nogabali=mvr %>% 
  mutate(ApsuKraja=ifelse(s10 %in% apses, v10, 0)+ifelse(s11 %in% apses,v11,0)+
           ifelse(s12 %in% apses, v12,0)+ifelse(s13 %in% apses,v13,0)+
           ifelse(s14 %in% apses, v14,0)) %>% 
  mutate(ApsuKraja2=ApsuKraja/10000*10*10) %>% 
  mutate(ApsuKraja3=ifelse(ApsuKraja2>5,5,ApsuKraja2)) %>% 
  filter(!is.na(ApsuKraja2))


par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$ApsuKraja2,main="Original",xlab="Aspen volume")
hist(nogabali$ApsuKraja3,main="Limited",xlab="Aspen volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeAspen.tif",
                      value_field = "ApsuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeAspen.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeAspen-sum_cell.tif",
                  layername = "egv_294",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(apses)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeAspen.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeAspen-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_294.png")
```


## ForestsQuant_VolumeBirch-sum_cell	{#ch06.295}

**filename:** `ForestsQuant_VolumeBirch-sum_cell.tif`	

**layername:** `egv_295`	

**English name:** Timber volume of Birches within the analysis cell (1 ha)	

**Latvian name:** Bērzu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
birch (species code: 4; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv295.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeBirch-sum_cell.tif	egv_295 ----

berzi=c("4")
nogabali=mvr %>% 
  mutate(BerzuKraja=ifelse(s10 %in% berzi, v10, 0)+ifelse(s11 %in% berzi,v11,0)+
           ifelse(s12 %in% berzi, v12,0)+ifelse(s13 %in% berzi,v13,0)+
           ifelse(s14 %in% berzi, v14,0)) %>% 
  mutate(BerzuKraja2=BerzuKraja/10000*10*10) %>% 
  mutate(BerzuKraja3=ifelse(BerzuKraja2>5,5,BerzuKraja2)) %>% 
  filter(!is.na(BerzuKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$BerzuKraja2,main="Original",xlab="Birch volume")
hist(nogabali$BerzuKraja3,main="Limited",xlab="Birch volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeBirch.tif",
                      value_field = "BerzuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeBirch.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeBirch-sum_cell.tif",
                  layername = "egv_295",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(berzi)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeBirch.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeBirch-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_295.png")
```


## ForestsQuant_VolumeBlackAlder-sum_cell	{#ch06.296}

**filename:** `ForestsQuant_VolumeBlackAlder-sum_cell.tif`	

**layername:** `egv_296`	

**English name:** Timber volume of Black Alder within the analysis cell (1 ha)	

**Latvian name:** Melnalkšņu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
black alder (species code: 6; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv296.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeBlackAlder-sum_cell.tif	egv_296 ----

melnalksni=c("6")
nogabali=mvr %>% 
  mutate(MeKraja=ifelse(s10 %in% melnalksni, v10, 0)+ifelse(s11 %in% melnalksni,v11,0)+
           ifelse(s12 %in% melnalksni, v12,0)+ifelse(s13 %in% melnalksni,v13,0)+
           ifelse(s14 %in% melnalksni, v14,0)) %>% 
  mutate(MeKraja2=MeKraja/10000*10*10) %>% 
  mutate(MeKraja3=ifelse(MeKraja2>4,4,MeKraja2)) %>% 
  filter(!is.na(MeKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$MeKraja2,main="Original",xlab="Black alder volume")
hist(nogabali$MeKraja3,main="Limited",xlab="Black alder volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeBlackAlder.tif",
                      value_field = "MeKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeBlackAlder.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeBlackAlder-sum_cell.tif",
                  layername = "egv_296",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(melnalksni)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeBlackAlder.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeBlackAlder-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_296.png")
```


## ForestsQuant_VolumeBorealDeciduousOther-sum_cell	{#ch06.297}

**filename:** `ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif`	

**layername:** `egv_297`	

**English name:** Timber volume of Other Boreal Deciduous trees within the analysis cell (1 ha)	

**Latvian name:** Citu šaurlapju krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
boreal deciduous tree species not separately described 
(species codes: 9, 20, 21, 32, 35, 50; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv297.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif	egv_297 ----

sl_citi=c("9","20","21","32","35","50")
nogabali=mvr %>% 
  mutate(SaurlapjuCKraja=ifelse(s10 %in% sl_citi, v10, 0)+ifelse(s11 %in% sl_citi,v11,0)+
           ifelse(s12 %in% sl_citi, v12,0)+ifelse(s13 %in% sl_citi,v13,0)+
           ifelse(s14 %in% sl_citi, v14,0)) %>% 
  mutate(SaurlapjuCKraja2=SaurlapjuCKraja/10000*10*10) %>% 
  mutate(SaurlapjuCKraja3=ifelse(SaurlapjuCKraja2>3,3,SaurlapjuCKraja2)) %>% 
  filter(!is.na(SaurlapjuCKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$SaurlapjuCKraja2,main="Original",xlab="Other boreal deciduous volume")
hist(nogabali$SaurlapjuCKraja3,main="Limited",xlab="Other boreal deciduous volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeBorealDeciduousOther.tif",
                      value_field = "SaurlapjuCKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousOther.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif",
                  layername = "egv_297",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(sl_citi)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousOther.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_297.png")
```


## ForestsQuant_VolumeBorealDeciduousTotal-sum_cell	{#ch06.298}

**filename:** `ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif`	

**layername:** `egv_298`	

**English name:** Timber volume of Boreal Deciduous trees within the analysis cell (1 ha)	

**Latvian name:** Šaurlapju krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
boreal deciduous tree species 
(species codes: 4, 6, 8, 9, 19, 20, 21, 32, 35, 50, 68; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv298.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif	egv_298 ----

sl_visi=c("4","6","8","9","19","20","21","32","35","50","68")
nogabali=mvr %>% 
  mutate(SaurlapjuVKraja=ifelse(s10 %in% sl_visi, v10, 0)+ifelse(s11 %in% sl_visi,v11,0)+
           ifelse(s12 %in% sl_visi, v12,0)+ifelse(s13 %in% sl_visi,v13,0)+
           ifelse(s14 %in% sl_visi, v14,0)) %>% 
  mutate(SaurlapjuVKraja2=SaurlapjuVKraja/10000*10*10) %>% 
  mutate(SaurlapjuVKraja3=ifelse(SaurlapjuVKraja2>6,6,SaurlapjuVKraja2)) %>% 
  filter(!is.na(SaurlapjuVKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$SaurlapjuVKraja2,main="Original",xlab="All boreal deciduous volume")
hist(nogabali$SaurlapjuVKraja3,main="Limited",xlab="All boreal deciduous volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeBorealDeciduousTotal.tif",
                      value_field = "SaurlapjuVKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousTotal.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif",
                  layername = "egv_298",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(sl_visi)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousTotal.tif")



# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_298.png")
```


## ForestsQuant_VolumeConiferous-sum_cell	{#ch06.299}

**filename:** `ForestsQuant_VolumeConiferous-sum_cell.tif`	

**layername:** `egv_299`	

**English name:** Timber volume of Coniferous trees within the analysis cell (1 ha)	

**Latvian name:** Skujkoku krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
coniferous tree species 
(species codes: 1, 14, 22, 3, 13, 15, 23; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv299.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeConiferous-sum_cell.tif	egv_299 ----

skujkoki=c("1","14","22","3","13","15","23")
nogabali=mvr %>% 
  mutate(SkujkokuKraja=ifelse(s10 %in% skujkoki, v10, 0)+ifelse(s11 %in% skujkoki,v11,0)+
           ifelse(s12 %in% skujkoki, v12,0)+ifelse(s13 %in% skujkoki,v13,0)+
           ifelse(s14 %in% skujkoki, v14,0)) %>% 
  mutate(SkujkokuKraja2=SkujkokuKraja/10000*10*10) %>% 
  mutate(SkujkokuKraja3=ifelse(SkujkokuKraja2>7,7,SkujkokuKraja2)) %>% 
  filter(!is.na(SkujkokuKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$SkujkokuKraja2,main="Original",xlab="Coniferous volume")
hist(nogabali$SkujkokuKraja3,main="Limited",xlab="Coniferous volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeConiferous.tif",
                      value_field = "SkujkokuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeConiferous.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeConiferous-sum_cell.tif",
                  layername = "egv_299",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(skujkoki)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeConiferous.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeConiferous-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_299.png")
```


## ForestsQuant_VolumeOak-sum_cell	{#ch06.300}

**filename:** `ForestsQuant_VolumeOak-sum_cell.tif`	

**layername:** `egv_300`	

**English name:** Timber volume of Oaks within the analysis cell (1 ha)	

**Latvian name:** Ozolu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
oaks 
(species codes: 10, 61; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv300.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeOak-sum_cell.tif	egv_300 ----
ozoli=c("10","61")
nogabali=mvr %>% 
  mutate(OzoluKraja=ifelse(s10 %in% ozoli, v10, 0)+ifelse(s11 %in% ozoli,v11,0)+
           ifelse(s12 %in% ozoli, v12,0)+ifelse(s13 %in% ozoli,v13,0)+
           ifelse(s14 %in% ozoli, v14,0)) %>% 
  mutate(OzoluKraja2=OzoluKraja/10000*10*10) %>% 
  mutate(OzoluKraja3=ifelse(OzoluKraja2>2,2,OzoluKraja2)) %>% 
  filter(!is.na(OzoluKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$OzoluKraja2,main="Original",xlab="Oak volume")
hist(nogabali$OzoluKraja3,main="Limited",xlab="Oak volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeOak.tif",
                      value_field = "OzoluKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeOak.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeOak-sum_cell.tif",
                  layername = "egv_300",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(ozoli)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeOak.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeOak-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_300.png")
```


## ForestsQuant_VolumeOakMaple-sum_cell	{#ch06.301}

**filename:** `ForestsQuant_VolumeOakMaple-sum_cell.tif`	

**layername:** `egv_301`	

**English name:** Timber volume of Oaks, Maples within the analysis cell (1 ha)	

**Latvian name:** Ozolu, kļavu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
oaks and maples 
(species codes: 10, 61, 24, 63; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv301.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeOakMaple-sum_cell.tif	egv_301 ----
ozolklavas=c("10","61","24","63")
nogabali=mvr %>% 
  mutate(OzolKlavuKraja=ifelse(s10 %in% ozolklavas, v10, 0)+ifelse(s11 %in% ozolklavas,v11,0)+
           ifelse(s12 %in% ozolklavas, v12,0)+ifelse(s13 %in% ozolklavas,v13,0)+
           ifelse(s14 %in% ozolklavas, v14,0)) %>% 
  mutate(OzolKlavuKraja2=OzolKlavuKraja/10000*10*10) %>% 
  mutate(OzolKlavuKraja3=ifelse(OzolKlavuKraja2>3,3,OzolKlavuKraja2)) %>% 
  filter(!is.na(OzolKlavuKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$OzolKlavuKraja2,main="Original",xlab="Oak and maple volume")
hist(nogabali$OzolKlavuKraja3,main="Limited",xlab="Oak and maple volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeOakMaple.tif",
                      value_field = "OzolKlavuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeOakMaple.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeOakMaple-sum_cell.tif",
                  layername = "egv_301",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(ozolklavas)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeOakMaple.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeOakMaple-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_301.png")
```


## ForestsQuant_VolumePine-sum_cell	{#ch06.302}

**filename:** `ForestsQuant_VolumePine-sum_cell.tif`	

**layername:** `egv_302`	

**English name:** Timber volume of Pines within the analysis cell (1 ha)	

**Latvian name:** Priežu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
pines 
(species codes: 1, 14, 22; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv302.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumePine-sum_cell.tif	egv_302 ----

priedes=c("1","14","22")
nogabali=mvr %>% 
  mutate(PriezuKraja=ifelse(s10 %in% priedes, v10, 0)+ifelse(s11 %in% priedes,v11,0)+
           ifelse(s12 %in% priedes, v12,0)+ifelse(s13 %in% priedes,v13,0)+
           ifelse(s14 %in% priedes, v14,0)) %>% 
  mutate(PriezuKraja2=PriezuKraja/10000*10*10) %>% 
  mutate(PriezuKraja3=ifelse(PriezuKraja2>6,6,PriezuKraja2)) %>% 
  filter(!is.na(PriezuKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$PriezuKraja2,main="Original",xlab="Pine volume")
hist(nogabali$PriezuKraja3,main="Limited",xlab="Pine volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumePine.tif",
                      value_field = "PriezuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumePine.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumePine-sum_cell.tif",
                  layername = "egv_302",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(priedes)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumePine.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumePine-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_302.png")
```


## ForestsQuant_VolumeSpruce-sum_cell	{#ch06.303}

**filename:** `ForestsQuant_VolumeSpruce-sum_cell.tif`	

**layername:** `egv_303`	

**English name:** Timber volume of Spruces within the analysis cell (1 ha)	

**Latvian name:** Egļu krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
spruces  
(species codes: 3, 13, 15, 23; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv303.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeSpruce-sum_cell.tif	egv_303 ----

egles=c("3","13","15","23")
nogabali=mvr %>% 
  mutate(EgluKraja=ifelse(s10 %in% egles, v10, 0)+ifelse(s11 %in% egles,v11,0)+
           ifelse(s12 %in% egles, v12,0)+ifelse(s13 %in% egles,v13,0)+
           ifelse(s14 %in% egles, v14,0)) %>% 
  mutate(EgluKraja2=EgluKraja/10000*10*10) %>% 
  mutate(EgluKraja3=ifelse(EgluKraja2>5,5,EgluKraja2)) %>% 
  filter(!is.na(EgluKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$EgluKraja2,main="Original",xlab="Spruce volume")
hist(nogabali$EgluKraja3,main="Limited",xlab="Spruce volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeSpruce.tif",
                      value_field = "EgluKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeSpruce.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeSpruce-sum_cell.tif",
                  layername = "egv_303",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(egles)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeSpruce.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeSpruce-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_303.png")
```


## ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell	{#ch06.304}

**filename:** `ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif`	

**layername:** `egv_304`	

**English name:** Timber volume of Temperate Deciduous trees within the analysis cell (1 ha)	

**Latvian name:** Platlapju krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
temperate deciduous tree species   
(species codes: 10, 11, 12, 16, 17, 18, 24, 25, 26, 27, 28, 29, 61, 
62, 63, 64, 65, 66, 67, 69; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv304.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif	egv_304 ----

platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69")
nogabali=mvr %>% 
  mutate(PlatKraja=ifelse(s10 %in% platlapji, v10, 0)+ifelse(s11 %in% platlapji,v11,0)+
           ifelse(s12 %in% platlapji, v12,0)+ifelse(s13 %in% platlapji,v13,0)+
           ifelse(s14 %in% platlapji, v14,0)) %>% 
  mutate(PlatKraja2=PlatKraja/10000*10*10) %>% 
  mutate(PlatKraja3=ifelse(PlatKraja2>4,4,PlatKraja2)) %>% 
  filter(!is.na(PlatKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$PlatKraja2,main="Original",xlab="Total volume\ntemperate deciduous")
hist(nogabali$PlatKraja3,main="Limited",xlab="Total volume\ntemperate deciduous")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeTemperateDeciduousTotal.tif",
                      value_field = "PlatKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateDeciduousTotal.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif",
                  layername = "egv_304",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(platlapji)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateDeciduousTotal.tif")



# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_304.png")
```


## ForestsQuant_VolumeTemperateWithoutOak-sum_cell	{#ch06.305}

**filename:** `ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif`	

**layername:** `egv_305`	

**English name:** Timber volume of Temperate Deciduous trees (without oaks) within the analysis cell (1 ha)	

**Latvian name:** Paltlapju (bez ozoliem) krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
temperate deciduous tree species except oaks   
(species codes: 11, 12, 16, 17, 18, 24, 25, 26, 27, 28, 29, 62, 63, 64, 65, 66, 
67, 69; see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv305.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif	egv_305 ----
neozoli=c("11","12","16","17","18","24","25","26","27","28","29",
          "62","63","64","65","66","67","69")
nogabali=mvr %>% 
  mutate(BezOzoluKraja=ifelse(s10 %in% neozoli, v10, 0)+ifelse(s11 %in% neozoli,v11,0)+
           ifelse(s12 %in% neozoli, v12,0)+ifelse(s13 %in% neozoli,v13,0)+
           ifelse(s14 %in% neozoli, v14,0)) %>% 
  mutate(BezOzoluKraja2=BezOzoluKraja/10000*10*10) %>% 
  mutate(BezOzoluKraja3=ifelse(BezOzoluKraja2>3,3,BezOzoluKraja2)) %>% 
  filter(!is.na(BezOzoluKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$BezOzoluKraja2,main="Original",xlab="Temperate deciduous volume\n without oak")
hist(nogabali$BezOzoluKraja3,main="Limited",xlab="Temperate deciduous volume\nwithout oak")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeTemperateWithoutOak.tif",
                      value_field = "BezOzoluKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOak.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif",
                  layername = "egv_305",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(neozoli)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOak.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_305.png")
```


## ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell	{#ch06.306}

**filename:** `ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif`	

**layername:** `egv_306`	

**English name:** Timber volume of Temperate Deciduous trees (without oaks, maples) within the analysis cell (1 ha)	

**Latvian name:** Platlapju (bez ozoliem, kļavām) krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume of 
teperate deciduous trees except oaks and maples   
(species codes: 11, 12, 16, 17, 18, 25, 26, 27, 28, 29, 62, 64, 65, 66, 67, 69; 
see tree species codes in [Terminology and acronyms](#Ch01)) in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv306.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif	egv_306 ----
neozolklavas=c("11","12","16","17","18","25","26","27","28","29",
               "62","64","65","66","67","69")
nogabali=mvr %>% 
  mutate(BezOzolKlavuKraja=ifelse(s10 %in% neozolklavas, v10, 0)+ifelse(s11 %in% neozolklavas,v11,0)+
           ifelse(s12 %in% neozolklavas, v12,0)+ifelse(s13 %in% neozolklavas,v13,0)+
           ifelse(s14 %in% neozolklavas, v14,0)) %>% 
  mutate(BezOzolKlavuKraja2=BezOzolKlavuKraja/10000*10*10) %>% 
  mutate(BezOzolKlavuKraja3=ifelse(BezOzolKlavuKraja2>3,3,BezOzolKlavuKraja2)) %>% 
  filter(!is.na(BezOzolKlavuKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$BezOzolKlavuKraja2,main="Original",xlab="Temperate deciduous volume\n without oak and maple")
hist(nogabali$BezOzolKlavuKraja3,main="Limited",xlab="Temperate deciduous volume\nwithout oak and maple")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeTemperateWithoutOakMaple.tif",
                      value_field = "BezOzolKlavuKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOakMaple.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif",
                  layername = "egv_306",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(neozolklavas)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOakMaple.tif")


# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_306.png")
```


## ForestsQuant_VolumeTotal-sum_cell	{#ch06.307}

**filename:** `ForestsQuant_VolumeTotal-sum_cell.tif`	

**layername:** `egv_307`	

**English name:** Timber volume within the analysis cell (1 ha)	

**Latvian name:** Kopējā krāja analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

This EGV was prepared based on the information of timber volume in the inventoried forest 
stands - [State Forest Service's State Forest Registry](#Ch04.01). 
As values in this attribute had some impossible extreme values, they were limited 
to the nearest integer showing only minimal accumulation in histogram.

```{r, echo=FALSE, out.width = '80%'}
knitr::include_graphics("./Figures/Histogramms/hist_egv307.png")
```

Resulting values at polygon geometries were rasterized with `egvtools::polygon2input()`,
restricting to pixels outside the clearcut mask. No background values were assigned 
during rasterization. The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating sum of pixel values. After the aggregation, cells with no forest information 
were filled with value 0. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsQuant_VolumeTotal-sum_cell.tif	egv_307 ----

nogabali=mvr %>% 
  mutate(KopejaKraja=v10+v11+v12+v13+v14) %>% 
  mutate(KopejaKraja2=KopejaKraja/10000*10*10) %>% 
  mutate(KopejaKraja3=ifelse(KopejaKraja2>8,8,KopejaKraja2)) %>% 
  filter(!is.na(KopejaKraja2))

par(mfrow=c(1,2))
options(scipen=999)
hist(nogabali$KopejaKraja2,main="Original",xlab="Timber volume")
hist(nogabali$KopejaKraja3,main="Limited",xlab="Timber volume")
par(mfrow=c(1,1))
options(scipen=0)

p2i_rez=polygon2input(vector_data=nogabali,
                      template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                      out_path = "./RasterGrids_10m/2024/",
                      file_name = "ForestsQuant_VolumeTotal.tif",
                      value_field = "KopejaKraja3",
                      fun="max",
                      prepare=FALSE,
                      restrict_to = clearcut_mask,
                      restrict_values = 0,
                      plot_result=TRUE,
                      overwrite=TRUE)
p2i_rez
i2e_rez=input2egv(input="./RasterGrids_10m/2024/ForestsQuant_VolumeTotal.tif",
                  egv_template = "./Templates/TemplateRasters/LV100m_10km.tif",
                  summary_function = "sum",
                  missing_job = "CoverOutput",
                  output_bg = "./Templates/TemplateRasters/nulls_LV100m_10km.tif",
                  outlocation = "./RasterGrids_100m/2024/RAW/",
                  outfilename = "ForestsQuant_VolumeTotal-sum_cell.tif",
                  layername = "egv_307",
                  plot_final=TRUE)
i2e_rez
rm(p2i_rez)
rm(nogabali)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsQuant_VolumeTotal.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsQuant_VolumeTotal-sum_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_307.png")
```


## ForestsSoil_EutrophicDrained_cell	{#ch06.308}

**filename:** `ForestsSoil_EutrophicDrained_cell.tif`	

**layername:** `egv_308`	

**English name:** Fractional cover of Drained Eutrophic Forests within the analysis cell (1 ha)	

**Latvian name:** Susinātu eitrofu mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "19", "21", "24" or "25" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_EutrophicDrained_cell.tif	egv_308 ----
EutrophicDrained=mvr %>% 
  filter(mt %in% c("19","21","24","25"))
p2i_rez=egvtools::polygon2input(vector_data = EutrophicDrained,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_EutrophicDrained_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_EutrophicDrained_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_EutrophicDrained_cell.tif",
                            layername = "egv_308",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(EutrophicDrained)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_EutrophicDrained_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicDrained_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_308.png")
```


## ForestsSoil_EutrophicDrained_r500	{#ch06.309}

**filename:** `ForestsSoil_EutrophicDrained_r500.tif`	

**layername:** `egv_309`	

**English name:** Fractional cover of Drained Eutrophic Forests within the 0.5 km landscape	

**Latvian name:** Susinātu eitrofu mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.308) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicDrained_r500.tif	egv_309
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r500.tif")
names(slanis)="egv_309"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicDrained_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_309.png")
```


## ForestsSoil_EutrophicDrained_r1250	{#ch06.310}

**filename:** `ForestsSoil_EutrophicDrained_r1250.tif`	

**layername:** `egv_310`	

**English name:** Fractional cover of Drained Eutrophic Forests within the 1.25 km landscape	

**Latvian name:** Susinātu eitrofu mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.308) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicDrained_r1250.tif	egv_310
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r1250.tif")
names(slanis)="egv_310"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicDrained_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_310.png")
```


## ForestsSoil_EutrophicDrained_r3000	{#ch06.311}

**filename:** `ForestsSoil_EutrophicDrained_r3000.tif`	

**layername:** `egv_311`	

**English name:** Fractional cover of Drained Eutrophic Forests within the 3 km landscape	

**Latvian name:** Susinātu eitrofu mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.308) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicDrained_r3000.tif	egv_311
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r3000.tif")
names(slanis)="egv_311"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicDrained_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_311.png")
```


## ForestsSoil_EutrophicDrained_r10000	{#ch06.312}

**filename:** `ForestsSoil_EutrophicDrained_r10000.tif`	

**layername:** `egv_312`	

**English name:** Fractional cover of Drained Eutrophic Forests within the 10 km landscape	

**Latvian name:** Susinātu eitrofu mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.308) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicDrained_r10000.tif	egv_312
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r10000.tif")
names(slanis)="egv_312"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicDrained_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_312.png")
```


## ForestsSoil_EutrophicMineral_cell	{#ch06.313}

**filename:** `ForestsSoil_EutrophicMineral_cell.tif`	

**layername:** `egv_313`	

**English name:** Fractional cover of Eutrophic Forests on undrained Mineral Soils within the analysis cell (1 ha)	

**Latvian name:** Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "5" "6" "10" or "11" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_EutrophicMineral_cell.tif	egv_313 ----
EutrophicMineral=mvr %>% 
  filter(mt %in% c("5","6","10","11"))
p2i_rez=egvtools::polygon2input(vector_data = EutrophicMineral,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_EutrophicMineral_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_EutrophicMineral_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_EutrophicMineral_cell.tif",
                            layername = "egv_313",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(EutrophicMineral)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_EutrophicMineral_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicMineral_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_313.png")
```


## ForestsSoil_EutrophicMineral_r500	{#ch06.314}

**filename:** `ForestsSoil_EutrophicMineral_r500.tif`	

**layername:** `egv_314`	

**English name:** Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 0.5 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.313) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicMineral_r500.tif	egv_314
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r500.tif")
names(slanis)="egv_314"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicMineral_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_314.png")
```


## ForestsSoil_EutrophicMineral_r1250	{#ch06.315}

**filename:** `ForestsSoil_EutrophicMineral_r1250.tif`	

**layername:** `egv_315`	

**English name:** Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 1.25 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.313) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicMineral_r1250.tif	egv_315
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r1250.tif")
names(slanis)="egv_315"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicMineral_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_315.png")
```


## ForestsSoil_EutrophicMineral_r3000	{#ch06.316}

**filename:** `ForestsSoil_EutrophicMineral_r3000.tif`	

**layername:** `egv_316`	

**English name:** Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 3 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.313) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicMineral_r3000.tif	egv_316
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r3000.tif")
names(slanis)="egv_316"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicMineral_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_316.png")
```


## ForestsSoil_EutrophicMineral_r10000	{#ch06.317}

**filename:** `ForestsSoil_EutrophicMineral_r10000.tif`	

**layername:** `egv_317`	

**English name:** Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 10 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.313) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicMineral_r10000.tif	egv_317
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r10000.tif")
names(slanis)="egv_317"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicMineral_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_317.png")
```


## ForestsSoil_EutrophicOrganic_cell	{#ch06.318}

**filename:** `ForestsSoil_EutrophicOrganic_cell.tif`	

**layername:** `egv_318`	

**English name:** Fractional cover of Eutrophic Forests on undrained Organic Soils within the analysis cell (1 ha)	

**Latvian name:** Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "15" or "16" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_EutrophicOrganic_cell.tif	egv_318 ----
EutrophicOrganic=mvr %>% 
  filter(mt %in% c("15","16"))
p2i_rez=egvtools::polygon2input(vector_data = EutrophicOrganic,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_EutrophicOrganic_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_EutrophicOrganic_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_EutrophicOrganic_cell.tif",
                            layername = "egv_318",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(EutrophicOrganic)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_EutrophicOrganic_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicOrganic_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_318.png")
```


## ForestsSoil_EutrophicOrganic_r500	{#ch06.319}

**filename:** `ForestsSoil_EutrophicOrganic_r500.tif`	

**layername:** `egv_319`	

**English name:** Fractional cover of Eutrophic Forests on undrained Organic Soils within the 0.5 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.318) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicOrganic_r500.tif	egv_319
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r500.tif")
names(slanis)="egv_319"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicOrganic_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_319.png")
```


## ForestsSoil_EutrophicOrganic_r1250	{#ch06.320}

**filename:** `ForestsSoil_EutrophicOrganic_r1250.tif`	

**layername:** `egv_320`	

**English name:** Fractional cover of Eutrophic Forests on undrained Organic Soils within the 1.25 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.318) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicOrganic_r1250.tif	egv_320
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r1250.tif")
names(slanis)="egv_320"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicOrganic_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_320.png")
```


## ForestsSoil_EutrophicOrganic_r3000	{#ch06.321}

**filename:** `ForestsSoil_EutrophicOrganic_r3000.tif`	

**layername:** `egv_321`	

**English name:** Fractional cover of Eutrophic Forests on undrained Organic Soils within the 3 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.318) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicOrganic_r3000.tif	egv_321
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r3000.tif")
names(slanis)="egv_321"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicOrganic_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_321.png")
```


## ForestsSoil_EutrophicOrganic_r10000	{#ch06.322}

**filename:** `ForestsSoil_EutrophicOrganic_r10000.tif`	

**layername:** `egv_322`	

**English name:** Fractional cover of Eutrophic Forests on undrained Organic Soils within the 10 km landscape	

**Latvian name:** Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.318) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_EutrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_EutrophicOrganic_r10000.tif	egv_322
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r10000.tif")
names(slanis)="egv_322"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_EutrophicOrganic_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_322.png")
```


## ForestsSoil_MesotrophicMineral_cell	{#ch06.323}

**filename:** `ForestsSoil_MesotrophicMineral_cell.tif`	

**layername:** `egv_323`	

**English name:** Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the analysis cell (1 ha)	

**Latvian name:** Mezotrofu mežu minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "4" or "9" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_MesotrophicMineral_cell.tif	egv_323 ----
MesotrophicMineral=mvr %>% 
  filter(mt %in% c("4","9"))
p2i_rez=egvtools::polygon2input(vector_data = MesotrophicMineral,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_MesotrophicMineral_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_MesotrophicMineral_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_MesotrophicMineral_cell.tif",
                            layername = "egv_323",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(MesotrophicMineral)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_MesotrophicMineral_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_MesotrophicMineral_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_323.png")
```


## ForestsSoil_MesotrophicMineral_r500	{#ch06.324}

**filename:** `ForestsSoil_MesotrophicMineral_r500.tif`	

**layername:** `egv_324`	

**English name:** Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 0.5 km landscape	

**Latvian name:** Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.323) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_MesotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_MesotrophicMineral_r500.tif	egv_324
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r500.tif")
names(slanis)="egv_324"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_MesotrophicMineral_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_324.png")
```


## ForestsSoil_MesotrophicMineral_r1250	{#ch06.325}

**filename:** `ForestsSoil_MesotrophicMineral_r1250.tif`	

**layername:** `egv_325`	

**English name:** Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 1.25 km landscape	

**Latvian name:** Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.323) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_MesotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_MesotrophicMineral_r1250.tif	egv_325
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r1250.tif")
names(slanis)="egv_325"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_MesotrophicMineral_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_325.png")
```


## ForestsSoil_MesotrophicMineral_r3000	{#ch06.326}

**filename:** `ForestsSoil_MesotrophicMineral_r3000.tif`	

**layername:** `egv_326`	

**English name:** Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 3 km landscape	

**Latvian name:** Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.323) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_MesotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_MesotrophicMineral_r3000.tif	egv_326
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r3000.tif")
names(slanis)="egv_326"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_MesotrophicMineral_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_326.png")
```


## ForestsSoil_MesotrophicMineral_r10000	{#ch06.327}

**filename:** `ForestsSoil_MesotrophicMineral_r10000.tif`	

**layername:** `egv_327`	

**English name:** Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 10 km landscape	

**Latvian name:** Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.323) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_MesotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_MesotrophicMineral_r10000.tif	egv_327
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r10000.tif")
names(slanis)="egv_327"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_MesotrophicMineral_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_327.png")
```


## ForestsSoil_OligotrophicDrained_cell	{#ch06.328}

**filename:** `ForestsSoil_OligotrophicDrained_cell.tif`	

**layername:** `egv_328`	

**English name:** Fractional cover of Drained Oligotrophic Forests within the analysis cell (1 ha)	

**Latvian name:** Susinātu oligotrofu mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "17", "18", "22" or "23" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_OligotrophicDrained_cell.tif	egv_328 ----
OligotrophicDrained=mvr %>% 
  filter(mt %in% c("17","18","22","23"))
p2i_rez=egvtools::polygon2input(vector_data = OligotrophicDrained,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_OligotrophicDrained_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_OligotrophicDrained_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_OligotrophicDrained_cell.tif",
                            layername = "egv_328",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(OligotrophicDrained)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_OligotrophicDrained_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicDrained_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_328.png")
```


## ForestsSoil_OligotrophicDrained_r500	{#ch06.329}

**filename:** `ForestsSoil_OligotrophicDrained_r500.tif`	

**layername:** `egv_329`	

**English name:** Fractional cover of Drained Oligotrophic Forests within the 0.5 km landscape	

**Latvian name:** Susinātu oligotrofu mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.328) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicDrained_r500.tif	egv_329
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r500.tif")
names(slanis)="egv_329"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicDrained_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_329.png")
```


## ForestsSoil_OligotrophicDrained_r1250	{#ch06.330}

**filename:** `ForestsSoil_OligotrophicDrained_r1250.tif`	

**layername:** `egv_330`	

**English name:** Fractional cover of Drained Oligotrophic Forests within the 1.25 km landscape	

**Latvian name:** Susinātu oligotrofu mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.328) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicDrained_r1250.tif	egv_330
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r1250.tif")
names(slanis)="egv_330"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicDrained_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_330.png")
```


## ForestsSoil_OligotrophicDrained_r3000	{#ch06.331}

**filename:** `ForestsSoil_OligotrophicDrained_r3000.tif`	

**layername:** `egv_331`	

**English name:** Fractional cover of Drained Oligotrophic Forests within the 3 km landscape	

**Latvian name:** Susinātu oligotrofu mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.328) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicDrained_r3000.tif	egv_331
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r3000.tif")
names(slanis)="egv_331"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicDrained_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_331.png")
```


## ForestsSoil_OligotrophicDrained_r10000	{#ch06.332}

**filename:** `ForestsSoil_OligotrophicDrained_r10000.tif`	

**layername:** `egv_332`	

**English name:** Fractional cover of Drained Oligotrophic Forests within the 10 km landscape	

**Latvian name:** Susinātu oligotrofu mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.328) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicDrained"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicDrained_r10000.tif	egv_332
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r10000.tif")
names(slanis)="egv_332"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicDrained_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_332.png")
```


## ForestsSoil_OligotrophicMineral_cell	{#ch06.333}

**filename:** `ForestsSoil_OligotrophicMineral_cell.tif`	

**layername:** `egv_333`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the analysis cell (1 ha)	

**Latvian name:** Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "1", "2", "3", "7" or "8" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_OligotrophicMineral_cell.tif	egv_333 ----
OligotrophicMineral=mvr %>% 
  filter(mt %in% c("1","2","3","7","8"))
p2i_rez=egvtools::polygon2input(vector_data = OligotrophicMineral,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_OligotrophicMineral_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_OligotrophicMineral_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_OligotrophicMineral_cell.tif",
                            layername = "egv_333",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(OligotrophicMineral)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_OligotrophicMineral_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_333.png")
```


## ForestsSoil_OligotrophicMineral_r500	{#ch06.334}

**filename:** `ForestsSoil_OligotrophicMineral_r500.tif`	

**layername:** `egv_334`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 0.5 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.333) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicMineral_r500.tif	egv_334
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r500.tif")
names(slanis)="egv_334"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_334.png")
```


## ForestsSoil_OligotrophicMineral_r1250	{#ch06.335}

**filename:** `ForestsSoil_OligotrophicMineral_r1250.tif`	

**layername:** `egv_335`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 1.25 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.333) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicMineral_r1250.tif	egv_335
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r1250.tif")
names(slanis)="egv_335"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_335.png")
```


## ForestsSoil_OligotrophicMineral_r3000	{#ch06.336}

**filename:** `ForestsSoil_OligotrophicMineral_r3000.tif`	

**layername:** `egv_336`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 3 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.333) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicMineral_r3000.tif	egv_336
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r3000.tif")
names(slanis)="egv_336"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_336.png")
```


## ForestsSoil_OligotrophicMineral_r10000	{#ch06.337}

**filename:** `ForestsSoil_OligotrophicMineral_r10000.tif`	

**layername:** `egv_337`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 10 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.333) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicMineral"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicMineral_r10000.tif	egv_337
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r10000.tif")
names(slanis)="egv_337"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_337.png")
```


## ForestsSoil_OligotrophicOrganic_cell	{#ch06.338}

**filename:** `ForestsSoil_OligotrophicOrganic_cell.tif`	

**layername:** `egv_338`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Organic Soils within the analysis cell (1 ha)	

**Latvian name:** Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** To prepare this EGV, forest stands with forest type equal to "12" or "14" 
were selected from [State Forest Service's State Forest Registry](#Ch04.01) 
and rasterized (presence = 1, NA otherwise). Resulting geometries were then rasterized 
with `egvtools::polygon2input()` with background covering (value 0). This layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. 

At the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsSoil_OligotrophicOrganic_cell.tif	egv_338 ----
OligotrophicOrganic=mvr %>% 
  filter(mt %in% c("12","14"))
p2i_rez=egvtools::polygon2input(vector_data = OligotrophicOrganic,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsSoil_OligotrophicOrganic_input.tif",
                                value_field = "yes",
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsSoil_OligotrophicOrganic_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsSoil_OligotrophicOrganic_cell.tif",
                            layername = "egv_338",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(OligotrophicOrganic)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsSoil_OligotrophicOrganic_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicMineral_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_338.png")
```


## ForestsSoil_OligotrophicOrganic_r500	{#ch06.339}

**filename:** `ForestsSoil_OligotrophicOrganic_r500.tif`	

**layername:** `egv_339`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 0.5 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.338) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicOrganic_r500.tif	egv_339
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r500.tif")
names(slanis)="egv_339"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicOrganic_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_339.png")
```


## ForestsSoil_OligotrophicOrganic_r1250	{#ch06.340}

**filename:** `ForestsSoil_OligotrophicOrganic_r1250.tif`	

**layername:** `egv_340`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 1.25 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.338) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicOrganic_r1250.tif	egv_340
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r1250.tif")
names(slanis)="egv_340"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicOrganic_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_340.png")
```


## ForestsSoil_OligotrophicOrganic_r3000	{#ch06.341}

**filename:** `ForestsSoil_OligotrophicOrganic_r3000.tif`	

**layername:** `egv_341`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 3 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.338) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicOrganic_r3000.tif	egv_341
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r3000.tif")
names(slanis)="egv_341"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicOrganic_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_341.png")
```


## ForestsSoil_OligotrophicOrganic_r10000	{#ch06.342}

**filename:** `ForestsSoil_OligotrophicOrganic_r10000.tif`	

**layername:** `egv_342`	

**English name:** Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 10 km landscape	

**Latvian name:** Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.338) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif"),
  layer_prefixes = c("ForestsSoil_OligotrophicOrganic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsSoil_OligotrophicOrganic_r10000.tif	egv_342
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r10000.tif")
names(slanis)="egv_342"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsSoil_OligotrophicOrganic_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_342.png")
```


## ForestsTreesAge_BorealDeciduousOld_cell	{#ch06.343}

**filename:** `ForestsTreesAge_BorealDeciduousOld_cell.tif`	

**layername:** `egv_343`	

**English name:** Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then boreal deciduous stands exceeding the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_BorealDeciduousOld_cell.tif	egv_343 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="saurlapju"&(vgr=="4"|vgr=="5"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_BorealDeciduousOld_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_BorealDeciduousOld_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_BorealDeciduousOld_cell.tif",
                            layername = "egv_343",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_BorealDeciduousOld_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousOld_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_343.png")
```


## ForestsTreesAge_BorealDeciduousOld_r500	{#ch06.344}

**filename:** `ForestsTreesAge_BorealDeciduousOld_r500.tif`	

**layername:** `egv_344`	

**English name:** Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.343) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousOld_r500.tif	egv_344
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r500.tif")
names(slanis)="egv_344"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousOld_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_344.png")
```


## ForestsTreesAge_BorealDeciduousOld_r1250	{#ch06.345}

**filename:** `ForestsTreesAge_BorealDeciduousOld_r1250.tif`	

**layername:** `egv_345`	

**English name:** Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.343) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousOld_r1250.tif	egv_345
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r1250.tif")
names(slanis)="egv_345"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousOld_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_345.png")
```


## ForestsTreesAge_BorealDeciduousOld_r3000	{#ch06.346}

**filename:** `ForestsTreesAge_BorealDeciduousOld_r3000.tif`	

**layername:** `egv_346`	

**English name:** Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 3 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.343) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousOld_r3000.tif	egv_346
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r3000.tif")
names(slanis)="egv_346"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousOld_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_346.png")
```


## ForestsTreesAge_BorealDeciduousOld_r10000	{#ch06.347}

**filename:** `ForestsTreesAge_BorealDeciduousOld_r10000.tif`	

**layername:** `egv_347`	

**English name:** Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 10 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.343) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousOld_r10000.tif	egv_347
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r10000.tif")
names(slanis)="egv_347"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousOld_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_347.png")
```


## ForestsTreesAge_BorealDeciduousYoung_cell	{#ch06.348}

**filename:** `ForestsTreesAge_BorealDeciduousYoung_cell.tif`	

**layername:** `egv_348`	

**English name:** Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then boreal deciduous stands younger than the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_BorealDeciduousYoung_cell.tif	egv_348 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="saurlapju"&(vgr=="1"|vgr=="2"|vgr=="3"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_BorealDeciduousYoung_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_BorealDeciduousYoung_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_BorealDeciduousYoung_cell.tif",
                            layername = "egv_348",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_BorealDeciduousYoung_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousYoung_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_348.png")
```


## ForestsTreesAge_BorealDeciduousYoung_r500	{#ch06.349}

**filename:** `ForestsTreesAge_BorealDeciduousYoung_r500.tif`	

**layername:** `egv_349`	

**English name:** Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.348) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousYoung_r500.tif	egv_349
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r500.tif")
names(slanis)="egv_349"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousYoung_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_349.png")
```


## ForestsTreesAge_BorealDeciduousYoung_r1250	{#ch06.350}

**filename:** `ForestsTreesAge_BorealDeciduousYoung_r1250.tif`	

**layername:** `egv_350`	

**English name:** Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.348) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousYoung_r1250.tif	egv_350
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r1250.tif")
names(slanis)="egv_350"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousYoung_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_350.png")
```


## ForestsTreesAge_BorealDeciduousYoung_r3000	{#ch06.351}

**filename:** `ForestsTreesAge_BorealDeciduousYoung_r3000.tif`	

**layername:** `egv_351`	

**English name:** Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 3 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.348) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousYoung_r3000.tif	egv_351
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r3000.tif")
names(slanis)="egv_351"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousYoung_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_351.png")
```


## ForestsTreesAge_BorealDeciduousYoung_r10000	{#ch06.352}

**filename:** `ForestsTreesAge_BorealDeciduousYoung_r10000.tif`	

**layername:** `egv_352`	

**English name:** Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 10 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.348) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_BorealDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_BorealDeciduousYoung_r10000.tif	egv_352
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r10000.tif")
names(slanis)="egv_352"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_BorealDeciduousYoung_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_352.png")
```


## ForestsTreesAge_ConiferousOld_cell	{#ch06.353}

**filename:** `ForestsTreesAge_ConiferousOld_cell.tif`	

**layername:** `egv_353`	

**English name:** Fractional cover of Old (over rotation age) Coniferous Forests within the analysis cell (1 ha)	

**Latvian name:** Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then coniferous stands exceeding the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_ConiferousOld_cell.tif	egv_353 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="skujkoku"&(vgr=="4"|vgr=="5"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_ConiferousOld_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_ConiferousOld_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_ConiferousOld_cell.tif",
                            layername = "egv_353",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_ConiferousOld_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousOld_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_353.png")
```


## ForestsTreesAge_ConiferousOld_r500	{#ch06.354}

**filename:** `ForestsTreesAge_ConiferousOld_r500.tif`	

**layername:** `egv_354`	

**English name:** Fractional cover of Old (over rotation age) Coniferous Forests within the 0.5 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.353) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousOld_r500.tif	egv_354
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r500.tif")
names(slanis)="egv_354"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousOld_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_354.png")
```


## ForestsTreesAge_ConiferousOld_r1250	{#ch06.355}

**filename:** `ForestsTreesAge_ConiferousOld_r1250.tif`	

**layername:** `egv_355`	

**English name:** Fractional cover of Old (over rotation age) Coniferous Forests within the 1.25 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.353) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousOld_r1250.tif	egv_355
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r1250.tif")
names(slanis)="egv_355"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousOld_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_355.png")
```


## ForestsTreesAge_ConiferousOld_r3000	{#ch06.356}

**filename:** `ForestsTreesAge_ConiferousOld_r3000.tif`	

**layername:** `egv_356`	

**English name:** Fractional cover of Old (over rotation age) Coniferous Forests within the 3 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.353) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousOld_r3000.tif	egv_356
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r3000.tif")
names(slanis)="egv_356"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousOld_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_356.png")
```


## ForestsTreesAge_ConiferousOld_r10000	{#ch06.357}

**filename:** `ForestsTreesAge_ConiferousOld_r10000.tif`	

**layername:** `egv_357`	

**English name:** Fractional cover of Old (over rotation age) Coniferous Forests within the 10 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.353) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousOld_r10000.tif	egv_357
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r10000.tif")
names(slanis)="egv_357"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousOld_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_357.png")
```


## ForestsTreesAge_ConiferousYoung_cell	{#ch06.358}

**filename:** `ForestsTreesAge_ConiferousYoung_cell.tif`	

**layername:** `egv_358`	

**English name:** Fractional cover of Young (pre-rotation age) Coniferous Forests within the analysis cell (1 ha)	

**Latvian name:** Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then coniferous stands younger than the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_ConiferousYoung_cell.tif	egv_358 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="skujkoku"&(vgr=="1"|vgr=="2"|vgr=="3"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_ConiferousYoung_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_ConiferousYoung_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_ConiferousYoung_cell.tif",
                            layername = "egv_358",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_ConiferousYoung_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousYoung_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_358.png")
```


## ForestsTreesAge_ConiferousYoung_r500	{#ch06.359}

**filename:** `ForestsTreesAge_ConiferousYoung_r500.tif`	

**layername:** `egv_359`	

**English name:** Fractional cover of Young (pre-rotation age) Coniferous Forests within the 0.5 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.358) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousYoung_r500.tif	egv_359
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r500.tif")
names(slanis)="egv_359"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousYoung_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_359.png")
```


## ForestsTreesAge_ConiferousYoung_r1250	{#ch06.360}

**filename:** `ForestsTreesAge_ConiferousYoung_r1250.tif`	

**layername:** `egv_360`	

**English name:** Fractional cover of Young (pre-rotation age) Coniferous Forests within the 1.25 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.358) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousYoung_r1250.tif	egv_360
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r1250.tif")
names(slanis)="egv_360"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousYoung_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_360.png")
```


## ForestsTreesAge_ConiferousYoung_r3000	{#ch06.361}

**filename:** `ForestsTreesAge_ConiferousYoung_r3000.tif`	

**layername:** `egv_361`	

**English name:** Fractional cover of Young (pre-rotation age) Coniferous Forests within the 3 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.358) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousYoung_r3000.tif	egv_361
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r3000.tif")
names(slanis)="egv_361"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousYoung_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_361.png")
```


## ForestsTreesAge_ConiferousYoung_r10000	{#ch06.362}

**filename:** `ForestsTreesAge_ConiferousYoung_r10000.tif`	

**layername:** `egv_362`	

**English name:** Fractional cover of Young (pre-rotation age) Coniferous Forests within the 10 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.358) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_ConiferousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_ConiferousYoung_r10000.tif	egv_362
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r10000.tif")
names(slanis)="egv_362"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_ConiferousYoung_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_362.png")
```


## ForestsTreesAge_MixedOld_cell	{#ch06.363}

**filename:** `ForestsTreesAge_MixedOld_cell.tif`	

**layername:** `egv_363`	

**English name:** Fractional cover of Old (over rotation age) Mixed Forests within the analysis cell (1 ha)	

**Latvian name:** Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then mixed stands exceeding the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_MixedOld_cell.tif	egv_363 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="jauktu koku"&(vgr=="4"|vgr=="5"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_MixedOld_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_MixedOld_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_MixedOld_cell.tif",
                            layername = "egv_363",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_MixedOld_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedOld_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_363.png")
```


## ForestsTreesAge_MixedOld_r500	{#ch06.364}

**filename:** `ForestsTreesAge_MixedOld_r500.tif`	

**layername:** `egv_364`	

**English name:** Fractional cover of Old (over rotation age) Mixed Forests within the 0.5 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.363) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedOld_r500.tif	egv_364
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r500.tif")
names(slanis)="egv_364"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedOld_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_364.png")
```


## ForestsTreesAge_MixedOld_r1250	{#ch06.365}

**filename:** `ForestsTreesAge_MixedOld_r1250.tif`	

**layername:** `egv_365`	

**English name:** Fractional cover of Old (over rotation age) Mixed Forests within the 1.25 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.363) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedOld_r1250.tif	egv_365
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r1250.tif")
names(slanis)="egv_365"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedOld_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_365.png")
```


## ForestsTreesAge_MixedOld_r3000	{#ch06.366}

**filename:** `ForestsTreesAge_MixedOld_r3000.tif`	

**layername:** `egv_366`	

**English name:** Fractional cover of Old (over rotation age) Mixed Forests within the 3 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.363) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedOld_r3000.tif	egv_366
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r3000.tif")
names(slanis)="egv_366"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedOld_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_366.png")
```


## ForestsTreesAge_MixedOld_r10000	{#ch06.367}

**filename:** `ForestsTreesAge_MixedOld_r10000.tif`	

**layername:** `egv_367`	

**English name:** Fractional cover of Old (over rotation age) Mixed Forests within the 10 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.363) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedOld_r10000.tif	egv_367
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r10000.tif")
names(slanis)="egv_367"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedOld_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_367.png")
```


## ForestsTreesAge_MixedYoung_cell	{#ch06.368}

**filename:** `ForestsTreesAge_MixedYoung_cell.tif`	

**layername:** `egv_368`	

**English name:** Fractional cover of Young (pre-rotation age) Mixed Forests within the analysis cell (1 ha)	

**Latvian name:** Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then mixed stands younger than the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_MixedYoung_cell.tif	egv_368 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="jauktu koku"&(vgr=="1"|vgr=="2"|vgr=="3"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_MixedYoung_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_MixedYoung_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_MixedYoung_cell.tif",
                            layername = "egv_368",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_MixedYoung_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedYoung_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_368.png")
```


## ForestsTreesAge_MixedYoung_r500	{#ch06.369}

**filename:** `ForestsTreesAge_MixedYoung_r500.tif`	

**layername:** `egv_369`	

**English name:** Fractional cover of Young (pre-rotation age) Mixed Forests within the 0.5 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.368) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedYoung_r500.tif	egv_369
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r500.tif")
names(slanis)="egv_369"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedYoung_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_369.png")
```


## ForestsTreesAge_MixedYoung_r1250	{#ch06.370}

**filename:** `ForestsTreesAge_MixedYoung_r1250.tif`	

**layername:** `egv_370`	

**English name:** Fractional cover of Young (pre-rotation age) Mixed Forests within the 1.25 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.368) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedYoung_r1250.tif	egv_370
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r1250.tif")
names(slanis)="egv_370"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedYoung_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_370.png")
```


## ForestsTreesAge_MixedYoung_r3000	{#ch06.371}

**filename:** `ForestsTreesAge_MixedYoung_r3000.tif`	

**layername:** `egv_371`	

**English name:** Fractional cover of Young (pre-rotation age) Mixed Forests within the 3 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.368) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedYoung_r3000.tif	egv_371
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r3000.tif")
names(slanis)="egv_371"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedYoung_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_371.png")
```


## ForestsTreesAge_MixedYoung_r10000	{#ch06.372}

**filename:** `ForestsTreesAge_MixedYoung_r10000.tif`	

**layername:** `egv_372`	

**English name:** Fractional cover of Young (pre-rotation age) Mixed Forests within the 10 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.368) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_MixedYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_MixedYoung_r10000.tif	egv_372
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r10000.tif")
names(slanis)="egv_372"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_MixedYoung_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_372.png")
```


## ForestsTreesAge_TemperateDeciduousOld_cell	{#ch06.373}

**filename:** `ForestsTreesAge_TemperateDeciduousOld_cell.tif`	

**layername:** `egv_373`	

**English name:** Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then temperate deciduous stands exceeding the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_TemperateDeciduousOld_cell.tif	egv_373 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="platlapju"&(vgr=="4"|vgr=="5"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_TemperateDeciduousOld_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_TemperateDeciduousOld_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_TemperateDeciduousOld_cell.tif",
                            layername = "egv_373",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_TemperateDeciduousOld_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousOld_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_373.png")
```


## ForestsTreesAge_TemperateDeciduousOld_r500	{#ch06.374}

**filename:** `ForestsTreesAge_TemperateDeciduousOld_r500.tif`	

**layername:** `egv_374`	

**English name:** Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.373) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousOld_r500.tif	egv_374
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r500.tif")
names(slanis)="egv_374"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousOld_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_374.png")
```


## ForestsTreesAge_TemperateDeciduousOld_r1250	{#ch06.375}

**filename:** `ForestsTreesAge_TemperateDeciduousOld_r1250.tif`	

**layername:** `egv_375`	

**English name:** Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.373) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousOld_r1250.tif	egv_375
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r1250.tif")
names(slanis)="egv_375"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousOld_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_375.png")
```


## ForestsTreesAge_TemperateDeciduousOld_r3000	{#ch06.376}

**filename:** `ForestsTreesAge_TemperateDeciduousOld_r3000.tif`	

**layername:** `egv_376`	

**English name:** Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 3 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.373) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousOld_r3000.tif	egv_376
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r3000.tif")
names(slanis)="egv_376"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousOld_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_376.png")
```


## ForestsTreesAge_TemperateDeciduousOld_r10000	{#ch06.377}

**filename:** `ForestsTreesAge_TemperateDeciduousOld_r10000.tif`	

**layername:** `egv_377`	

**English name:** Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 10 km landscape	

**Latvian name:** Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.373) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousOld"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousOld_r10000.tif	egv_377
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r10000.tif")
names(slanis)="egv_377"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousOld_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_377.png")
```


## ForestsTreesAge_TemperateDeciduousYoung_cell	{#ch06.378}

**filename:** `ForestsTreesAge_TemperateDeciduousYoung_cell.tif`	

**layername:** `egv_378`	

**English name:** Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then temperate deciduous stands younger than the legal rotation age were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTreesAge_TemperateDeciduousYoung_cell.tif	egv_378 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="platlapju"&(vgr=="1"|vgr=="2"|vgr=="3"))

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTreesAge_TemperateDeciduousYoung_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTreesAge_TemperateDeciduousYoung_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTreesAge_TemperateDeciduousYoung_cell.tif",
                            layername = "egv_378",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTreesAge_TemperateDeciduousYoung_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousYoung_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_378.png")
```


## ForestsTreesAge_TemperateDeciduousYoung_r500	{#ch06.379}

**filename:** `ForestsTreesAge_TemperateDeciduousYoung_r500.tif`	

**layername:** `egv_379`	

**English name:** Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.378) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousYoung_r500.tif	egv_379
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r500.tif")
names(slanis)="egv_379"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousYoung_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_379.png")
```


## ForestsTreesAge_TemperateDeciduousYoung_r1250	{#ch06.380}

**filename:** `ForestsTreesAge_TemperateDeciduousYoung_r1250.tif`	

**layername:** `egv_380`	

**English name:** Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.378) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousYoung_r1250.tif	egv_380
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r1250.tif")
names(slanis)="egv_380"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousYoung_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_380.png")
```


## ForestsTreesAge_TemperateDeciduousYoung_r3000	{#ch06.381}

**filename:** `ForestsTreesAge_TemperateDeciduousYoung_r3000.tif`	

**layername:** `egv_381`	

**English name:** Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 3 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.378) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousYoung_r3000.tif	egv_381
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r3000.tif")
names(slanis)="egv_381"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousYoung_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_381.png")
```


## ForestsTreesAge_TemperateDeciduousYoung_r10000	{#ch06.382}

**filename:** `ForestsTreesAge_TemperateDeciduousYoung_r10000.tif`	

**layername:** `egv_382`	

**English name:** Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 10 km landscape	

**Latvian name:** Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.378) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif"),
  layer_prefixes = c("ForestsTreesAge_TemperateDeciduousYoung"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTreesAge_TemperateDeciduousYoung_r10000.tif	egv_382
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r10000.tif")
names(slanis)="egv_382"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTreesAge_TemperateDeciduousYoung_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_382.png")
```


## ForestsTrees_BorealDeciduous_cell	{#ch06.383}

**filename:** `ForestsTrees_BorealDeciduous_cell.tif`	

**layername:** `egv_383`	

**English name:** Fractional cover of Boeral Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then boreal deciduous stands were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTrees_BorealDeciduous_cell.tif	egv_383 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="saurlapju")

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTrees_BorealDeciduous_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTrees_BorealDeciduous_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTrees_BorealDeciduous_cell.tif",
                            layername = "egv_383",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTrees_BorealDeciduous_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_BorealDeciduous_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_383.png")
```


## ForestsTrees_BorealDeciduous_r500	{#ch06.384}

**filename:** `ForestsTrees_BorealDeciduous_r500.tif`	

**layername:** `egv_384`	

**English name:** Fractional cover of Boreal Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Šaurlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.383) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_BorealDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_BorealDeciduous_r500.tif	egv_384
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r500.tif")
names(slanis)="egv_384"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_BorealDeciduous_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_384.png")
```


## ForestsTrees_BorealDeciduous_r1250	{#ch06.385}

**filename:** `ForestsTrees_BorealDeciduous_r1250.tif`	

**layername:** `egv_385`	

**English name:** Fractional cover of Boreal Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Šaurlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.383) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_BorealDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_BorealDeciduous_r1250.tif	egv_385
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r1250.tif")
names(slanis)="egv_385"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_BorealDeciduous_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_385.png")
```


## ForestsTrees_BorealDeciduous_r3000	{#ch06.386}

**filename:** `ForestsTrees_BorealDeciduous_r3000.tif`	

**layername:** `egv_386`	

**English name:** Fractional cover of Boreal Deciduous Forests within the 3 km landscape	

**Latvian name:** Šaurlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.383) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_BorealDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_BorealDeciduous_r3000.tif	egv_386
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r3000.tif")
names(slanis)="egv_386"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_BorealDeciduous_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_386.png")
```


## ForestsTrees_BorealDeciduous_r10000	{#ch06.387}

**filename:** `ForestsTrees_BorealDeciduous_r10000.tif`	

**layername:** `egv_387`	

**English name:** Fractional cover of Boreal Deciduous Forests within the 10 km landscape	

**Latvian name:** Šaurlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.383) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_BorealDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_BorealDeciduous_r10000.tif	egv_387
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r10000.tif")
names(slanis)="egv_387"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_BorealDeciduous_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_387.png")
```


## ForestsTrees_Coniferous_cell	{#ch06.388}

**filename:** `ForestsTrees_Coniferous_cell.tif`	

**layername:** `egv_388`	

**English name:** Fractional cover of Coniferous Forests within the analysis cell (1 ha)	

**Latvian name:** Skujkoku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then coniferous stands were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTrees_Coniferous_cell.tif	egv_388 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="skujkoku")

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTrees_Coniferous_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTrees_Coniferous_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTrees_Coniferous_cell.tif",
                            layername = "egv_388",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTrees_Coniferous_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Coniferous_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_388.png")
```


## ForestsTrees_Coniferous_r500	{#ch06.389}

**filename:** `ForestsTrees_Coniferous_r500.tif`	

**layername:** `egv_389`	

**English name:** Fractional cover of Coniferous Forests within the 0.5 km landscape	

**Latvian name:** Skujkoku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.388) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif"),
  layer_prefixes = c("ForestsTrees_Coniferous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Coniferous_r500.tif	egv_389
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r500.tif")
names(slanis)="egv_389"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Coniferous_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_389.png")
```


## ForestsTrees_Coniferous_r1250	{#ch06.390}

**filename:** `ForestsTrees_Coniferous_r1250.tif`	

**layername:** `egv_390`	

**English name:** Fractional cover of Coniferous Forests within the 1.25 km landscape	

**Latvian name:** Skujkoku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.388) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif"),
  layer_prefixes = c("ForestsTrees_Coniferous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Coniferous_r1250.tif	egv_390
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r1250.tif")
names(slanis)="egv_390"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Coniferous_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_390.png")
```


## ForestsTrees_Coniferous_r3000	{#ch06.391}

**filename:** `ForestsTrees_Coniferous_r3000.tif`	

**layername:** `egv_391`	

**English name:** Fractional cover of Coniferous Forests within the 3 km landscape	

**Latvian name:** Skujkoku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.388) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif"),
  layer_prefixes = c("ForestsTrees_Coniferous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Coniferous_r3000.tif	egv_391
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r3000.tif")
names(slanis)="egv_391"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Coniferous_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_391.png")
```


## ForestsTrees_Coniferous_r10000	{#ch06.392}

**filename:** `ForestsTrees_Coniferous_r10000.tif`	

**layername:** `egv_392`	

**English name:** Fractional cover of Coniferous Forests within the 10 km landscape	

**Latvian name:** Skujkoku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.388) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif"),
  layer_prefixes = c("ForestsTrees_Coniferous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Coniferous_r10000.tif	egv_392
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r10000.tif")
names(slanis)="egv_392"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Coniferous_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_392.png")
```


## ForestsTrees_Mixed_cell	{#ch06.393}

**filename:** `ForestsTrees_Mixed_cell.tif`	

**layername:** `egv_393`	

**English name:** Fractional cover of Mixed Forests within the analysis cell (1 ha)	

**Latvian name:** Jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then mixed stands were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTrees_Mixed_cell.tif	egv_393 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="jauktu koku")

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTrees_Mixed_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTrees_Mixed_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTrees_Mixed_cell.tif",
                            layername = "egv_393",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTrees_Mixed_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Mixed_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_393.png")
```


## ForestsTrees_Mixed_r500	{#ch06.394}

**filename:** `ForestsTrees_Mixed_r500.tif`	

**layername:** `egv_394`	

**English name:** Fractional cover of Mixed Forests within the 0.5 km landscape	

**Latvian name:** Jauktu koku mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.393) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif"),
  layer_prefixes = c("ForestsTrees_Mixed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Mixed_r500.tif	egv_394
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r500.tif")
names(slanis)="egv_394"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Mixed_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_394.png")
```


## ForestsTrees_Mixed_r1250	{#ch06.395}

**filename:** `ForestsTrees_Mixed_r1250.tif`	

**layername:** `egv_395`	

**English name:** Fractional cover of Mixed Forests within the 1.25 km landscape	

**Latvian name:** Jauktu koku mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.393) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif"),
  layer_prefixes = c("ForestsTrees_Mixed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Mixed_r1250.tif	egv_395
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r1250.tif")
names(slanis)="egv_395"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Mixed_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_395.png")
```


## ForestsTrees_Mixed_r3000	{#ch06.396}

**filename:** `ForestsTrees_Mixed_r3000.tif`	

**layername:** `egv_396`	

**English name:** Fractional cover of Mixed Forests within the 3 km landscape	

**Latvian name:** Jauktu koku mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.393) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif"),
  layer_prefixes = c("ForestsTrees_Mixed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Mixed_r3000.tif	egv_396
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r3000.tif")
names(slanis)="egv_396"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Mixed_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_396.png")
```


## ForestsTrees_Mixed_r10000	{#ch06.397}

**filename:** `ForestsTrees_Mixed_r10000.tif`	

**layername:** `egv_397`	

**English name:** Fractional cover of Mixed Forests within the 10 km landscape	

**Latvian name:** Jauktu koku mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.393) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif"),
  layer_prefixes = c("ForestsTrees_Mixed"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_Mixed_r10000.tif	egv_397
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r10000.tif")
names(slanis)="egv_397"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_Mixed_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_397.png")
```


## ForestsTrees_TemperateDeciduous_cell	{#ch06.398}

**filename:** `ForestsTrees_TemperateDeciduous_cell.tif`	

**layername:** `egv_398`	

**English name:** Fractional cover of Temperate Deciduous Forests within the analysis cell (1 ha)	

**Latvian name:** Platlapju mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Most of forests describing EGVs are spatially restricted outside 
clearcuts and dead stands. Mask for this is created 
from [State Forest Service's State Forest Registry](#Ch04.01) land category 12 and 14 
combined with [The Global Forest Watch](#Ch04.09) pixels classified as lost tree 
canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). 

To prepare this EGV, stands from [State Forest Service's State Forest Registry](#Ch04.01) 
were classified into (in order):

- coniferous (see [Terminology and acronyms](#Ch01) for species codes) if timber volume of those species exceeded 75%;

- boreal deciduous if timber volume of those species exceeded 75%;

- temperate deciduous if timber volume of those species exceeded 50%;

- mixed otherwise;

then temperate deciduous stands were selected and 
geometries were rasterized (presence = 1, NA otherwise). Rasterization was 
performed by `egvtools:polygon2input()` 
restricting to pixels outside clearcut mask and covering background with value 0. 
The resulting layer was then 
aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")


# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")

# mvr ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
mvr$yes=1

# clear cut mask ----
izcirtumi=mvr %>% 
  filter(zkat %in% c("12","14")) %>% 
  dplyr::select(yes)
r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field="yes")
t_izcirtumi_mvr=rast(r_izcirtumi_mvr)
plot(t_izcirtumi_mvr)

tcl=rast("./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif")
tcl2=ifel(tcl<20,0,1)
tclX=cover(tcl2,nulls10)
plot(tclX)

clearcut_mask=cover(t_izcirtumi_mvr,tclX,
                    filename="./RasterGrids_10m/2024/Mask_clearcuts.tif",
                    overwrite=TRUE)
plot(clearcut_mask)

rm(izcirtumi)
rm(r_izcirtumi_mvr)
rm(t_izcirtumi_mvr)
rm(tcl)
rm(tcl2)
rm(tclX)

# ForestsTrees_TemperateDeciduous_cell.tif	egv_398 ----
skujkoki=c("1","3","13","14","15","22","23") # 7
saurlapji=c("4","6","8","9","19","20","21","32","35","50","68") # 11
platlapji=c("10","11","12","16","17","18","24","25","26","27","28","29",
            "61","62","63","64","65","66","67","69") # 20
mvr=mvr %>% 
  mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+
           ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+
           ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0),
         kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+
           ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+
           ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0),
         kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+
           ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+
           ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %>% 
  mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %>% 
  mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja>=0.75,"skujkoku",
                     ifelse(kraja_saurlapju/kopeja_kraja>=0.75,"saurlapju",
                            ifelse(kraja_platlapju/kopeja_kraja>0.5,"platlapju",
                                   "jauktu koku"))))
nogabali=mvr %>% 
  filter(zkat=="10"&tips=="platlapju")

p2i_rez=egvtools::polygon2input(vector_data = nogabali,
                                template_path = "./Templates/TemplateRasters/LV10m_10km.tif",
                                out_path = "./RasterGrids_10m/2024/",
                                file_name = "ForestsTrees_TemperateDeciduous_input.tif",
                                value_field = "yes",
                                restrict_to = clearcut_mask,
                                restrict_values = 0,
                                prepare=FALSE,
                                background_raster = "./Templates/TemplateRasters/nulls_LV10m_10km.tif",
                                plot_result = TRUE)
p2i_rez
i2e_rez=egvtools::input2egv(input=paste0("./RasterGrids_10m/2024/",
                                         "ForestsTrees_TemperateDeciduous_input.tif"),
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "ForestsTrees_TemperateDeciduous_cell.tif",
                            layername = "egv_398",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(nogabali)
rm(p2i_rez)
rm(i2e_rez)
unlink("./RasterGrids_10m/2024/ForestsTrees_TemperateDeciduous_input.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_TemperateDeciduous_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_398.png")
```


## ForestsTrees_TemperateDeciduous_r500	{#ch06.399}

**filename:** `ForestsTrees_TemperateDeciduous_r500.tif`	

**layername:** `egv_399`	

**English name:** Fractional cover of Temperate Deciduous Forests within the 0.5 km landscape	

**Latvian name:** Platlapju mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.398) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_TemperateDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_TemperateDeciduous_r500.tif	egv_399
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r500.tif")
names(slanis)="egv_399"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_TemperateDeciduous_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_399.png")
```


## ForestsTrees_TemperateDeciduous_r1250	{#ch06.400}

**filename:** `ForestsTrees_TemperateDeciduous_r1250.tif`	

**layername:** `egv_400`	

**English name:** Fractional cover of Temperate Deciduous Forests within the 1.25 km landscape	

**Latvian name:** Platlapju mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.398) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_TemperateDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_TemperateDeciduous_r1250.tif	egv_400
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r1250.tif")
names(slanis)="egv_400"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_TemperateDeciduous_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_400.png")
```


## ForestsTrees_TemperateDeciduous_r3000	{#ch06.401}

**filename:** `ForestsTrees_TemperateDeciduous_r3000.tif`	

**layername:** `egv_401`	

**English name:** Fractional cover of Temperate Deciduous Forests within the 3 km landscape	

**Latvian name:** Platlapju mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.398) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_TemperateDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_TemperateDeciduous_r3000.tif	egv_401
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r3000.tif")
names(slanis)="egv_401"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_TemperateDeciduous_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_401.png")
```


## ForestsTrees_TemperateDeciduous_r10000	{#ch06.402}

**filename:** `ForestsTrees_TemperateDeciduous_r10000.tif`	

**layername:** `egv_402`	

**English name:** Fractional cover of Temperate Deciduous Forests within the 10 km landscape	

**Latvian name:** Platlapju mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.398) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif"),
  layer_prefixes = c("ForestsTrees_TemperateDeciduous"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# ForestsTrees_TemperateDeciduous_r10000.tif	egv_402
slanis=rast("./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r10000.tif")
names(slanis)="egv_402"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="ForestsTrees_TemperateDeciduous_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_402.png")
```


## General_AllotmentGardens_cell	{#ch06.403}

**filename:** `General_AllotmentGardens_cell.tif`	

**layername:** `egv_403`	

**English name:** Fractional cover of Allotment gardens within the analysis cell (1 ha)	

**Latvian name:** Vasarnīcu kompleksu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, allotment gardens and farmsteads from [Landscape classification](#Ch05.03) were selected (value 410 reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_AllotmentGardens_cell.tif	egv_403 ----
allotmentgardens=ifel(simple_landscape==410,1,0)
i2e_rez=egvtools::input2egv(input=allotmentgardens,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_AllotmentGardens_cell.tif",
                            layername = "egv_403",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(allotmentgardens)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_AllotmentGardens_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_403.png")
```


## General_AllotmentGardens_r500	{#ch06.404}

**filename:** `General_AllotmentGardens_r500.tif`	

**layername:** `egv_404`	

**English name:** Fractional cover of Allotment gardens within the 0.5 km landscape	

**Latvian name:** Vasarnīcu kompleksu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.403) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif"),
  layer_prefixes = c("General_AllotmentGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_AllotmentGardens_r500.tif	egv_404
slanis=rast("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r500.tif")
names(slanis)="egv_404"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_AllotmentGardens_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_404.png")
```


## General_AllotmentGardens_r1250	{#ch06.405}

**filename:** `General_AllotmentGardens_r1250.tif`	

**layername:** `egv_405`	

**English name:** Fractional cover of Allotment gardens within the 1.25 km landscape	

**Latvian name:** Vasarnīcu kompleksu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.403) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif"),
  layer_prefixes = c("General_AllotmentGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_AllotmentGardens_r1250.tif	egv_405
slanis=rast("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r1250.tif")
names(slanis)="egv_405"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_AllotmentGardens_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_405.png")
```


## General_AllotmentGardens_r3000	{#ch06.406}

**filename:** `General_AllotmentGardens_r3000.tif`	

**layername:** `egv_406`	

**English name:** Fractional cover of Allotment gardens within the 3 km landscape	

**Latvian name:** Vasarnīcu kompleksu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.403) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif"),
  layer_prefixes = c("General_AllotmentGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_AllotmentGardens_r3000.tif	egv_406
slanis=rast("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r3000.tif")
names(slanis)="egv_406"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_AllotmentGardens_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_406.png")
```


## General_AllotmentGardens_r10000	{#ch06.407}

**filename:** `General_AllotmentGardens_r10000.tif`	

**layername:** `egv_407`	

**English name:** Fractional cover of Allotment gardens within the 10 km landscape	

**Latvian name:** Vasarnīcu kompleksu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.403) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif"),
  layer_prefixes = c("General_AllotmentGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_AllotmentGardens_r10000.tif	egv_407
slanis=rast("./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r10000.tif")
names(slanis)="egv_407"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_AllotmentGardens_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_407.png")
```


## General_BareSoilQuarry_cell	{#ch06.408}

**filename:** `General_BareSoilQuarry_cell.tif`	

**layername:** `egv_408`	

**English name:** Fractional cover of areas with Bare Soil, Quarries within the analysis cell (1 ha)	

**Latvian name:** Atklātas augsnes un karjeru platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, bare soil and querry areas from [Landscape classification](#Ch05.03) were selected (value 800 reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_BareSoilQuarry_cell.tif	egv_408 ----
baresoilquerry=ifel(simple_landscape==800,1,0)
i2e_rez=egvtools::input2egv(input=baresoilquerry,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_BareSoilQuarry_cell.tif",
                            layername = "egv_408",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(baresoilquerry)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_BareSoilQuarry_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_408.png")
```


## General_BareSoilQuarry_r500	{#ch06.409}

**filename:** `General_BareSoilQuarry_r500.tif`	

**layername:** `egv_409`	

**English name:** Fractional cover of areas with Bare Soil, Quarries within the 0.5 km landscape	

**Latvian name:** Atklātas augsnes un karjeru platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.408) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif"),
  layer_prefixes = c("General_BareSoilQuarry"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_BareSoilQuarry_r500.tif	egv_409
slanis=rast("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r500.tif")
names(slanis)="egv_409"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_BareSoilQuarry_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_409.png")
```


## General_BareSoilQuarry_r1250	{#ch06.410}

**filename:** `General_BareSoilQuarry_r1250.tif`	

**layername:** `egv_410`	

**English name:** Fractional cover of areas with Bare Soil, Quarries within the 1.25 km landscape	

**Latvian name:** Atklātas augsnes un karjeru platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.408) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif"),
  layer_prefixes = c("General_BareSoilQuarry"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_BareSoilQuarry_r1250.tif	egv_410
slanis=rast("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r1250.tif")
names(slanis)="egv_410"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_BareSoilQuarry_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_410.png")
```


## General_BareSoilQuarry_r3000	{#ch06.411}

**filename:** `General_BareSoilQuarry_r3000.tif`	

**layername:** `egv_411`	

**English name:** Fractional cover of areas with Bare Soil, Quarries within the 3 km landscape	

**Latvian name:** Atklātas augsnes un karjeru platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.408) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif"),
  layer_prefixes = c("General_BareSoilQuarry"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_BareSoilQuarry_r3000.tif	egv_411
slanis=rast("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r3000.tif")
names(slanis)="egv_411"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_BareSoilQuarry_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_411.png")
```


## General_BareSoilQuarry_r10000	{#ch06.412}

**filename:** `General_BareSoilQuarry_r10000.tif`	

**layername:** `egv_412`	

**English name:** Fractional cover of areas with Bare Soil, Quarries within the 10 km landscape	

**Latvian name:** Atklātas augsnes un karjeru platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.408) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif"),
  layer_prefixes = c("General_BareSoilQuarry"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_BareSoilQuarry_r10000.tif	egv_412
slanis=rast("./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r10000.tif")
names(slanis)="egv_412"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_BareSoilQuarry_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_412.png")
```


## General_Builtup_cell	{#ch06.413}

**filename:** `General_Builtup_cell.tif`	

**layername:** `egv_413`	

**English name:** Fractional cover of Built-Up areas within the analysis cell (1 ha)	

**Latvian name:** Apbūves platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, builtup areas from [Landscape classification](#Ch05.03) were selected (value 500 reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_Builtup_cell.tif	egv_413 ----
builtup=ifel(simple_landscape==500,1,0)
i2e_rez=egvtools::input2egv(input=builtup,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_Builtup_cell.tif",
                            layername = "egv_413",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(builtup)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Builtup_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_413.png")
```


## General_Builtup_r500	{#ch06.414}

**filename:** `General_Builtup_r500.tif`	

**layername:** `egv_414`	

**English name:** Fractional cover of Built-Up areas within the 0.5 km landscape	

**Latvian name:** Apbūves platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.413) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif"),
  layer_prefixes = c("General_Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Builtup_r500.tif	egv_414
slanis=rast("./RasterGrids_100m/2024/RAW/General_Builtup_r500.tif")
names(slanis)="egv_414"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Builtup_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Builtup_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_414.png")
```


## General_Builtup_r1250	{#ch06.415}

**filename:** `General_Builtup_r1250.tif`	

**layername:** `egv_415`	

**English name:** Fractional cover of Built-Up areas within the 1.25 km landscape	

**Latvian name:** Apbūves platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.413) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif"),
  layer_prefixes = c("General_Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Builtup_r1250.tif	egv_415
slanis=rast("./RasterGrids_100m/2024/RAW/General_Builtup_r1250.tif")
names(slanis)="egv_415"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Builtup_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Builtup_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_415.png")
```


## General_Builtup_r3000	{#ch06.416}

**filename:** `General_Builtup_r3000.tif`	

**layername:** `egv_416`	

**English name:** Fractional cover of Built-Up areas within the 3 km landscape	

**Latvian name:** Apbūves platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.413) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif"),
  layer_prefixes = c("General_Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Builtup_r3000.tif	egv_416
slanis=rast("./RasterGrids_100m/2024/RAW/General_Builtup_r3000.tif")
names(slanis)="egv_416"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Builtup_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Builtup_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_416.png")
```


## General_Builtup_r10000	{#ch06.417}

**filename:** `General_Builtup_r10000.tif`	

**layername:** `egv_417`	

**English name:** Fractional cover of Built-Up areas within the 10 km landscape	

**Latvian name:** Apbūves platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.413) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif"),
  layer_prefixes = c("General_Builtup"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Builtup_r10000.tif	egv_417
slanis=rast("./RasterGrids_100m/2024/RAW/General_Builtup_r10000.tif")
names(slanis)="egv_417"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Builtup_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Builtup_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_417.png")
```


## General_Farmland_cell	{#ch06.418}

**filename:** `General_Farmland_cell.tif`	

**layername:** `egv_418`	

**English name:** Fractional cover of Farmland within the analysis cell (1 ha)	

**Latvian name:** Lauksaimniecībā izmantojamo zemju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, farmlands from [Landscape classification](#Ch05.03) were selected (values between 300 and 400 were reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_Farmland_cell.tif	egv_418 ----
farmland=ifel(simple_landscape>=300&simple_landscape<400,1,0)
i2e_rez=egvtools::input2egv(input=farmland,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_Farmland_cell.tif",
                            layername = "egv_418",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(farmland)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Farmland_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_418.png")
```


## General_Farmland_r500	{#ch06.419}

**filename:** `General_Farmland_r500.tif`	

**layername:** `egv_419`	

**English name:** Fractional cover of Farmland within the 0.5 km landscape	

**Latvian name:** Lauksaimniecībā izmantojamo zemju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.418) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif"),
  layer_prefixes = c("General_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Farmland_r500.tif	egv_419
slanis=rast("./RasterGrids_100m/2024/RAW/General_Farmland_r500.tif")
names(slanis)="egv_419"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Farmland_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Farmland_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_419.png")
```


## General_Farmland_r1250	{#ch06.420}

**filename:** `General_Farmland_r1250.tif`	

**layername:** `egv_420`	

**English name:** Fractional cover of Farmland within the 1.25 km landscape	

**Latvian name:** Lauksaimniecībā izmantojamo zemju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.418) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif"),
  layer_prefixes = c("General_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Farmland_r1250.tif	egv_420
slanis=rast("./RasterGrids_100m/2024/RAW/General_Farmland_r1250.tif")
names(slanis)="egv_420"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Farmland_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Farmland_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_420.png")
```


## General_Farmland_r3000	{#ch06.421}

**filename:** `General_Farmland_r3000.tif`	

**layername:** `egv_421`	

**English name:** Fractional cover of Farmland within the 3 km landscape	

**Latvian name:** Lauksaimniecībā izmantojamo zemju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.418) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif"),
  layer_prefixes = c("General_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Farmland_r3000.tif	egv_421
slanis=rast("./RasterGrids_100m/2024/RAW/General_Farmland_r3000.tif")
names(slanis)="egv_421"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Farmland_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Farmland_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_421.png")
```


## General_Farmland_r10000	{#ch06.422}

**filename:** `General_Farmland_r10000.tif`	

**layername:** `egv_422`	

**English name:** Fractional cover of Farmland within the 10 km landscape	

**Latvian name:** Lauksaimniecībā izmantojamo zemju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.418) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif"),
  layer_prefixes = c("General_Farmland"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Farmland_r10000.tif	egv_422
slanis=rast("./RasterGrids_100m/2024/RAW/General_Farmland_r10000.tif")
names(slanis)="egv_422"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Farmland_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Farmland_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_422.png")
```


## General_ForestsWithoutInventory_cell	{#ch06.423}

**filename:** `General_ForestsWithoutInventory_cell.tif`	

**layername:** `egv_423`	

**English name:** Fractional cover of Forests Without Inventory within the analysis cell (1 ha)	

**Latvian name:** Netaksēto mežu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, clearcuts and forest stands from [State Forest Service's State Forest Registry](#Ch04.01) were rasterized to match inputs (value 1 and NA elsewhere). Then, from [Landscape classification](#Ch05.03) class 630 was reclassified to value 1, others to 0). These layers were then combined so that values 1 from the second layer, where spatially matching NA values in the first layer as classified as 1 and 0 otherwise. 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_ForestsWithoutInventory_cell.tif	egv_423 ----
mvr=st_read_parquet("./Geodata/2024/MVR/nogabali_2024janv.parquet")
tksetie=mvr %>% 
  mutate(yes=1) %>% 
  filter(zkat %in% c("10","12","14","16"))
taksetie_r=fasterize(tksetie,rastrs10,field="yes",fun="first")
taksetie_t=rast(taksetie_r)
visi_mezi=ifel(simple_landscape==630,1,0)
netaksetie=ifel(is.na(taksetie_t)&visi_mezi==1,1,0)
plot(netaksetie)

i2e_rez=egvtools::input2egv(input=netaksetie,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_ForestsWithoutInventory_cell.tif",
                            layername = "egv_423",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(netaksetie)
rm(i2e_rez)
rm(mvr)
rm(tksetie)
rm(taksetie_r)
rm(taksetie_t)
rm(visi_mezi)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ForestsWithoutInventory_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_423.png")
```


## General_ForestsWithoutInventory_r500	{#ch06.424}

**filename:** `General_ForestsWithoutInventory_r500.tif`	

**layername:** `egv_424`	

**English name:** Fractional cover of Forests Without Inventory within the 0.5 km landscape	

**Latvian name:** Netaksēto mežu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.423) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif"),
  layer_prefixes = c("General_ForestsWithoutInventory"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ForestsWithoutInventory_r500.tif	egv_424
slanis=rast("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r500.tif")
names(slanis)="egv_424"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ForestsWithoutInventory_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_424.png")
```


## General_ForestsWithoutInventory_r1250	{#ch06.425}

**filename:** `General_ForestsWithoutInventory_r1250.tif`	

**layername:** `egv_425`	

**English name:** Fractional cover of Forests Without Inventory within the 1.25 km landscape	

**Latvian name:** Netaksēto mežu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.423) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif"),
  layer_prefixes = c("General_ForestsWithoutInventory"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ForestsWithoutInventory_r1250.tif	egv_425
slanis=rast("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r1250.tif")
names(slanis)="egv_425"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ForestsWithoutInventory_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_425.png")
```


## General_ForestsWithoutInventory_r3000	{#ch06.426}

**filename:** `General_ForestsWithoutInventory_r3000.tif`	

**layername:** `egv_426`	

**English name:** Fractional cover of Forests Without Inventory within the 3 km landscape	

**Latvian name:** Netaksēto mežu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.423) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif"),
  layer_prefixes = c("General_ForestsWithoutInventory"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ForestsWithoutInventory_r3000.tif	egv_426
slanis=rast("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r3000.tif")
names(slanis)="egv_426"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ForestsWithoutInventory_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_426.png")
```


## General_ForestsWithoutInventory_r10000	{#ch06.427}

**filename:** `General_ForestsWithoutInventory_r10000.tif`	

**layername:** `egv_427`	

**English name:** Fractional cover of Forests Without Inventory within the 10 km landscape	

**Latvian name:** Netaksēto mežu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.423) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif"),
  layer_prefixes = c("General_ForestsWithoutInventory"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ForestsWithoutInventory_r10000.tif	egv_427
slanis=rast("./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r10000.tif")
names(slanis)="egv_427"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ForestsWithoutInventory_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_427.png")
```


## General_GardensOrchards_cell	{#ch06.428}

**filename:** `General_GardensOrchards_cell.tif`	

**layername:** `egv_428`	

**English name:** Fractional cover of Allotment gardens, Orchards within the analysis cell (1 ha)	

**Latvian name:** Vasarnīcu kompleksu un augļudārzu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, allotment gardens and ochards from [Landscape classification](#Ch05.03) were selected (values between 400 and 500 were reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_GardensOrchards_cell.tif	egv_428 ----
parejie=ifel(simple_landscape>=400&simple_landscape<500,1,0)
i2e_rez=egvtools::input2egv(input=parejie,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_GardensOrchards_cell.tif",
                            layername = "egv_428",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(parejie)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_GardensOrchards_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_428.png")
```


## General_GardensOrchards_r500	{#ch06.429}

**filename:** `General_GardensOrchards_r500.tif`	

**layername:** `egv_429`	

**English name:** Fractional cover of Allotment gardens, Orchards within the 0.5 km landscape	

**Latvian name:** Vasarnīcu kompleksu un augļudārzu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.428) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif"),
  layer_prefixes = c("General_GardensOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_GardensOrchards_r500.tif	egv_429
slanis=rast("./RasterGrids_100m/2024/RAW/General_GardensOrchards_r500.tif")
names(slanis)="egv_429"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_GardensOrchards_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_GardensOrchards_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_429.png")
```


## General_GardensOrchards_r1250	{#ch06.430}

**filename:** `General_GardensOrchards_r1250.tif`	

**layername:** `egv_430`	

**English name:** Fractional cover of Allotment gardens, Orchards within the 1.25 km landscape	

**Latvian name:** Vasarnīcu kompleksu un augļudārzu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.428) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif"),
  layer_prefixes = c("General_GardensOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_GardensOrchards_r1250.tif	egv_430
slanis=rast("./RasterGrids_100m/2024/RAW/General_GardensOrchards_r1250.tif")
names(slanis)="egv_430"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_GardensOrchards_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_GardensOrchards_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_430.png")
```


## General_GardensOrchards_r3000	{#ch06.431}

**filename:** `General_GardensOrchards_r3000.tif`	

**layername:** `egv_431`	

**English name:** Fractional cover of Allotment gardens, Orchards within the 3 km landscape	

**Latvian name:** Vasarnīcu kompleksu un augļudārzu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.428) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif"),
  layer_prefixes = c("General_GardensOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_GardensOrchards_r3000.tif	egv_431
slanis=rast("./RasterGrids_100m/2024/RAW/General_GardensOrchards_r3000.tif")
names(slanis)="egv_431"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_GardensOrchards_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_GardensOrchards_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_431.png")
```


## General_GardensOrchards_r10000	{#ch06.432}

**filename:** `General_GardensOrchards_r10000.tif`	

**layername:** `egv_432`	

**English name:** Fractional cover of Allotment gardens, Orchards within the 10 km landscape	

**Latvian name:** Vasarnīcu kompleksu un augļudārzu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.428) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif"),
  layer_prefixes = c("General_GardensOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_GardensOrchards_r10000.tif	egv_432
slanis=rast("./RasterGrids_100m/2024/RAW/General_GardensOrchards_r10000.tif")
names(slanis)="egv_432"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_GardensOrchards_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_GardensOrchards_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_432.png")
```


## General_Roads_cell	{#ch06.433}

**filename:** `General_Roads_cell.tif`	

**layername:** `egv_433`	

**English name:** Fractional cover of Roads within the analysis cell (1 ha)	

**Latvian name:** Ceļu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, roads from [Landscape classification](#Ch05.03) were selected (values equal to 100 were reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_Roads_cell.tif	egv_433 ----
celi=ifel(simple_landscape==100,1,0)
i2e_rez=egvtools::input2egv(input=celi,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_Roads_cell.tif",
                            layername = "egv_433",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(celi)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Roads_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_433.png")
```


## General_ShrubsOrchards_cell	{#ch06.434}

**filename:** `General_ShrubsOrchards_cell.tif`	

**layername:** `egv_434`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards within the analysis cell (1 ha)	

**Latvian name:** Krūmāju, jaunaudžu un augļudārzu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as short term coppice were selected from 
[Rural Support Service's information on declared fields](#Ch04.02) and rasterized to match inputs. Then orchards and shrubs-low forest stands from [Landscape classification](#Ch05.03) were selected (values equal to 420 or 620 were reclassified to
value 1, others as 0). The first layer was then covered over the second.
Once covered, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_ShrubsOrchards_cell.tif	egv_434 ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
table(kodi$SDM_grupa_sakums,useNA="always")
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))
ilggadigiekrumveida=lad %>% 
  filter(SDM_grupa_sakums == "krūmveida ilggadīgie stādījumi")
krumveida_r=fasterize(ilggadigiekrumveida,rastrs10,field="yes",fun="first")
krumveida_t=rast(krumveida_r)
augludarzi=ifel(simple_landscape==420|simple_landscape==620,1,0)
apvienoti=cover(krumveida_t,augludarzi)
plot(apvienoti)

i2e_rez=egvtools::input2egv(input=apvienoti,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_ShrubsOrchards_cell.tif",
                            layername = "egv_434",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(apvienoti)
rm(i2e_rez)
rm(ilggadigiekrumveida)
rm(krumveida_r)
rm(krumveida_t)
rm(augludarzi)

rm(kodi)
rm(lad)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchards_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_434.png")
```


## General_ShrubsOrchards_r500	{#ch06.435}

**filename:** `General_ShrubsOrchards_r500.tif`	

**layername:** `egv_435`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards within the 0.5 km landscape	

**Latvian name:** Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.434) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchards_r500.tif	egv_435
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r500.tif")
names(slanis)="egv_435"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchards_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_435.png")
```


## General_ShrubsOrchards_r1250	{#ch06.436}

**filename:** `General_ShrubsOrchards_r1250.tif`	

**layername:** `egv_436`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards within the 1.25 km landscape	

**Latvian name:** Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.434) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchards_r1250.tif	egv_436
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r1250.tif")
names(slanis)="egv_436"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchards_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_436.png")
```


## General_ShrubsOrchards_r3000	{#ch06.437}

**filename:** `General_ShrubsOrchards_r3000.tif`	

**layername:** `egv_437`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards within the 3 km landscape	

**Latvian name:** Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.434) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchards_r3000.tif	egv_437
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r3000.tif")
names(slanis)="egv_437"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchards_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_437.png")
```


## General_ShrubsOrchards_r10000	{#ch06.438}

**filename:** `General_ShrubsOrchards_r10000.tif`	

**layername:** `egv_438`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards within the 10 km landscape	

**Latvian name:** Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.434) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchards"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchards_r10000.tif	egv_438
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r10000.tif")
names(slanis)="egv_438"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchards_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_438.png")
```


## General_ShrubsOrchardsGardens_cell	{#ch06.439}

**filename:** `General_ShrubsOrchardsGardens_cell.tif`	

**layername:** `egv_439`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the analysis cell (1 ha)	

**Latvian name:** Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, agricultural parcels declared as short term coppice were selected from 
[Rural Support Service's information on declared fields](#Ch04.02) and rasterized to match inputs. Then orchards, allotment gardens and shrubs-low forest stands from [Landscape classification](#Ch05.03) were selected (values between 400 and 500 or equal to 620 were reclassified to
value 1, others as 0). The first layer was then covered over the second.
Once covered, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_ShrubsOrchardsGardens_cell.tif	egv_439 ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
table(kodi$SDM_grupa_sakums,useNA="always")
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))
ilggadigiekrumveida=lad %>% 
  filter(SDM_grupa_sakums == "krūmveida ilggadīgie stādījumi")
krumveida_r=fasterize(ilggadigiekrumveida,rastrs10,field="yes",fun="first")
krumveida_t=rast(krumveida_r)
parejie=ifel((simple_landscape>=400&simple_landscape<500)|
               simple_landscape==620,1,0)
apvienoti=cover(krumveida_t,parejie)
plot(apvienoti)

i2e_rez=egvtools::input2egv(input=apvienoti,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_ShrubsOrchardsGardens_cell.tif",
                            layername = "egv_439",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(apvienoti)
rm(i2e_rez)
rm(ilggadigiekrumveida)
rm(krumveida_r)
rm(krumveida_t)
rm(parejie)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchardsGardens_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_439.png")
```


## General_ShrubsOrchardsGardens_r500	{#ch06.440}

**filename:** `General_ShrubsOrchardsGardens_r500.tif`	

**layername:** `egv_440`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 0.5 km landscape	

**Latvian name:** Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.439) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchardsGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchardsGardens_r500.tif	egv_440
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r500.tif")
names(slanis)="egv_440"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchardsGardens_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_440.png")
```


## General_ShrubsOrchardsGardens_r1250	{#ch06.441}

**filename:** `General_ShrubsOrchardsGardens_r1250.tif`	

**layername:** `egv_441`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 1.25 km landscape	

**Latvian name:** Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.439) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchardsGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchardsGardens_r1250.tif	egv_441
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r1250.tif")
names(slanis)="egv_441"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchardsGardens_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_441.png")
```


## General_ShrubsOrchardsGardens_r3000	{#ch06.442}

**filename:** `General_ShrubsOrchardsGardens_r3000.tif`	

**layername:** `egv_442`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 3 km landscape	

**Latvian name:** Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.439) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchardsGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchardsGardens_r3000.tif	egv_442
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r3000.tif")
names(slanis)="egv_442"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchardsGardens_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_442.png")
```


## General_ShrubsOrchardsGardens_r10000	{#ch06.443}

**filename:** `General_ShrubsOrchardsGardens_r10000.tif`	

**layername:** `egv_443`	

**English name:** Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 10 km landscape	

**Latvian name:** Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.439) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif"),
  layer_prefixes = c("General_ShrubsOrchardsGardens"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_ShrubsOrchardsGardens_r10000.tif	egv_443
slanis=rast("./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r10000.tif")
names(slanis)="egv_443"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_ShrubsOrchardsGardens_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_443.png")
```


## General_SwampsMiresBogsHelophytes_cell	{#ch06.444}

**filename:** `General_SwampsMiresBogsHelophytes_cell.tif`	

**layername:** `egv_444`	

**English name:** Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the analysis cell (1 ha)	

**Latvian name:** Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, swamps, mires, bogs and reed, sedge, rush beds from [Landscape classification](#Ch05.03) were selected (values between 700 and 800 were reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_SwampsMiresBogsHelophytes_cell.tif	egv_444 ----
purvi=ifel(simple_landscape>=700&simple_landscape<800,1,0)
i2e_rez=egvtools::input2egv(input=purvi,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_SwampsMiresBogsHelophytes_cell.tif",
                            layername = "egv_444",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(purvi)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_SwampsMiresBogsHelophytes_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_444.png")
```


## General_SwampsMiresBogsHelophytes_r500	{#ch06.445}

**filename:** `General_SwampsMiresBogsHelophytes_r500.tif`	

**layername:** `egv_445`	

**English name:** Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 0.5 km landscape	

**Latvian name:** Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.444) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif"),
  layer_prefixes = c("General_SwampsMiresBogsHelophytes"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_SwampsMiresBogsHelophytes_r500.tif	egv_445
slanis=rast("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r500.tif")
names(slanis)="egv_445"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_SwampsMiresBogsHelophytes_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_445.png")
```


## General_SwampsMiresBogsHelophytes_r1250	{#ch06.446}

**filename:** `General_SwampsMiresBogsHelophytes_r1250.tif`	

**layername:** `egv_446`	

**English name:** Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 1.25 km landscape	

**Latvian name:** Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.444) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif"),
  layer_prefixes = c("General_SwampsMiresBogsHelophytes"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_SwampsMiresBogsHelophytes_r1250.tif	egv_446
slanis=rast("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r1250.tif")
names(slanis)="egv_446"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_SwampsMiresBogsHelophytes_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_446.png")
```


## General_SwampsMiresBogsHelophytes_r3000	{#ch06.447}

**filename:** `General_SwampsMiresBogsHelophytes_r3000.tif`	

**layername:** `egv_447`	

**English name:** Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 3 km landscape	

**Latvian name:** Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.444) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif"),
  layer_prefixes = c("General_SwampsMiresBogsHelophytes"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_SwampsMiresBogsHelophytes_r3000.tif	egv_447
slanis=rast("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r3000.tif")
names(slanis)="egv_447"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_SwampsMiresBogsHelophytes_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_447.png")
```


## General_SwampsMiresBogsHelophytes_r10000	{#ch06.448}

**filename:** `General_SwampsMiresBogsHelophytes_r10000.tif`	

**layername:** `egv_448`	

**English name:** Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 10 km landscape	

**Latvian name:** Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.444) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif"),
  layer_prefixes = c("General_SwampsMiresBogsHelophytes"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_SwampsMiresBogsHelophytes_r10000.tif	egv_448
slanis=rast("./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r10000.tif")
names(slanis)="egv_448"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_SwampsMiresBogsHelophytes_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_448.png")
```


## General_Trees_cell	{#ch06.449}

**filename:** `General_Trees_cell.tif`	

**layername:** `egv_449`	

**English name:** Fractional cover of Trees, Shrubs, Clear-cuts within the analysis cell (1 ha)	

**Latvian name:** Koku, krūmu un izcirtumu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, trees, shrubs and clear cuts from [Landscape classification](#Ch05.03) were selected (values between 600 and 700 were reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_Trees_cell.tif	egv_449 ----
kokimezi=ifel(simple_landscape>=600&simple_landscape<700,1,0)
i2e_rez=egvtools::input2egv(input=kokimezi,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_Trees_cell.tif",
                            layername = "egv_449",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(kokimezi)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Trees_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_449.png")
```


## General_Trees_r500	{#ch06.450}

**filename:** `General_Trees_r500.tif`	

**layername:** `egv_450`	

**English name:** Fractional cover of Trees, Shrubs, Clear-cuts within the 0.5 km landscape	

**Latvian name:** Koku, krūmu un izcirtumu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.449) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Trees_cell.tif"),
  layer_prefixes = c("General_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Trees_r500.tif	egv_450
slanis=rast("./RasterGrids_100m/2024/RAW/General_Trees_r500.tif")
names(slanis)="egv_450"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Trees_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Trees_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_450.png")
```


## General_Trees_r1250	{#ch06.451}

**filename:** `General_Trees_r1250.tif`	

**layername:** `egv_451`	

**English name:** Fractional cover of Trees, Shrubs, Clear-cuts within the 1.25 km landscape	

**Latvian name:** Koku, krūmu un izcirtumu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.449) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Trees_cell.tif"),
  layer_prefixes = c("General_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Trees_r1250.tif	egv_451
slanis=rast("./RasterGrids_100m/2024/RAW/General_Trees_r1250.tif")
names(slanis)="egv_451"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Trees_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Trees_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_451.png")
```


## General_Trees_r3000	{#ch06.452}

**filename:** `General_Trees_r3000.tif`	

**layername:** `egv_452`	

**English name:** Fractional cover of Trees, Shrubs, Clear-cuts within the 3 km landscape	

**Latvian name:** Koku, krūmu un izcirtumu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.449) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Trees_cell.tif"),
  layer_prefixes = c("General_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Trees_r3000.tif	egv_452
slanis=rast("./RasterGrids_100m/2024/RAW/General_Trees_r3000.tif")
names(slanis)="egv_452"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Trees_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Trees_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_452.png")
```


## General_Trees_r10000	{#ch06.453}

**filename:** `General_Trees_r10000.tif`	

**layername:** `egv_453`	

**English name:** Fractional cover of Trees, Shrubs, Clear-cuts within the 10 km landscape	

**Latvian name:** Koku, krūmu un izcirtumu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.449) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Trees_cell.tif"),
  layer_prefixes = c("General_Trees"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Trees_r10000.tif	egv_453
slanis=rast("./RasterGrids_100m/2024/RAW/General_Trees_r10000.tif")
names(slanis)="egv_453"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Trees_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Trees_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_453.png")
```


## General_TreesOutsideForests_cell	{#ch06.454}

**filename:** `General_TreesOutsideForests_cell.tif`	

**layername:** `egv_454`	

**English name:** Fractional cover of Tree covered areas Outside Forests within the analysis cell (1 ha)	

**Latvian name:** Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, tree outside forest stands from [Landscape classification](#Ch05.03) were selected (values equal to 640 were reclassified to
value 1, others as 0). Then the layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_TreesOutsideForests_cell.tif	egv_454 ----
kokiarpuse=ifel(simple_landscape==640,1,0)
i2e_rez=egvtools::input2egv(input=kokiarpuse,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_TreesOutsideForests_cell.tif",
                            layername = "egv_454",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(kokiarpuse)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_TreesOutsideForests_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_454.png")
```


## General_TreesOutsideForests_r500	{#ch06.455}

**filename:** `General_TreesOutsideForests_r500.tif`	

**layername:** `egv_455`	

**English name:** Fractional cover of Tree covered areas Outside Forests within the 0.5 km landscape	

**Latvian name:** Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.454) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif"),
  layer_prefixes = c("General_TreesOutsideForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_TreesOutsideForests_r500.tif	egv_455
slanis=rast("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r500.tif")
names(slanis)="egv_455"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_TreesOutsideForests_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_455.png")
```


## General_TreesOutsideForests_r1250	{#ch06.456}

**filename:** `General_TreesOutsideForests_r1250.tif`	

**layername:** `egv_456`	

**English name:** Fractional cover of Tree covered areas Outside Forests within the 1.25 km landscape	

**Latvian name:** Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.454) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif"),
  layer_prefixes = c("General_TreesOutsideForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_TreesOutsideForests_r1250.tif	egv_456
slanis=rast("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r1250.tif")
names(slanis)="egv_456"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_TreesOutsideForests_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_456.png")
```


## General_TreesOutsideForests_r3000	{#ch06.457}

**filename:** `General_TreesOutsideForests_r3000.tif`	

**layername:** `egv_457`	

**English name:** Fractional cover of Tree covered areas Outside Forests within the 3 km landscape	

**Latvian name:** Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.454) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif"),
  layer_prefixes = c("General_TreesOutsideForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_TreesOutsideForests_r3000.tif	egv_457
slanis=rast("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r3000.tif")
names(slanis)="egv_457"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_TreesOutsideForests_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_457.png")
```


## General_TreesOutsideForests_r10000	{#ch06.458}

**filename:** `General_TreesOutsideForests_r10000.tif`	

**layername:** `egv_458`	

**English name:** Fractional cover of Tree covered areas Outside Forests within the 10 km landscape	

**Latvian name:** Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.454) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif"),
  layer_prefixes = c("General_TreesOutsideForests"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_TreesOutsideForests_r10000.tif	egv_458
slanis=rast("./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r10000.tif")
names(slanis)="egv_458"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_TreesOutsideForests_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_458.png")
```


## General_Water_cell	{#ch06.459}

**filename:** `General_Water_cell.tif`	

**layername:** `egv_459`	

**English name:** Fractional cover of Waterbodies within the analysis cell (1 ha)	

**Latvian name:** Ūdenstilpju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, water from [Landscape classification](#Ch05.03) were selected (values equal to 200 were reclassified to
value 1, others as 0). Then the layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# General_Water_cell.tif	egv_459 ----
udens=ifel(simple_landscape==200,1,0)
i2e_rez=egvtools::input2egv(input=udens,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "General_Water_cell.tif",
                            layername = "egv_459",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(udens)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Water_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_459.png")
```


## General_Water_r500	{#ch06.460}

**filename:** `General_Water_r500.tif`	

**layername:** `egv_460`	

**English name:** Fractional cover of Waterbodies within the 0.5 km landscape	

**Latvian name:** Ūdenstilpju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.459) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Water_cell.tif"),
  layer_prefixes = c("General_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Water_r500.tif	egv_460
slanis=rast("./RasterGrids_100m/2024/RAW/General_Water_r500.tif")
names(slanis)="egv_460"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Water_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Water_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_460.png")
```


## General_Water_r1250	{#ch06.461}

**filename:** `General_Water_r1250.tif`	

**layername:** `egv_461`	

**English name:** Fractional cover of Waterbodies within the 1.25 km landscape	

**Latvian name:** Ūdenstilpju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.459) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Water_cell.tif"),
  layer_prefixes = c("General_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Water_r1250.tif	egv_461
slanis=rast("./RasterGrids_100m/2024/RAW/General_Water_r1250.tif")
names(slanis)="egv_461"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Water_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Water_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_461.png")
```


## General_Water_r3000	{#ch06.462}

**filename:** `General_Water_r3000.tif`	

**layername:** `egv_462`	

**English name:** Fractional cover of Waterbodies within the 3 km landscape	

**Latvian name:** Ūdenstilpju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.459) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Water_cell.tif"),
  layer_prefixes = c("General_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Water_r3000.tif	egv_462
slanis=rast("./RasterGrids_100m/2024/RAW/General_Water_r3000.tif")
names(slanis)="egv_462"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Water_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Water_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_462.png")
```


## General_Water_r10000	{#ch06.463}

**filename:** `General_Water_r10000.tif`	

**layername:** `egv_463`	

**English name:** Fractional cover of Waterbodies within the 10 km landscape	

**Latvian name:** Ūdenstilpju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.459) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/General_Water_cell.tif"),
  layer_prefixes = c("General_Water"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 6,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 40 * 1024^3)


# General_Water_r10000.tif	egv_463
slanis=rast("./RasterGrids_100m/2024/RAW/General_Water_r10000.tif")
names(slanis)="egv_463"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/General_Water_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="General_Water_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_463.png")
```


## Wetlands_Bogs_cell	{#ch06.464}

**filename:** `Wetlands_Bogs_cell.tif`	

**layername:** `egv_464`	

**English name:** Fractional cover of Raised Bogs within the analysis cell (1 ha)	

**Latvian name:** Augsto purvu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Bogs and Mires: EDI](#Ch04.17), where bogs were 
classified as 1 with 0 elsewhere. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# template ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# Wetlands_Bogs_cell.tif	egv_464 ----
bogs=rast("./RasterGrids_10m/2024/EDI_BogsYN.tif")
i2e_rez=egvtools::input2egv(input=bogs,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "Wetlands_Bogs_cell.tif",
                            layername = "egv_464",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(bogs)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Bogs_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_464.png")
```


## Wetlands_Bogs_r500	{#ch06.465}

**filename:** `Wetlands_Bogs_r500.tif`	

**layername:** `egv_465`	

**English name:** Fractional cover of Raised Bogs within the 0.5 km landscape	

**Latvian name:** Augsto purvu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.464) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif"),
  layer_prefixes = c("Wetlands_Bogs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Bogs_r500.tif	egv_465
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r500.tif")
names(slanis)="egv_465"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Bogs_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_465.png")
```


## Wetlands_Bogs_r1250	{#ch06.466}

**filename:** `Wetlands_Bogs_r1250.tif`	

**layername:** `egv_466`	

**English name:** Fractional cover of Raised Bogs within the 1.25 km landscape	

**Latvian name:** Augsto purvu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.464) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif"),
  layer_prefixes = c("Wetlands_Bogs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Bogs_r1250.tif	egv_466
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r1250.tif")
names(slanis)="egv_466"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Bogs_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_466.png")
```


## Wetlands_Bogs_r3000	{#ch06.467}

**filename:** `Wetlands_Bogs_r3000.tif`	

**layername:** `egv_467`	

**English name:** Fractional cover of Raised Bogs within the 3 km landscape	

**Latvian name:** Augsto purvu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.464) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif"),
  layer_prefixes = c("Wetlands_Bogs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Bogs_r3000.tif	egv_467
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r3000.tif")
names(slanis)="egv_467"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Bogs_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_467.png")
```


## Wetlands_Bogs_r10000	{#ch06.468}

**filename:** `Wetlands_Bogs_r10000.tif`	

**layername:** `egv_468`	

**English name:** Fractional cover of Raised Bogs within the 10 km landscape	

**Latvian name:** Augsto purvu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.464) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif"),
  layer_prefixes = c("Wetlands_Bogs"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Bogs_r10000.tif	egv_468
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r10000.tif")
names(slanis)="egv_468"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Bogs_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_468.png")
```


## Wetlands_Mires_cell	{#ch06.469}

**filename:** `Wetlands_Mires_cell.tif`	

**layername:** `egv_469`	

**English name:** Fractional cover of Transitional Mires within the analysis cell (1 ha)	

**Latvian name:** Pārejas purvu platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Bogs and Mires: EDI](#Ch04.17), where transitional mires were 
classified as 1 with 0 elsewhere. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}

# template ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# Wetlands_Mires_cell.tif	egv_469 ----
mires=rast("./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif")
i2e_rez=egvtools::input2egv(input=mires,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "Wetlands_Mires_cell.tif",
                            layername = "egv_469",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(mires)
rm(i2e_rez)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Mires_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_469.png")
```


## Wetlands_Mires_r500	{#ch06.470}

**filename:** `Wetlands_Mires_r500.tif`	

**layername:** `egv_470`	

**English name:** Fractional cover of Transitional Mires within the 0.5 km landscape	

**Latvian name:** Pārejas purvu platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.469) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif"),
  layer_prefixes = c("Wetlands_Mires"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Mires_r500.tif	egv_470
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Mires_r500.tif")
names(slanis)="egv_470"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Mires_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Mires_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_470.png")
```


## Wetlands_Mires_r1250	{#ch06.471}

**filename:** `Wetlands_Mires_r1250.tif`	

**layername:** `egv_471`	

**English name:** Fractional cover of Transitional Mires within the 1.25 km landscape	

**Latvian name:** Pārejas purvu platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.469) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif"),
  layer_prefixes = c("Wetlands_Mires"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Mires_r1250.tif	egv_471
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Mires_r1250.tif")
names(slanis)="egv_471"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Mires_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Mires_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_471.png")
```


## Wetlands_Mires_r3000	{#ch06.472}

**filename:** `Wetlands_Mires_r3000.tif`	

**layername:** `egv_472`	

**English name:** Fractional cover of Transitional Mires within the 3 km landscape	

**Latvian name:** Pārejas purvu platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.469) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif"),
  layer_prefixes = c("Wetlands_Mires"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Mires_r3000.tif	egv_472
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Mires_r3000.tif")
names(slanis)="egv_472"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Mires_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Mires_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_472.png")
```


## Wetlands_Mires_r10000	{#ch06.473}

**filename:** `Wetlands_Mires_r10000.tif`	

**layername:** `egv_473`	

**English name:** Fractional cover of Transitional Mires within the 10 km landscape	

**Latvian name:** Pārejas purvu platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.469) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif"),
  layer_prefixes = c("Wetlands_Mires"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_Mires_r10000.tif	egv_473
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_Mires_r10000.tif")
names(slanis)="egv_473"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_Mires_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_Mires_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_473.png")
```


## Wetlands_ReedSedgeRushBeds_cell	{#ch06.474}

**filename:** `Wetlands_ReedSedgeRushBeds_cell.tif`	

**layername:** `egv_474`	

**English name:** Fractional cover of Reed-, Sedge-, Rush-, Beds within the analysis cell (1 ha)	

**Latvian name:** Niedrāju, grīslāju, meldrāju platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** First, reed, sedge and rush beds from [Landscape classification](#Ch05.03) were selected (value 720 reclassified to
value 1, others as 0). 
Once reclassified, layer was aggregated to EGV resolution with `egvtools::input2egv()` 
by calculating arithmetic mean, thus resulting in cover fraction. 
During aggregation, inverse distance weighted (power = 2) gap filling on the 
output was initialized to ensure no missing values at the edges. At 
the very end, layer was standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(sf)) {install.packages("sf"); require(sf)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}
if(!require(sfarrow)) {install.packages("sfarrow"); require(sfarrow)}
if(!require(readxl)) {install.packages("readxl"); require(readxl)}
if(!require(raster)) {install.packages("raster"); require(raster)}
if(!require(fasterize)) {install.packages("fasterize"); require(fasterize)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
rastrs10=raster(template10)

nulls10=rast("./Templates/TemplateRasters/nulls_LV10m_10km.tif")
nulls100=rast("./Templates/TemplateRasters/nulls_LV100m_10km.tif")

# kodi ----
kodi=read_excel("./Geodata/2024/LAD/KulturuKodi_2024.xlsx")
kodi$kods=as.character(kodi$kods)
# LAD ----
lad=sfarrow::st_read_parquet("./Geodata/2024/LAD/Lauki_2024.parquet")
lad$yes=1
lad=lad %>% 
  left_join(kodi,by=c("PRODUCT_CODE"="kods"))

# simple landscape ----
simple_landscape=rast("RasterGrids_10m/2024/Ainava_vienk_mask.tif")


# Wetlands_ReedSedgeRushBeds_cell.tif	egv_474 ----
reedsedgerush=ifel(simple_landscape==720,1,0)

i2e_rez=egvtools::input2egv(input=reedsedgerush,
                            egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                            summary_function = "average",
                            missing_job = "FillOutput",
                            outlocation = "./RasterGrids_100m/2024/RAW/",
                            outfilename = "Wetlands_ReedSedgeRushBeds_cell.tif",
                            layername = "egv_474",
                            idw_weight = 2,
                            plot_gaps = FALSE,plot_final = TRUE)
i2e_rez
rm(reedsedgerush)
rm(i2e_rez)
rm(simple_landscape)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_ReedSedgeRushBeds_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)

```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_474.png")
```


## Wetlands_ReedSedgeRushBeds_r500	{#ch06.475}

**filename:** `Wetlands_ReedSedgeRushBeds_r500.tif`	

**layername:** `egv_475`	

**English name:** Fractional cover of Reed-, Sedge-, Rush-, Beds within the 0.5 km landscape	

**Latvian name:** Niedrāju, grīslāju, meldrāju platības īpatsvars 0,5 km ainavā

**Procedure:** Cover fraction at 500 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.474) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif"),
  layer_prefixes = c("Wetlands_ReedSedgeRushBeds"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_ReedSedgeRushBeds_r500.tif	egv_475
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r500.tif")
names(slanis)="egv_475"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_ReedSedgeRushBeds_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_475.png")
```


## Wetlands_ReedSedgeRushBeds_r1250	{#ch06.476}

**filename:** `Wetlands_ReedSedgeRushBeds_r1250.tif`	

**layername:** `egv_476`	

**English name:** Fractional cover of Reed-, Sedge-, Rush-, Beds within the 1.25 km landscape	

**Latvian name:** Niedrāju, grīslāju, meldrāju platības īpatsvars 1,25 km ainavā

**Procedure:** Cover fraction at 1250 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.474) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif"),
  layer_prefixes = c("Wetlands_ReedSedgeRushBeds"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_ReedSedgeRushBeds_r1250.tif	egv_476
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r1250.tif")
names(slanis)="egv_476"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_ReedSedgeRushBeds_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_476.png")
```


## Wetlands_ReedSedgeRushBeds_r3000	{#ch06.477}

**filename:** `Wetlands_ReedSedgeRushBeds_r3000.tif`	

**layername:** `egv_477`	

**English name:** Fractional cover of Reed-, Sedge-, Rush-, Beds within the 3 km landscape	

**Latvian name:** Niedrāju, grīslāju, meldrāju platības īpatsvars 3 km ainavā

**Procedure:** Cover fraction at 3000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.474) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif"),
  layer_prefixes = c("Wetlands_ReedSedgeRushBeds"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_ReedSedgeRushBeds_r3000.tif	egv_477
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r3000.tif")
names(slanis)="egv_477"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_ReedSedgeRushBeds_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_477.png")
```


## Wetlands_ReedSedgeRushBeds_r10000	{#ch06.478}

**filename:** `Wetlands_ReedSedgeRushBeds_r10000.tif`	

**layername:** `egv_478`	

**English name:** Fractional cover of Reed-, Sedge-, Rush-, Beds within the 10 km landscape	

**Latvian name:** Niedrāju, grīslāju, meldrāju platības īpatsvars 10 km ainavā

**Procedure:** Cover fraction at 10000 m radius around the analysis grid cell, was 
calculated as the area-weighted sum of [analysis cells](#ch06.474) inside the 
buffer with `egvtools::radius_function`. During calculation of landscape metric, 
inverse distance weighted (power = 2) gap filling on the output is initialized 
to ensure no missing values at the edges. Finally, layer is rewritten to ensure 
layers name. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# Libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# Templates -----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# radii ----
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif"),
  layer_prefixes = c("Wetlands_ReedSedgeRushBeds"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 12,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 20 * 1024^3)


# Wetlands_ReedSedgeRushBeds_r10000.tif	egv_478
slanis=rast("./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r10000.tif")
names(slanis)="egv_478"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Wetlands_ReedSedgeRushBeds_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_478.png")
```


## EO_NDMI-LYmed-average_cell	{#ch06.479}

**filename:** `EO_NDMI-LYmed-average_cell.tif`	

**layername:** `egv_479`	

**English name:** Median vegetation water content (NDMI) for the last year within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējā gada ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDMI-LYmed-average_cell.tif ----
egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDMI-LYmed-average_cell.tif",
                 layername = "egv_479",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-LYmed-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_479.png")
```


## EO_NDMI-LYmedian-iqr_cell	{#ch06.480}

**filename:** `EO_NDMI-LYmedian-iqr_cell.tif`	

**layername:** `egv_480`	

**English name:** Spatial variability of last year's median vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējā gada mediānajai ūdens saturam veģetācijā indeksa (NDMI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:**  Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDMI-LYmedian-iqr_cell.tif ----

p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_480",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_480",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDMI-LYmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-LYmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_480.png")
```


## EO_NDMI-STiqr-median_cell	{#ch06.481}

**filename:** `EO_NDMI-STiqr-median_cell.tif`	

**layername:** `egv_481`	

**English name:** Average short-term seasonality of vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Sezonalitāte pēdējo piecu gadu vidējam ūdens satura veģetācijā indeksa (NDMI) vērtībai, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDMI-STiqr-median_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STiqr.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDMI-STiqr-median_cell.tif",
                 layername = "egv_481",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-STiqr-median_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_481.png")
```


## EO_NDMI-STmedian-average_cell	{#ch06.482}

**filename:** `EO_NDMI-STmedian-average_cell.tif`	

**layername:** `egv_482`	

**English name:** Median short-term vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDMI-STmedian-average_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDMI-STmedian-average_cell.tif",
                 layername = "egv_482",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-STmedian-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_482.png")
```


## EO_NDMI-STmedian-iqr_cell	{#ch06.483}

**filename:** `EO_NDMI-STmedian-iqr_cell.tif`	

**layername:** `egv_483`	

**English name:** Spatial variability of short-term median vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējo piecu gadu mediānajai ūdens saturam veģetācijā indeksa (NDMI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term corresponds 
to last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDMI-STmedian-iqr_cell.tif ----


p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_483",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_483",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDMI-STmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-STmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_483.png")
```


## EO_NDMI-STp25-min_cell	{#ch06.484}

**filename:** `EO_NDMI-STp25-min_cell.tif`	

**layername:** `egv_484`	

**English name:** Minimum short-term 25th percentile of vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Minimālā 25. procentiles pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Minimum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDMI-STp25-min_cell.tif ----


egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STp25.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDMI-STp25-min_cell.tif",
                 layername = "egv_484",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-STp25-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_484.png")
```


## EO_NDMI-STp75-max_cell	{#ch06.485}

**filename:** `EO_NDMI-STp75-max_cell.tif`	

**layername:** `egv_485`	

**English name:** Maximum short-term 75th percentile of vegetation water content (NDMI) within the analysis cell (1 ha)	

**Latvian name:** Maksimālā 75. procentiles pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Maximum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDMI-STp75-max_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDMI-STp75.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDMI-STp75-max_cell.tif",
                 layername = "egv_485",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDMI-STp75-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_485.png")
```


## EO_NDVI-LYmedian-average_cell	{#ch06.486}

**filename:** `EO_NDVI-LYmedian-average_cell.tif`	

**layername:** `egv_486`	

**English name:** Median vegetation index (NDVI) for the last year within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējā gada veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDVI-LYmedian-average_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDVI-LYmedian-average_cell.tif",
                 layername = "egv_486",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-LYmedian-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_486.png")
```


## EO_NDVI-LYmedian-iqr_cell	{#ch06.487}

**filename:** `EO_NDVI-LYmedian-iqr_cell.tif`	

**layername:** `egv_487`	

**English name:** Spatial variability of last year's median vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējā gada mediānajai veģetācijas indeksa (NDVI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:**  Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDVI-LYmedian-iqr_cell.tif ----


p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_487",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_487",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDVI-LYmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-LYmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_487.png")
```


## EO_NDVI-STiqr-median_cell	{#ch06.488}

**filename:** `EO_NDVI-STiqr-median_cell.tif`	

**layername:** `egv_488`	

**English name:** Average short-term seasonality of vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Sezonalitāte pēdējo piecu gadu vidējam veģetācijas indeksa (NDVI) vērtībai, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDVI-STiqr-median_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STiqr.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDVI-STiqr-median_cell.tif",
                 layername = "egv_488",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-STiqr-median_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_488.png")
```


## EO_NDVI-STmedian-average_cell	{#ch06.489}

**filename:** `EO_NDVI-STmedian-average_cell.tif`	

**layername:** `egv_489`	

**English name:** Median short-term vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDVI-STmedian-average_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDVI-STmedian-average_cell.tif",
                 layername = "egv_489",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-STmedian-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_489.png")
```


## EO_NDVI-STmedian-iqr_cell	{#ch06.490}

**filename:** `EO_NDVI-STmedian-iqr_cell.tif`	

**layername:** `egv_490`	

**English name:** Spatial variability of short-term median vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējo piecu gadu mediānajai veģetācijas indeksa (NDVI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term corresponds 
to last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDVI-STmedian-iqr_cell.tif ----


p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_490",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_490",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDVI-STmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-STmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_490.png")
```


## EO_NDVI-STp25-min_cell	{#ch06.491}

**filename:** `EO_NDVI-STp25-min_cell.tif`	

**layername:** `egv_491`	

**English name:** Minimum short-term 25th percentile of vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Minimālā 25. procentiles pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Minimum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDVI-STp25-min_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STp25.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDVI-STp25-min_cell.tif",
                 layername = "egv_491",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-STp25-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_491.png")
```


## EO_NDVI-STp75-max_cell	{#ch06.492}

**filename:** `EO_NDVI-STp75-max_cell.tif`	

**layername:** `egv_492`	

**English name:** Maximum short-term 75th percentile of vegetation index (NDVI) within the analysis cell (1 ha)	

**Latvian name:** Maksimālā 75. procentiles pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Maximum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDVI-STp75-max_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDVI-STp75.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDVI-STp75-max_cell.tif",
                 layername = "egv_492",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDVI-STp75-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_492.png")
```


## EO_NDWI-LYmedian-average_cell	{#ch06.493}

**filename:** `EO_NDWI-LYmedian-average_cell.tif`	

**layername:** `egv_493`	

**English name:** Median water index (NDWI) for the last year within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējā gada ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDWI-LYmedian-average_cell.tif",
                 layername = "egv_493",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-LYmedian-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_493.png")
```


## EO_NDWI-LYmedian-iqr_cell	{#ch06.494}

**filename:** `EO_NDWI-LYmedian-iqr_cell.tif`	

**layername:** `egv_494`	

**English name:** Spatial variability of last year's median water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējā gada mediānajai ūdens indeksa (NDWI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Last year is 2024.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDWI-LYmedian-iqr_cell.tif ----


p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_494",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_494",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDWI-LYmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-LYmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_494.png")
```


## EO_NDWI-STiqr-median_cell	{#ch06.495}

**filename:** `EO_NDWI-STiqr-median_cell.tif`	

**layername:** `egv_495`	

**English name:** Average short-term seasonality of water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Sezonalitāte pēdējo piecu gadu vidējam ūdens indeksa (NDWI) vērtībai, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDWI-STiqr-median_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STiqr.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDWI-STiqr-median_cell.tif",
                 layername = "egv_495",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-STiqr-median_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_495.png")
```


## EO_NDWI-STmedian-average_cell	{#ch06.496}

**filename:** `EO_NDWI-STmedian-average_cell.tif`	

**layername:** `egv_496`	

**English name:** Median short-term water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Mediānā pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Arithmetic mean value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDWI-STmedian-average_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "average",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDWI-STmedian-average_cell.tif",
                 layername = "egv_496",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-STmedian-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_496.png")
```


## EO_NDWI-STmedian-iqr_cell	{#ch06.497}

**filename:** `EO_NDWI-STmedian-iqr_cell.tif`	

**layername:** `egv_497`	

**English name:** Spatial variability of short-term median water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Telpiskā variabilitāte pēdējo piecu gadu mediānajai ūdens indeksa (NDWI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term corresponds 
to last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDWI-STmedian-iqr_cell.tif ----

p25rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_497",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_497",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/EO_NDWI-STmedian-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-STmedian-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_497.png")
```


## EO_NDWI-STp25-min_cell	{#ch06.498}

**filename:** `EO_NDWI-STp25-min_cell.tif`	

**layername:** `egv_498`	

**English name:** Minimum short-term 25th percentile of water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Minimālā 25. procentiles pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Minimum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EO_NDWI-STp25-min_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STp25.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDWI-STp25-min_cell.tif",
                 layername = "egv_498",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-STp25-min_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_498.png")
```


## EO_NDWI-STp75-max_cell	{#ch06.499}

**filename:** `EO_NDWI-STp75-max_cell.tif`	

**layername:** `egv_499`	

**English name:** Maximum short-term 75th percentile of water index (NDWI) within the analysis cell (1 ha)	

**Latvian name:** Maksimālā 75. procentiles pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha)

**Procedure:** Directly follows [preprocessing](#Ch04.13). Maximum value at analysis cell 
calculated with `egvtools::input2egv()`. To protect against possible data loss at edge cells, 
inverse distance weighted (power = 2) gap filling is implemented. Short-term is last five years (2020-2024).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# EO_NDWI-STp75-max_cell.tif ----

egvrez=input2egv(input="./Geodata/2024/S2indices/Mosaics/EO_NDWI-STp75.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "min",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/RAW/",
                 outfilename = "EO_NDWI-STp75-max_cell.tif",
                 layername = "egv_499",
                 idw_weight = 2,
                 plot_gaps = FALSE,
                 plot_final = FALSE)
egvrez

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="EO_NDWI-STp75-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_499.png")
```


## SoilChemistry_ESDAC-CN_cell	{#ch06.500}

**filename:** `SoilChemistry_ESDAC-CN_cell.tif`	

**layername:** `egv_500`	

**English name:** Average value of Topsoil Carbon-Nitrogen ratio (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas oglekļa-slāpekļa attiecība (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# CN ----

egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/CN/CN.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-CN_cell.tif",
  layer_name    = "egv_500",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-CN_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_500.png")
```


## SoilChemistry_ESDAC-CaCo3_cell	{#ch06.501}

**filename:** `SoilChemistry_ESDAC-CaCo3_cell.tif`	

**layername:** `egv_501`	

**English name:** Average value of Topsoil Calcium Carbonates Content (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas kalcija karbonātu apjoms (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# CaCO3 ----


egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/Caco3/CaCO3.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-CaCo3_cell.tif",
  layer_name    = "egv_501",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-CaCo3_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_501.png")
```


## SoilChemistry_ESDAC-K_cell	{#ch06.502}

**filename:** `SoilChemistry_ESDAC-K_cell.tif`	

**layername:** `egv_502`	

**English name:** Average value of Topsoil Sodium Content (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas kālija apjoms (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# K ----

egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/K/K.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-K_cell.tif",
  layer_name    = "egv_502",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-K_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_502.png")
```


## SoilChemistry_ESDAC-N_cell	{#ch06.503}

**filename:** `SoilChemistry_ESDAC-N_cell.tif`	

**layername:** `egv_503`	

**English name:** Average value of Topsoil Nitrogen Content (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas slāpekļa apjoms (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# N ----

egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/N/N.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-N_cell.tif",
  layer_name    = "egv_503",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-N_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_503.png")
```


## SoilChemistry_ESDAC-P_cell	{#ch06.504}

**filename:** `SoilChemistry_ESDAC-P_cell.tif`	

**layername:** `egv_504`	

**English name:** Average value of Topsoil Phosphorous Content (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas fosfora apjoms (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# P ----

egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/P/P.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-P_cell.tif",
  layer_name    = "egv_504",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-P_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_504.png")
```


## SoilChemistry_ESDAC-phH2O_cell	{#ch06.505}

**filename:** `SoilChemistry_ESDAC-phH2O_cell.tif`	

**layername:** `egv_505`	

**English name:** Average value of Topsoil pH reaction in water (ESDAC v2.0) within the analysis cell (1 ha)	

**Latvian name:** Augsnes virskārtas reakcija (pH) ūdens šķīdumā (ESDAC v2.0) analīzes šūnā (1 ha)

**Procedure:** Directly derived from [Soil chemistry](#Ch04.07.01). Processed 
with `egvtools::downscale2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border and `smooth = FALSE` 
to keep as original values as reasonable (there is bilinear interpolation 
involved when projecting from 500 m to 100 m resolution of different CRS).

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.

```{r,eval=FALSE}
# libs ----
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}


# pH_H2O ----

egv=downscale2egv(
  template_path = "./Templates/TemplateRasters/LV100m_10km.tif",
  grid_path     = "./Templates/TemplateGrids/tikls1km_sauzeme.parquet",
  rawfile_path  = "./Geodata/2024/Soils/ESDAC/chemistry/chemistry/pH_H2O/pH_H2O.tif",
  out_path      = "./RasterGrids_100m/2024/RAW/",
  file_name     = "SoilChemistry_ESDAC-phH2O_cell.tif",
  layer_name    = "egv_505",
  fill_gaps     = TRUE,
  smooth        = FALSE,
  plot_result   = TRUE)
egv

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilChemistry_ESDAC-phH2O_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_505.png")
```


## SoilTexture_Clay_cell	{#ch06.506}

**filename:** `SoilTexture_Clay_cell.tif`	

**layername:** `egv_506`	

**English name:** Fractional cover of Clay Soils within the analysis cell (1 ha)	

**Latvian name:** Augsnes granulometriskās klases "māls" platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Soil texture product](#Ch05.02). First, layer is 
reclassified so that class of interest is 1, other classes are 0. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# input ----
combtext=rast("./RasterGrids_10m/2024/SoilTXT_combined.tif")

# EGVs cell ----

# SoilTexture_Clay_cell.tif	egv_506

clay10=ifel(combtext==3,1,0)

input2egv(input=clay10,
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "SoilTexture_Clay_cell.tif",
          layername="egv_506",
          return_visible = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Clay_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_506.png")
```


## SoilTexture_Clay_r500	{#ch06.507}

**filename:** `SoilTexture_Clay_r500.tif`	

**layername:** `egv_507`	

**English name:** Fractional cover of Clay Soils within the 0.5 km landscape	

**Latvian name:** Augsnes granulometriskās klases "māls" platības īpatsvars 0,5 km ainavā

**Procedure:** Derived from [SoilTexture_Clay_cell](#ch06.506). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif"),
  layer_prefixes = c("SoilTexture_Clay"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Clay_r500.tif	egv_507

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r500.tif")
names(slanis)="egv_507"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Clay_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_507.png")
```


## SoilTexture_Clay_r1250	{#ch06.508}

**filename:** `SoilTexture_Clay_r1250.tif`	

**layername:** `egv_508`	

**English name:** Fractional cover of Clay Soils within the 1.25 km landscape	

**Latvian name:** Augsnes granulometriskās klases "māls" platības īpatsvars 1,25 km ainavā

**Procedure:** Derived from [SoilTexture_Clay_cell](#ch06.506). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif"),
  layer_prefixes = c("SoilTexture_Clay"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# SoilTexture_Clay_r1250.tif	egv_508

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r1250.tif")
names(slanis)="egv_508"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Clay_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_508.png")
```


## SoilTexture_Clay_r3000	{#ch06.509}

**filename:** `SoilTexture_Clay_r3000.tif`	

**layername:** `egv_509`	

**English name:** Fractional cover of Clay Soils within the 3 km landscape	

**Latvian name:** Augsnes granulometriskās klases "māls" platības īpatsvars 3 km ainavā

**Procedure:** Derived from [SoilTexture_Clay_cell](#ch06.506). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif"),
  layer_prefixes = c("SoilTexture_Clay"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Clay_r3000.tif	egv_509

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r3000.tif")
names(slanis)="egv_509"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Clay_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_509.png")
```


## SoilTexture_Clay_r10000	{#ch06.510}

**filename:** `SoilTexture_Clay_r10000.tif`	

**layername:** `egv_510`	

**English name:** Fractional cover of Clay Soils within the 10 km landscape	

**Latvian name:** Augsnes granulometriskās klases "māls" platības īpatsvars 10 km ainavā

**Procedure:** Derived from [SoilTexture_Clay_cell](#ch06.506). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif"),
  layer_prefixes = c("SoilTexture_Clay"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# SoilTexture_Clay_r10000.tif	egv_510

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r10000.tif")
names(slanis)="egv_510"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Clay_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_510.png")
```


## SoilTexture_Organic_cell	{#ch06.511}

**filename:** `SoilTexture_Organic_cell.tif`	

**layername:** `egv_511`	

**English name:** Fractional cover of Organic Soils within the analysis cell (1 ha)	

**Latvian name:** Augsnes granulometriskās klases "organiskās augsnes" platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Soil texture product](#Ch05.02). First, layer is 
reclassified so that class of interest is 1, other classes are 0. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border.

At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# input ----
combtext=rast("./RasterGrids_10m/2024/SoilTXT_combined.tif")

# EGVs cell ----

# SoilTexture_Organic_cell.tif	egv_511

org10=ifel(combtext==4,1,0)

input2egv(input=org10,
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "SoilTexture_Organic_cell.tif",
          layername="egv_511",
          return_visible = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Organic_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_511.png")
```


## SoilTexture_Organic_r500	{#ch06.512}

**filename:** `SoilTexture_Organic_r500.tif`	

**layername:** `egv_512`	

**English name:** Fractional cover of Organic Soils within the 0.5 km landscape	

**Latvian name:** Augsnes granulometriskās klases "organiskās augsnes" platības īpatsvars 0,5 km ainavā

**Procedure:** Derived from [SoilTexture_Organic_cell](#ch06.511). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif"),
  layer_prefixes = c("SoilTexture_Organic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Organic_r500.tif	egv_512

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r500.tif")
names(slanis)="egv_512"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Organic_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_512.png")
```


## SoilTexture_Organic_r1250	{#ch06.513}

**filename:** `SoilTexture_Organic_r1250.tif`	

**layername:** `egv_513`	

**English name:** Fractional cover of Organic Soils within the 1.25 km landscape	

**Latvian name:** Augsnes granulometriskās klases "organiskās augsnes" platības īpatsvars 1,25 km ainavā

**Procedure:** Derived from [SoilTexture_Organic_cell](#ch06.511). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif"),
  layer_prefixes = c("SoilTexture_Organic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# SoilTexture_Organic_r1250.tif	egv_513

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r1250.tif")
names(slanis)="egv_513"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Organic_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_513.png")
```


## SoilTexture_Organic_r3000	{#ch06.514}

**filename:** `SoilTexture_Organic_r3000.tif`	

**layername:** `egv_514`	

**English name:** Fractional cover of Organic Soils within the 3 km landscape	

**Latvian name:** Augsnes granulometriskās klases "organiskās augsnes" platības īpatsvars 3 km ainavā

**Procedure:** Derived from [SoilTexture_Organic_cell](#ch06.511). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif"),
  layer_prefixes = c("SoilTexture_Organic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Organic_r3000.tif	egv_514

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r3000.tif")
names(slanis)="egv_514"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Organic_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_514.png")
```


## SoilTexture_Organic_r10000	{#ch06.515}

**filename:** `SoilTexture_Organic_r10000.tif`	

**layername:** `egv_515`	

**English name:** Fractional cover of Organic Soils within the 10 km landscape	

**Latvian name:** Augsnes granulometriskās klases "organiskās augsnes" platības īpatsvars 10 km ainavā

**Procedure:** Derived from [SoilTexture_Organic_cell](#ch06.511). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif"),
  layer_prefixes = c("SoilTexture_Organic"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Organic_r10000.tif	egv_515

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r10000.tif")
names(slanis)="egv_515"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Organic_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_515.png")
```


## SoilTexture_Sand_cell	{#ch06.516}

**filename:** `SoilTexture_Sand_cell.tif`	

**layername:** `egv_516`	

**English name:** Fractional cover of Sand Soils within the analysis cell (1 ha)	

**Latvian name:** Augsnes granulometriskās klases "smilts" platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Soil texture product](#Ch05.02). First, layer is 
reclassified so that class of interest is 1, other classes are 0. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# input ----
combtext=rast("./RasterGrids_10m/2024/SoilTXT_combined.tif")

# EGVs cell ----

# SoilTexture_Sand_cell.tif	egv_516

sand10=ifel(combtext==1,1,0)
plot(sand10)

input2egv(input=sand10,
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "SoilTexture_Sand_cell.tif",
          layername="egv_516",
          return_visible = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Sand_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_516.png")
```


## SoilTexture_Sand_r500	{#ch06.517}

**filename:** `SoilTexture_Sand_r500.tif`	

**layername:** `egv_517`	

**English name:** Fractional cover of Sand Soils within the 0.5 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilts" platības īpatsvars 0,5 km ainavā

**Procedure:** Derived from [SoilTexture_Sand_cell](#ch06.516). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif"),
  layer_prefixes = c("SoilTexture_Sand"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Sand_r500.tif	egv_517

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r500.tif")
names(slanis)="egv_517"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Sand_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_517.png")
```


## SoilTexture_Sand_r1250	{#ch06.518}

**filename:** `SoilTexture_Sand_r1250.tif`	

**layername:** `egv_518`	

**English name:** Fractional cover of Sand Soils within the 1.25 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilts" platības īpatsvars 1,25 km ainavā

**Procedure:** Derived from [SoilTexture_Sand_cell](#ch06.516). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif"),
  layer_prefixes = c("SoilTexture_Sand"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Sand_r1250.tif	egv_518

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r1250.tif")
names(slanis)="egv_518"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Sand_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_518.png")
```


## SoilTexture_Sand_r3000	{#ch06.519}

**filename:** `SoilTexture_Sand_r3000.tif`	

**layername:** `egv_519`	

**English name:** Fractional cover of Sand Soils within the 3 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilts" platības īpatsvars 3 km ainavā

**Procedure:** Derived from [SoilTexture_Sand_cell](#ch06.516). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif"),
  layer_prefixes = c("SoilTexture_Sand"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Sand_r3000.tif	egv_519

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r3000.tif")
names(slanis)="egv_519"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Sand_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_519.png")
```


## SoilTexture_Sand_r10000	{#ch06.520}

**filename:** `SoilTexture_Sand_r10000.tif`	

**layername:** `egv_520`	

**English name:** Fractional cover of Sand Soils within the 10 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilts" platības īpatsvars 10 km ainavā

**Procedure:** Derived from [SoilTexture_Sand_cell](#ch06.516). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif"),
  layer_prefixes = c("SoilTexture_Sand"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Sand_r10000.tif	egv_520

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r10000.tif")
names(slanis)="egv_520"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Sand_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_520.png")
```


## SoilTexture_Silt_cell	{#ch06.521}

**filename:** `SoilTexture_Silt_cell.tif`	

**layername:** `egv_521`	

**English name:** Fractional cover of Silt Soils within the analysis cell (1 ha)	

**Latvian name:** Augsnes granulometriskās klases "smilšmāls un mālsmilts" platības īpatsvars analīzes šūnā (1 ha)

**Procedure:** Derived from [Soil texture product](#Ch05.02). First, layer is 
reclassified so that class of interest is 1, other classes are 0. Then processed 
with `egvtools::input2egv()` with `fill gaps = TRUE` performing inverse 
distance weighted (power = 2) filling of gaps at the border. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template10=rast("./Templates/TemplateRasters/LV10m_10km.tif")
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# input ----
combtext=rast("./RasterGrids_10m/2024/SoilTXT_combined.tif")

# EGVs cell ----

# SoilTexture_Silt_cell.tif	egv_521

silt10=ifel(combtext==2,1,0)

input2egv(input=silt10,
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "SoilTexture_Silt_cell.tif",
          layername="egv_521",
          return_visible = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Silt_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_521.png")
```


## SoilTexture_Silt_r500	{#ch06.522}

**filename:** `SoilTexture_Silt_r500.tif`	

**layername:** `egv_522`	

**English name:** Fractional cover of Silt Soils within the 0.5 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilšmāls un mālsmilts" platības īpatsvars 0,5 km ainavā

**Procedure:** Derived from [SoilTexture_Silt_cell](#ch06.521). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif"),
  layer_prefixes = c("SoilTexture_Silt"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Silt_r500.tif	egv_522

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r500.tif")
names(slanis)="egv_522"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Silt_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_522.png")
```


## SoilTexture_Silt_r1250	{#ch06.523}

**filename:** `SoilTexture_Silt_r1250.tif`	

**layername:** `egv_523`	

**English name:** Fractional cover of Silt Soils within the 1.25 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilšmāls un mālsmilts" platības īpatsvars 1,25 km ainavā

**Procedure:** Derived from [SoilTexture_Silt_cell](#ch06.521). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif"),
  layer_prefixes = c("SoilTexture_Silt"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Silt_r1250.tif	egv_523

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r1250.tif")
names(slanis)="egv_523"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Silt_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_523.png")
```


## SoilTexture_Silt_r3000	{#ch06.524}

**filename:** `SoilTexture_Silt_r3000.tif`	

**layername:** `egv_524`	

**English name:** Fractional cover of Silt Soils within the 3 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilšmāls un mālsmilts" platības īpatsvars 3 km ainavā

**Procedure:** Derived from [SoilTexture_Silt_cell](#ch06.521). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif"),
  layer_prefixes = c("SoilTexture_Silt"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# SoilTexture_Silt_r3000.tif	egv_524

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r3000.tif")
names(slanis)="egv_524"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Silt_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_524.png")
```


## SoilTexture_Silt_r10000	{#ch06.525}

**filename:** `SoilTexture_Silt_r10000.tif`	

**layername:** `egv_525`	

**English name:** Fractional cover of Silt Soils within the 10 km landscape	

**Latvian name:** Augsnes granulometriskās klases "smilšmāls un mālsmilts" platības īpatsvars 10 km ainavā

**Procedure:** Derived from [SoilTexture_Silt_cell](#ch06.521). First processed 
with `egvtools::radius_function()`, then rewritten to ensure layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# EGVs radii ----

radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif"),
  layer_prefixes = c("SoilTexture_Silt"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# SoilTexture_Silt_r10000.tif	egv_525

slanis=rast("./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r10000.tif")
names(slanis)="egv_525"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="SoilTexture_Silt_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_525.png")
```


## Terrain_ASL-average_cell	{#ch06.526}

**filename:** `Terrain_ASL-average_cell.tif`	

**layername:** `egv_526`	

**English name:** Average value of height Above Sea Level (m) within the analysis cell (1 ha)	

**Latvian name:** Augstums virs jūras līmeņa (m) analīzes šūnā (1 ha)

**Procedure:**  Derived from [Digital elevation/terrain models](#Ch04.15). Processed 
with `egvtools::input2egv()`. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")

# Terrain_ASL-average_cell.tif	egv_526

input2egv(input="./Geodata/2024/DEM/mozDEM_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_ASL-average_cell.tif",
          layername="egv_526",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_ASL-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_526.png")
```


## Terrain_Aspect-average_cell	{#ch06.527}

**filename:** `Terrain_Aspect-average_cell.tif`	

**layername:** `egv_527`	

**English name:** Average value of Terrain Aspect (degree) within the analysis cell (1 ha)	

**Latvian name:** Nogāzes vidējais vērsuma virziens analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.



```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_Aspect-average_cell.tif	egv_527
input2egv(input="./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_Aspect-average_cell.tif",
          layername="egv_527",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_Aspect-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_527.png")
```


## Terrain_Aspect-iqr_cell	{#ch06.528}

**filename:** `Terrain_Aspect-iqr_cell.tif`	

**layername:** `egv_528`	

**English name:** Variability of Terrain Aspect (degree) within the analysis cell (1 ha)	

**Latvian name:** Nogāzes vērsuma variabilitāte analīzes šūnā (1 ha)

**Procedure:** Derived from [Terrain products](#Ch05.01). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_Aspect-iqr_cell.tif	egv_528
p25rez=input2egv(input="./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_528",
                 idw_weight = 2)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_528",
                 idw_weight = 2)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/Terrain_Aspect-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_Aspect-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_528.png")
```


## Terrain_DiS-area_cell	{#ch06.529}

**filename:** `Terrain_DiS-area_cell.tif`	

**layername:** `egv_529`	

**English name:** Fractional cover of Terrain Sinks within the analysis cell (1 ha)	

**Latvian name:** Reljefa depresiju bez virszemes noteces platības īpatsvars analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.



```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_DiS-area_cell.tif	egv_529
dis=rast("./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif")
dis2=ifel(dis>0,1,dis)

input2egv(input=dis2,
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_DiS-area_cell.tif",
          layername="egv_529",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-area_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_529.png")
```


## Terrain_DiS-area_r500	{#ch06.530}

**filename:** `Terrain_DiS-area_r500.tif`	

**layername:** `egv_530`	

**English name:** Fractional cover of Terrain Sinks within the 0.5 km landscape	

**Latvian name:** Reljefa depresiju bez virszemes noteces platības īpatsvars 0,5 km ainavā

**Procedure:** Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::radius_function()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. After zonal statistics, file is rewritten to ensure layername. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif"),
  layer_prefixes = c("Terrain_DiS-area"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r500"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# Terrain_DiS-area_r500.tif	egv_530
slanis=rast("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r500.tif")
names(slanis)="egv_530"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r500.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-area_r500.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_530.png")
```


## Terrain_DiS-area_r1250	{#ch06.531}

**filename:** `Terrain_DiS-area_r1250.tif`	

**layername:** `egv_531`	

**English name:** Fractional cover of Terrain Sinks within the 1.25 km landscape	

**Latvian name:** Reljefa depresiju bez virszemes noteces platības īpatsvars 1,25 km ainavā

**Procedure:** Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::radius_function()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. After zonal statistics, file is rewritten to ensure layername. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif"),
  layer_prefixes = c("Terrain_DiS-area"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r1250"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)

# Terrain_DiS-area_r1250.tif	egv_531
slanis=rast("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r1250.tif")
names(slanis)="egv_531"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r1250.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-area_r1250.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_531.png")
```


## Terrain_DiS-area_r3000	{#ch06.532}

**filename:** `Terrain_DiS-area_r3000.tif`	

**layername:** `egv_532`	

**English name:** Fractional cover of Terrain Sinks within the 3 km landscape	

**Latvian name:** Reljefa depresiju bez virszemes noteces platības īpatsvars 3 km ainavā

**Procedure:** Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::radius_function()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. After zonal statistics, file is rewritten to ensure layername. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif"),
  layer_prefixes = c("Terrain_DiS-area"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r3000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# Terrain_DiS-area_r3000.tif	egv_532
slanis=rast("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r3000.tif")
names(slanis)="egv_532"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r3000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-area_r3000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_532.png")
```


## Terrain_DiS-area_r10000	{#ch06.533}

**filename:** `Terrain_DiS-area_r10000.tif`	

**layername:** `egv_533`	

**English name:** Fractional cover of Terrain Sinks within the 10 km landscape	

**Latvian name:** Reljefa depresiju bez virszemes noteces platības īpatsvars 10 km ainavā

**Procedure:** Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::radius_function()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. After zonal statistics, file is rewritten to ensure layername. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.



```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# radii
radius_function(
  kvadrati_path  = "./Templates/TemplateGrids/tiles/",
  radii_path     = "./Templates/TemplateGridPoints/tiles/",
  tikls100_path  = "./Templates/TemplateGrids/tikls100_sauzeme.parquet",
  template_path  = "./Templates/TemplateRasters/LV100m_10km.tif",
  input_layers   = c("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif"),
  layer_prefixes = c("Terrain_DiS-area"),
  output_dir     = "./RasterGrids_100m/2024/RAW/",
  n_workers      = 5,
  radii          = c("r10000"),
  radius_mode    = "sparse",
  extract_fun    = "mean",
  fill_missing   = TRUE,
  IDW_weight     = 2,
  future_max_size = 5 * 1024^3)


# Terrain_DiS-area_r10000.tif	egv_533
slanis=rast("./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r10000.tif")
names(slanis)="egv_533"
slanis2=project(slanis,template100)
writeRaster(slanis2,
            "./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r10000.tif",
            overwrite=TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-area_r10000.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_533.png")
```


## Terrain_DiS-max_cell	{#ch06.534}	

**filename:** `Terrain_DiS-max_cell.tif`	

**layername:** `egv_534`	

**English name:** Maximum Depth in Terrain Sink within the analysis cell (1 ha)	

**Latvian name:** Reljefa depresiju lielākais dziļums analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_DiS-max_cell.tif	egv_534
input2egv(input="./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "max",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_DiS-max_cell.tif",
          layername="egv_534",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-max_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_534.png")
```


## Terrain_DiS-mean_cell	{#ch06.535}	

**filename:** `Terrain_DiS-mean_cell.tif`	

**layername:** `egv_535`	

**English name:** Average Depth in Terrain Sink within the analysis cell (1 ha)	

**Latvian name:** Reljefa depresiju vidējais dziļums analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_DiS-mean_cell.tif	egv_535
input2egv(input="./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_DiS-mean_cell.tif",
          layername="egv_535",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_DiS-mean_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_535.png")
```


## Terrain_Slope-average_cell	{#ch06.536}	

**filename:** `Terrain_Slope-average_cell.tif`	

**layername:** `egv_536`	

**English name:** Average value of Terrain Slope (degree) within the analysis cell (1 ha)	

**Latvian name:** Nogāzes slīpuma vidējā vērtība analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.



```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_Slope-average_cell.tif	egv_536
input2egv(input="./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_Slope-average_cell.tif",
          layername="egv_536",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_Slope-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_536.png")
```


## Terrain_Slope-iqr_cell	{#ch06.537}	

**filename:** `Terrain_Slope-iqr_cell.tif`	

**layername:** `egv_537`	

**English name:** Variability of Terrain Slope (degree) within the analysis cell (1 ha)	

**Latvian name:** Nogāzes slīpuma variabilitāte analīzes šūnā (1 ha)

**Procedure:** Derived from [Terrain products](#Ch05.01). First Q1 and then Q3 
is calculated for every cell with `egvtools::input2egv()`. Finally, subtracting 
Q1 from Q3 and writing final raster with specified layername. To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. 
At the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.


```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_Slope-iqr_cell.tif	egv_537
p25rez=input2egv(input="./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q1",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p25.tif",
                 layername = "egv_537",
                 idw_weight = 2)
p25rez_r=rast("./RasterGrids_100m/2024/draza_p25.tif")


p75rez=input2egv(input="./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif",
                 egv_template= "./Templates/TemplateRasters/LV100m_10km.tif",
                 summary_function = "q3",
                 missing_job = "FillOutput",
                 outlocation = "./RasterGrids_100m/2024/",
                 outfilename = "draza_p75.tif",
                 layername = "egv_537",
                 idw_weight = 2)
p75rez_r=rast("./RasterGrids_100m/2024/draza_p75.tif")

iqr_rez=p75rez_r-p25rez_r
iqr_rez
plot(iqr_rez)

writeRaster(iqr_rez,
            "./RasterGrids_100m/2024/RAW/Terrain_Slope-iqr_cell.tif",
            overwrite=TRUE)

unlink("./RasterGrids_100m/2024/draza_p75.tif")
unlink("./RasterGrids_100m/2024/draza_p25.tif")

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_Slope-iqr_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_537.png")
```


## Terrain_TWI-average_cell	{#ch06.538}	

**filename:** `Terrain_TWI-average_cell.tif`	

**layername:** `egv_538`	

**English name:** Average value of Topographic Wetness Index (TWI) within the analysis cell (1 ha)	

**Latvian name:** Topogrāfiskā mitruma indeksa vidējā vērtība analīzes šūnā (1 ha)

**Procedure:**  Derived from [Terrain products](#Ch05.01). Processed 
with `egvtools::input2egv()`.  To protect against 
possible data loss at edge cells, inverse distance weighted (power = 2) gap filling 
is implemented. At 
the very end, layer is standardized by subtracting arithmetic mean and dividing 
by root mean squared error.



```{r,eval=FALSE}
# libs ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(egvtools)) {remotes::install_github("aavotins/egvtools"); require(egvtools)}

# templates ----
template100=rast("./Templates/TemplateRasters/LV100m_10km.tif")


# Terrain_TWI-average_cell.tif	egv_538
input2egv(input="./RasterGrids_10m/2024/Terrain_TWI_udeni2_10m.tif",
          egv_template="./Templates/TemplateRasters/LV100m_10km.tif",
          summary_function = "average",
          missing_job = "FillOutput",
          idw_weight = 2,
          outlocation = "./RasterGrids_100m/2024/RAW/",
          outfilename = "Terrain_TWI-average_cell.tif",
          layername="egv_538",
          return_visible = TRUE,
          plot_final = TRUE)

# standardization ----
if(!require(terra)) {install.packages("terra"); require(terra)}
if(!require(tidyverse)) {install.packages("tidyverse"); require(tidyverse)}

nosaukums="Terrain_TWI-average_cell.tif"
ielasisanas_cels=paste0("./RasterGrids_100m/2024/RAW/",nosaukums)
saglabasanas_cels=paste0("./RasterGrids_100m/2024/Scaled/",nosaukums)
slanis=rast(ielasisanas_cels)
videjais=global(slanis,fun="mean",na.rm=TRUE)
centrets=slanis-videjais[,1]
standartnovirze=terra::global(centrets,fun="rms",na.rm=TRUE)
merogots=centrets/standartnovirze[,1]
writeRaster(merogots,
            filename=saglabasanas_cels,
            overwrite=TRUE)
```

```{r, echo=FALSE, eval=TRUE, out.width = '100%'}
knitr::include_graphics("./Figures/maps4book/egv_538.png")
```

