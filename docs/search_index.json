[["index.html", "High-resolution ecogeographical variables for species distribution modelling describing Latvia, 2024 Preface About this material Outline", " High-resolution ecogeographical variables for species distribution modelling describing Latvia, 2024 Andris Avotiņš, Jekaterīna Butkeviča, Betija Rubene, Solvita Rūsiņa, Rūta Starka, Vita Šakele, Vineta Vērpēja, Ivo Vinogradovs, Marks Arnolds Župerka, Ainārs Auniņš 2025-11-25 Preface Welcome! This book documents the geodata and processing workflows used to create ecogeographical variables (EGVs) for species distribution modelling in Latvia (2024). This material presents the results of three University of Latvia projects deeply rooted in species distribution modelling and, more importantly, explains the workflow and decisions made to ensure their repeatability and reproducibility. These projects are: The project “Preparation of a geospatial data layer covering existing protected areas for the implementation of the EU Biodiversity Strategy 2030” (No. 1-08/73/2023), funded by the Administrations of the Latvian Environmental Protection Fund; Scientific research service project commissioned by the Joint Stock Company “Latvijas valsts meži” (Latvian State Forests) “Improvement of the monitoring of the northern goshawk Accipiter gentilis and creation of a spatial model of habitat suitability” (Latvian State Forests document No. 5-5.5.1_000r_101_23_27_6); State research program “Development of research specified in the Biodiversity Priority Action Program” project “High-resolution quantification of biodiversity for nature conservation and management: HiQBioDiv” (VPP-VARAM-DABA-2024/1-0002). The material was developed in R using {bookdown}. The data processing and analysis described in the content was mainly performed in R, and one of the main reasons for creating this material was to transfer the information necessary for reproducing the work using verified command lines. A desirable side effect is to promote openness and reproducibility in scientific practice and practical science. Home repository of this material: aavotins/HiQBioDiv_EGVs Cite as needed using book/book.bib. About this material This material is not: an introduction to R or other programming language. On the contrary, it will be most useful to those who already understand how to use command lines. However, it will also be informative for other users regarding the approaches used; a tutorial on geoprocessing. This material summarizes the approaches that, at the time of its development, were known to the authors as the most effective (in terms of processing time, RAM and hard disk space, performance guarantees, and reliability), but they are certainly not the only ones possible; copy/paste ready product. Although the use and publication of command lines tends to be intended for these purposes, in a situation where large amounts of data and, at least in part, restricted access data are used for the work, this is simply not possible. However, by ensuring data availability and placement in accordance with the file structure of this project (available at root/Data or by forking template repository), the command lines will be repeatable without changes and will produce the same results. This material has been prepared to provide a reproducible workflow, describing the decisions made and solutions implemented in the preparation of ecogeographical variables for species distribution (habitat suitability) modelling for biodiversity conservation planning. For the most part, this material consists of: explanatory text, which is recognizable as text; command lines, which are hidden by default to make the text easier to read. The locations of the command lines can be identified by the “|&gt; Code” visible on the left side of the page, just below this paragraph. Clicking on it will open the code area, where the text on a grey background is command lines, for example: Code object=function(arguments1,arguments2, path=&quot;./path/file/tree/object.extension&quot;) # comment In the example above, the first line creates an object (“object”) that is the result of a function (“function()”). The function has three arguments (“arguments1”, “arguments2” and “path”) separated by commas (as with all function arguments in R). The third argument is the path in the file tree (it is on a new line but is a continuation of the function on the previous line, because the parentheses are not closed), which is indicated by an equal sign (and quotation marks) followed by this path (note the beginning “./”, which indicates a relative path - the location in the file tree is relative to the project location). The second line of the example above is a comment - everything after “#” is a comment. Anything in a command line before “#” must be an executable function or object. A comment can contain anything and be on the same line as an executable function (at the end of it). Command lines are the most important part of this material for reproducibility. However, the person using them must ensure the availability of input data and maintain correct paths in the file tree. In this material code chunks are formatted as individual pieces to better pinpoint commands used for a job described in the text around. However, in practical setting the creation of ecogeographical variables will be much faster, if they will be combined in loops or other batch processing setup. Command lines used in practice are available in the home repository of this material at Data/RScripts_final, they can be executed in an alphanumeric order, if not specified differently. We performed parts of the compute on the University of Latvia Institute of Numerical Modelling HPC cluster with the same file tree as in this material. Shell scripts used to run R commands are available in the home repository of this material at Data/hpc_io/Jobs_shell/2024/EGVs. Sometimes we will refer to R packages in the text, we will put them in curly brackets, for example, {package}. graphics - occasional diagrams that describe the workflow or data characteristics and maps; links to other resources, especially to higher-level products and results created within the project, as well as any publicly available data. The results are intended for practical use. Within reason, the material describes all data sets used and provides metadata related to ensuring reproducibility. Since not all data sets are freely available, they are not published as such, but in all cases information is provided on how they were obtained for the development of this project. Outline Terminology and acronyms Utilities Template files Raw geodata Geodata products Ecogeographical variables Data access "],["Ch01.html", "1 Terminology and acronyms", " 1 Terminology and acronyms Athough all georeferenced data can be considered geodata, in this material we use the following terms in the order listed below in our workflows: raw geodata - considered as raw data obtained for a harmonised description of the environment. This may include tables with coordinates, raster or vector data. It can be anything that has been or can be used to create ecogeographical variables, with or without slight processing. geodata product - processed raw geodata that have undegone heavy modifications, e.g.  spatial overlays and combinations of different sets of raw geodata, and are used as input data. In this document, geodata products are categorical raster layers that match the CRS and the pixel locations of input data. When split by categories, they become input data. The processing step of creating geodata products is necessary when decisions about the order of spatial overlays are important. For example, in a high-resolution pixel, there can only be water or forest, if the edge between water and forest need to be calculated. input data or input layers - very-high resolution (multiple times higher than that used for ecogeographical variables) raster data that are the direct input for the creation of most of the ecogeographical variables. The creation of such layers is particularly useful alongside geodata products, as dealing with border misalignment or decisions regarding the order of spatial overlays, as well as simple geoprocessing, is much faster with raster data. ecogeographical variables (EGVs) - this is the final product of the workflow describing environment for statistical analysis (e.g. species distribution modelling). They are suitable also for publishing due to standardisation of the values. In other words, these are standardised landscape ecological variables in the form of high-resolution raster layers (we use 1 ha cells). Each layer contains values representing the environment within the cell footprint or a summary of focal neighbours. In our case, each layer is of quantitative data describing a natural quantity (e.g. timber volume, mean annual temperature), or quantified information of categories (e.g. the fraction of class’s area in an analysis cell or some neighbourhood, the number of pixels creating an edge of a certain class or between two classes in the analysis cell or some neighbourhood). The values of each layer are standardised: for each cell, the layer mean is subtracted and the result is divided by the root mean square error. Therefore, the values are more suitable for modelling, and the layers can be made publicly available as they do not directly provide exact sensitive information. In this material, we use the term species distribution modelling as a more used term, that is synonymous with ecological niche analysis and ecological niche modelling. Tree species groups: coniferous - following species (codes) as used in the national forest stand-level-inventory database: - pines (1, 14, 22) - spruces (3, 15) - larch (13) - firs (23, 28) boreal deciduous - following species (codes) as used in the national forest stand-level-inventory database: - birches (4) - black alder (6) - aspens (8, 19, 68) - grey alder (9) - willows (20, 21) - rowan (32) - eve (35) temperate deciduous - following species (codes) as used in the national forest stand-level-inventory database: - oaks (10, 61) - ashes (11, 64) - lindens (12, 62) - elms (16, 65) - beech (17) - hornbeam (18) - maples (24, 63) - cherry (25) - apple (26) - pear (27) - yew (29) - acacia (50) - walnut (66) - chestnut (67) - robinia (69) Forest stand age groups as used in the national forest stand-level-inventory database: - young stands (vgr = 1) in coniferous trees, ashes and oaks - until 40 years, in grey alder - until 10 years, in other tree species - until 20 years; - medium aged stands (vgr = 2 or vgr = 3) are between young stands (vgr = 1) and legal rotation age; - old stands (vgr = 4 or vgr = 5) are stands exceeding legal rotation age. This is defined in [by law](https://likumi.lv/ta/id/2825#p9) based on tree species and site quality class (bonity). Generally for oaks, pines and larches it is 101 or 121 year, for spruces, ashes, limes, elms and maples it is 81 year, for birches it is 71 or 51 year, for black alder it is 71 year, for aspens it is 41 year. Currently, there is no minimum rotation age in grey alder. We used 35 years, as it is the age of the youngest stand registered as “full grown” in the databse. This was necessary for the harmonization of EGVs throughout forests. Acronyms: CRS - coordinate reference system DW - Dynamic World EGV - ecogeographical variables SDM - species distribution modelling SDMs - species distribution models LAD - Rural Support Service LĢIA - Latvian Geospatial Information Agency LULC - Land use and land cover LU ĢZZF - University of Latvia Faculty of Geography and Earth Sciences LVM - state owned Joint Stock Company “Latvia’s State Forests” LVMI Silava - Latvian State Forest Research Institute “Silava” NDMI - normalized difference moisture index NDVI - normalized difference vegetation index NDWI - normalized difference water index MVR - State Forest Service’s stand level inventory database “Forest State Registry” VMD - State Forest Service "],["Ch02.html", "2 Utilities 2.1 R package egvtools 2.2 Other utility functions", " 2 Utilities This chapter provides a brief description of the utility functions used in this material. Most of these functions are packaged in the R package {egvtools}, which was created specifically for this work. 2.1 R package egvtools {egvtools} provides a coherent set of wrappers and utilities that facilitate the reproducible and efficient creation of large-scale EGVs on real datasets. The package relies on robust building blocks — {terra}, {sf}, {sfarrow}, {exactextractr} and {whitebox} — and standardises input/output, naming conventions and multi-scale zonal statistics, ensuring that the pipelines are repeatable across machines and projects. The package was developed for the project ‘HiQBioDiv: High-resolution quantification of biodiversity for conservation and management’, which was funded by the Latvian Council of Science (Ref. No. VPP-VARAM-DABA-2024/1-0002), to simplify our work and to facilitate the reproduction of our results. Five of the functions are strictly for replication, while others are useful for a wider audience. Package can be installed from GitHub with: Code # install.packages(&quot;pak&quot;) pak::pak(&quot;aavotins/egvtools&quot;) or obtained as a Docker container with all the necessary system and software dependencies. 2.1.1 Reproduction only functions These functions are small wrappers, that helps to recreate our working environments - template files and their locations in the file tree. These functions are: download_raster_templates() — fetch template rasters from Zenodo repository and place them in user specified location on disk, or by default - the one we used. By default this function links to the version 2.0.0 of the dataset; download_vector_templates() - fetch template vector grids/points from Zenodo repository and place them in user specified location on disk, or by default - the one we used. By default this function links to the version 1.0.1 of the dataset; radius_function() — extracts summary statistics from raster layers using buffered polygon zones of multiple radii and rasterises them onto a common template grid. Internally hard coded to use filenames (first and second part in the result of tiling functions) as used in this project. If the filenames are kept, function can easily be used for other projects, regions etc. Function can be used to run sequentially, however much faster compute will be with parallel computing. If fast swap disk is available, this function needs only c.a. 5 GiBs of RAM per worked to perform tasks in this project. However, if the swap disk is not available, at least 20 GiBs of RAM per worker need to be assigned. 2.1.2 General purpose functions Each of those functions are small workflows themselves that can be combined into larger workflows and used more widely than for Latvia. tile_vector_grid() — tile template (vector) grid for chunked processing. The function internally is linked to our file naming convention. As long as it is maintained, function can be used to create tiled grid from any {sfarrow} parquet grid file; tiled_buffers() — precompute buffered tiles for multiple radii around points. The function internally is linked to our file naming convention. As long as it is maintained, function can be used to create tiled polygons with buffers around points from any {sfarrow} parquet grid file. There are three buffering modes: dense (buffers the best-matching pts100*.parquet (prefers pts100_sauzeme.parquet) for each tile by radii_dense (default: 500, 1250, 3000, 10000 m ensuring that every analysis grid cell has desired buffer. Computationally heavy in the following workflows), sparse (uses a file to radius mapping and is highly generalizable), and specified (the same as sparse, but with one single point file). In our workflows we used the sparse mode with default mapping; create_backgrounds() — a wrapper around terra::ifel() to build consistent background rasters. This function better guards coordinate reference system and how it is stored, while also guarding spatial cover, resolution, coordinate reference system, exact pixel matching, etc. Creation of layers with default background values is faster than recreating them several times in workflows preparing EGVs; polygon2input() — rasterise polygons to input layers. Handles only polygon data, other geometry types need to be buffered. Rasterizes polygon/multipolygon sf data to a raster aligned to a template GeoTIFF. Rasterization targets a raster::RasterLayer built from the template (so grids normally match). Projection is optional (project_mode). Missing values are counted only over valid template cells. User may optionally restrict the result with a raster mask (restrict_to) using numeric values or bracketed range strings (e.g., “(0,5]”, “[10,)”). Remaining NA cells can be filled by covering with a background raster (background_raster) or a constant (background_value). For large rasters, heavy steps (projection/mask/cover) can stream to disk via terra_todisk=TRUE. input2egv() — normalize/align a fine-resolution input raster to a (coarser) EGV template, optionally cover missing values and/or fill gaps (IDW via Whitebox), and write the result to disk. Designed for large runs: fast gap counting (inside template footprint only), optional filling, tuned GDAL write options, and controlled terra memory/temp behavior. downscale2egv() — downscale coarse rasters to a template grid (CRS, resolution, extent), masks to the template footprint, and optionally: (1) fills NoData gaps using WhiteboxTools’ IDW-based fill_missing_data, and (2) applies IDW smoothing to reduce blockiness from low-resolution inputs. distance2egv() — computes Euclidean distance (in map units) from cells matching a set of class values in an input raster to all cells of an EGV template grid, then writes a Float32 GeoTIFF aligned to the template. Designed to work with rasters produced by polygon2input(). landscape_function() — computes a {landscapemetrics} metric (default “lsm_l_shdi”), optionally with extra lm_args, that yields one value per zone and per input layer. Runs tile-by-tile (by tile_field), writes per-tile rasters, merges to final per-layer GeoTIFF(s), then performs gap analysis (NA count within the template footprint and optional maximum gap width) and optional IDW gap filling via WhiteboxTools. Returns a compact data.frame with per-layer stats and timing. Function can be used to run sequentially, however much faster compute will be with parallel computing. If fast swap disk is available, this function needs only 3 GiBs of RAM per worked to perform tasks in this project. However, if the swap disk is not available, at least 20 GiBs of RAM per worker need to be assigned. 2.2 Other utility functions Other handy functions repeatedly used, not included in {egvtools} are stored in egvs02.02_UtilityFunctions.R file, located in Data/RScipts_final. ensure_multipolygons() - rather agressive function to create MULTIPOLYGON geometries from GEOMETRYCOLLECTION Code if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(gdalUtilities)) {install.packages(&quot;gdalUtilities&quot;); require(gdalUtilities)} ensure_multipolygons &lt;- function(X) { library(sf) library(gdalUtilities) tmp1 &lt;- tempfile(fileext = &quot;.gpkg&quot;) tmp2 &lt;- tempfile(fileext = &quot;.gpkg&quot;) st_write(X, tmp1) ogr2ogr(tmp1, tmp2, f = &quot;GPKG&quot;, nlt = &quot;MULTIPOLYGON&quot;) Y &lt;- st_read(tmp2) st_sf(st_drop_geometry(X), geom = st_geometry(Y)) } "],["Ch03.html", "3 Templates files 3.1 Vector data 3.2 Raster data", " 3 Templates files This chapter defines template files. They define the analysis space and ensure harmonisation of georeferenced data creation, and facilitate connection with other Latvian geodata. 3.1 Vector data Baseline template (or reference) vector grid and point files are publiclly available in the HiQBioDiv’s Zenodo repository. The command lines and data used to create these files are documented in the HiQBioDiv main code repository’s file. The easiest way to obtain these files is to run determined function download_vector_templates() from {egvtools}. Code if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} download_vector_templates( url = &quot;https://zenodo.org/api/records/14277114/files-archive&quot;, grid_dir = &quot;./Templates/TemplateGrids&quot;, points_dir = &quot;./Templates/TemplateGridPoints&quot;, gpkg_dir = &quot;./Templates&quot;, overwrite = FALSE, quiet = FALSE ) Once template vector data are downloaded and unarchived, they need to be tiled: Analysis grid is tiled in tks50km pages Code if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} tile_vector_grid( grid_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, out_dir = &quot;./Templates/TemplateGrids/tiles&quot;, tile_field = &quot;tks50km&quot;, chunk_size = 50000L, overwrite = FALSE, quiet = FALSE ) Expect to see warning: This is an initial implementation of Parquet/Feather file support and geo metadata. This is tracking version 0.1.0 of the metadata (https://github.com/geopandas/geo-arrow-spec). This metadata specification may change and does not yet make stability promises. We do not yet recommend using this in a production setting unless you are able to rewrite your Parquet/Feather files. Point files are tiled and buffered. In the workflows creating EGVs described in this document, we used a “sparse” grid: 500m buffers around every 100m grid cell’s centre; 1250m buffers around every 100m grid cell’s centre; 3000m buffers around every 300m grid cell’s centre (to speed up neighbourhood analysis ~9 times, while loosing &lt;0.001% of precission); 10000m buffers around every 1000m grid cell’s centre (to speed up neighbourhood analysis ~100 times, while loosing &lt;0.001% of precission) Code if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} tiled_buffers( in_dir = &quot;./Templates/TemplateGridPoints&quot;, out_dir = &quot;./Templates/TemplateGridPoints/tiles&quot;, buffer_mode = &quot;sparse&quot;, mapping_sparse = list(&quot;pts100_sauzeme.parquet&quot; = c(500, 1250), &quot;pts300_sauzeme.parquet&quot; = 3000, &quot;pts1000_sauzeme.parquet&quot; = 10000), split_field = &quot;tks50km&quot;, n_workers = 4, future_max_mem_gb = 4, overwrite = FALSE, quiet = FALSE ) Expect to see warning: This is an initial implementation of Parquet/Feather file support and geo metadata. This is tracking version 0.1.0 of the metadata (https://github.com/geopandas/geo-arrow-spec). This metadata specification may change and does not yet make stability promises. We do not yet recommend using this in a production setting unless you are able to rewrite your Parquet/Feather files. Appearance of file pts300_r3000_NA.parquet, i.e. without a tile number, is expected, due to slight mismatch of 300 m grid with the 50 km one. 3.2 Raster data Baseline template (or reference) raster grid and point files are publically available in the HiQBioDiv’s Zenodo repository. The command lines and data used to create these files are documented in the HiQBioDiv main code repository’s file. The easiest way to obtain these files is to run determined function download_raster_templates() from {egvtools}. Code if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} download_raster_templates( url = &quot;https://zenodo.org/api/records/14497070/files-archive&quot;, out_dir = &quot;./Templates/TemplateRasters&quot;, overwrite = TRUE, quiet = FALSE ) During EGV creation, background filling to handle missing values may be necessary. For all EGVs described in this document where such an exercise might be required, the variables can be considered quantities of ratio scale, therefore backgrounds with value 0 are created. Code if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} create_backgrounds(in_dir=&quot;./Templates/TemplateRasters/&quot;, out_dir = &quot;./Templates/TemplateRasters/&quot;, background_value = 0, out_prefix = &quot;nulls_&quot;, overwrite=TRUE) "],["Ch04.html", "4 Raw geodata 4.1 State Forest Service’s State Forest Register 4.2 Rural Support Service’s information on declared fields 4.3 Melioration Cadaster 4.4 Topographic Map 4.5 Corine Land Cover 2018 4.6 Publicly available LVM data 4.7 Soil data 4.8 Dynamic World data 4.9 The Global Forest Watch 4.10 Palsar 4.11 CHELSA v2.1 4.12 HydroClim data 4.13 Sentinel-2 indices 4.14 Waste and garbage disposal sites, landfills 4.15 Digital elevation/terrain models 4.16 Latvian Exclusive Economic Zone polygon 4.17 Bogs and Mires: EDI", " 4 Raw geodata This chapter describes raw geodata used and the preliminary processing conducted on them. 4.1 State Forest Service’s State Forest Register The State Forest Service’s State Forest Register database (ESRI file geodatabase), which compiles indicators and spatial data characterizing forest compartments (stand level inventory database), was received by the University of Latvia on January 7, 2024, to support study and research processes. The structure of the received database version corresponds to the State Forest Register Forest Inventory File Structure, but lowercase letters are used in field names. After downloading, the CRS is guarded, geometries are checked and saved in GeoParquet format. Files are stored at Geodata/2024/MVR/. Code # libs if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(gdalUtilities)) {install.packages(&quot;gdalUtilities&quot;); require(gdalUtilities)} # database nog=read_sf(&quot;./Geodata/2024/MVR/VMD.gdb/&quot;,layer=&quot;Nogabali_pilna_datubaze&quot;) # ensuring geometries source(&quot;./RScripts_final/egvs02.02_UtilityFunctions.R&quot;) nogabali &lt;- ensure_multipolygons(nog) # securing geometries nogabali2 = nogabali[!st_is_empty(nogabali),,drop=FALSE] # 108 tukšas ģeometrijas validity=st_is_valid(nogabali2) table(validity) # 1733 invalid ģeometrijas nogabali3=st_make_valid(nogabali2) # transforming CRS nogabali4=st_transform(nogabali3, crs=3059) # saving sfarrow::st_write_parquet(nogabali4, &quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) 4.2 Rural Support Service’s information on declared fields The Rural Support Service maintains regularly updated information on the open data portal. An archive (since 2016) is also available there, and the data sets that can be used contain the keyword “deklarētās platības”. After downloading files to Geodata/2024/LAD/downloads/, they are unzipped and read into R. Files are checked, empty geometries are deleted and the rest are validated, and all individual files are combined into one, which is saved in GeoPackage and GeoParquet formats at Geodata/2024/LAD/. At the end, downloaded files are unlinked. Code # libs if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(gdalUtilities)) {install.packages(&quot;gdalUtilities&quot;); require(gdalUtilities)} # reading all files faili=data.frame(celi=list.files(&quot;./Geodata/2024/LAD/downloads&quot;,full.names = TRUE)) dati=st_read(faili$celi[1]) for(i in 2:length(faili$celi)){ nakosais=st_read(faili$celi[i]) dati=bind_rows(dati,nakosais) print(nrow(dati)) } # ensuring geometries source(&quot;./RScripts_final/egvs02.02_UtilityFunctions.R&quot;) nogabali &lt;- ensure_multipolygons(nog) dati2 &lt;- ensure_multipolygons(dati) dati3 = dati2[!st_is_empty(dati2),,drop=FALSE] # viss kārtībā table(st_is_valid(dati3)) dati4=st_make_valid(dati3) table(st_is_valid(dati4)) dati5 &lt;- ensure_multipolygons(dati4) table(st_is_valid(dati5)) # saving output st_write(dati5,&quot;./Geodata/2024/LAD/Lauki_2024.gpkg&quot;,append = FALSE) sfarrow::st_write_parquet(dati5,&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) # unlinking downloads for(i in seq_along(faili$celi)){ unlink(faili$celi[i]) } rm(list=ls()) 4.3 Melioration Cadaster The Land Improvement Cadastre Information System database was downloaded layer by layer from Geoserver. Geometries were tested and validated for each layer, and layers were all combined into a single GeoPackage file stored at Geodata/2024/MKIS/. Initially, no additional processing was performed on this data. It was used to prepare Geodata products - both Terrain products and Landscape classification. Code # libs if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(httr)) {install.packages(&quot;httr&quot;); require(httr)} if(!require(ows4R)) {install.packages(&quot;ows4R&quot;); require(ows4R)} # basis information ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;, #version = &quot;2.0.0&quot;, # facultative request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) request bwk_client &lt;- WFSClient$new(link, serviceVersion = &quot;2.0.0&quot;) bwk_client bwk_client$getFeatureTypes(pretty = TRUE) # dams ---- bwk_client$getFeatureTypes(pretty = TRUE) url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_dam&quot;) request &lt;- build_url(url) aizsargdambji &lt;- read_sf(request) aizsargdambji = aizsargdambji %&gt;% st_set_crs(st_crs(3059)) aizsargdambji=st_cast(aizsargdambji,&quot;MULTILINESTRING&quot;) ggplot(aizsargdambji)+geom_sf() table(st_is_valid(aizsargdambji)) write_sf(aizsargdambji, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;Aizsargdambji&quot;, append=FALSE) rm(aizsargdambji) # watercourses ---- bwk_client$getFeatureTypes(pretty = TRUE) url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_watercourses&quot;) request &lt;- build_url(url) DabiskasUdensteces &lt;- read_sf(request) DabiskasUdensteces = DabiskasUdensteces %&gt;% st_set_crs(st_crs(3059)) DabiskasUdensteces=st_cast(DabiskasUdensteces,&quot;MULTILINESTRING&quot;) ggplot(DabiskasUdensteces)+geom_sf() table(st_is_valid(DabiskasUdensteces)) write_sf(DabiskasUdensteces, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;DabiskasUdensteces&quot;, append=FALSE) rm(DabiskasUdensteces) # dam pickets ---- bwk_client$getFeatureTypes(pretty = TRUE) url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_dampicket&quot;) request &lt;- build_url(url) DambjuPiketi &lt;- read_sf(request) DambjuPiketi = DambjuPiketi %&gt;% st_set_crs(st_crs(3059)) DambjuPiketi=st_cast(DambjuPiketi,&quot;POINT&quot;) ggplot(DambjuPiketi)+geom_sf() table(st_is_valid(DambjuPiketi)) write_sf(DambjuPiketi, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;DambjuPiketi&quot;, append=FALSE) rm(DambjuPiketi) # drainpipes ---- bwk_client$getFeatureTypes(pretty = TRUE) base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_drainpipes&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_Drenas&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) Drenas_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_Drenas&quot;) Drenas_all2 = Drenas_all[!st_is_empty(Drenas_all),,drop=FALSE] # 1 table(st_is_valid(Drenas_all2)) write_sf(Drenas_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;Drenas&quot;, append=FALSE) rm(list=ls()) # drain collectors ---- bwk_client$getFeatureTypes(pretty = TRUE) # geoms bwk_client$getFeatureTypes(pretty = TRUE) url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_draincollectors&quot;, count=1) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # count url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_draincollectors&quot;, resultType=&quot;hits&quot;) request &lt;- build_url(url) result &lt;- GET(request) parsed &lt;- xml2::as_list(content(result, &quot;parsed&quot;)) n_features &lt;- attr(parsed$FeatureCollection, &quot;numberMatched&quot;) n_features # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_draincollectors&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_DrenuKolektori&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) DrenuKolektori_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_DrenuKolektori&quot;) DrenuKolektori_all2 = DrenuKolektori_all[!st_is_empty(DrenuKolektori_all),,drop=FALSE] # 1 table(st_is_valid(DrenuKolektori_all2)) write_sf(DrenuKolektori_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;DrenuKolektori&quot;, append=FALSE) rm(list=ls()) # drenage network structures ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_networkstructures&quot;, count=1) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_networkstructures&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_DrenazasTiklaBuves&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) DrenazasTiklaBuves_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_DrenazasTiklaBuves&quot;) DrenazasTiklaBuves_all2 = DrenazasTiklaBuves_all[!st_is_empty(DrenazasTiklaBuves_all),,drop=FALSE] # 0 table(st_is_valid(DrenazasTiklaBuves_all2)) write_sf(DrenazasTiklaBuves_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;DrenazasTiklaBuves&quot;, append=FALSE) rm(list=ls()) # dithces ----- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_ditches&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_ditches&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_Gravji&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) Gravji_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_Gravji&quot;) Gravji_all2 = Gravji_all[!st_is_empty(Gravji_all),,drop=FALSE] # 0 table(st_is_valid(Gravji_all2)) write_sf(Gravji_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;Gravji&quot;, append=FALSE) rm(list=ls()) # hydrometric posts ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_hydropost&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_hydropost&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./IevadesDati/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_HidrometriskiePosteni&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) HidrometriskiePosteni_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_HidrometriskiePosteni&quot;) HidrometriskiePosteni_all2 = HidrometriskiePosteni_all[!st_is_empty(HidrometriskiePosteni_all),,drop=FALSE] # 0 table(st_is_valid(HidrometriskiePosteni_all2)) write_sf(HidrometriskiePosteni_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;HidrometriskiePosteni&quot;, append=FALSE) rm(list=ls()) # large diameter drain collectors ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_bigdraincollectors&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_bigdraincollectors&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_LielaDiametraKolektori&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) LielaDiametraKolektori_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_LielaDiametraKolektori&quot;) LielaDiametraKolektori_all2 = LielaDiametraKolektori_all[!st_is_empty(LielaDiametraKolektori_all),,drop=FALSE] # 0 table(st_is_valid(LielaDiametraKolektori_all2)) write_sf(LielaDiametraKolektori_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;LielaDiametraKolektori&quot;, append=FALSE) rm(list=ls()) # river pickets ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_stateriverspickets&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_stateriverspickets&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_Piketi&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) Piketi_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_Piketi&quot;) Piketi_all2 = Piketi_all[!st_is_empty(Piketi_all),,drop=FALSE] # 0 table(st_is_valid(Piketi_all2)) write_sf(Piketi_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;Piketi&quot;, append=FALSE) rm(list=ls()) # polder pumping stations ----- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_polderpumpingstation&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_polderpumpingstation&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_PolderuSuknuStacijas&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) PolderuSuknuStacijas_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_PolderuSuknuStacijas&quot;) PolderuSuknuStacijas_all2 = PolderuSuknuStacijas_all[!st_is_empty(PolderuSuknuStacijas_all),,drop=FALSE] # 0 table(st_is_valid(PolderuSuknuStacijas_all2)) write_sf(PolderuSuknuStacijas_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;PolderuSuknuStacijas&quot;, append=FALSE) rm(list=ls()) # polders ----- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_polderterritory&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam geometrijas=st_set_crs(geometrijam,st_crs(3059)) library(gdalUtilities) ensure_multipolygons &lt;- function(X) { tmp1 &lt;- tempfile(fileext = &quot;.gpkg&quot;) tmp2 &lt;- tempfile(fileext = &quot;.gpkg&quot;) st_write(X, tmp1) ogr2ogr(tmp1, tmp2, f = &quot;GPKG&quot;, nlt = &quot;MULTIPOLYGON&quot;) Y &lt;- st_read(tmp2) st_sf(st_drop_geometry(X), geom = st_geometry(Y)) } poligoni &lt;- ensure_multipolygons(geometrijas) PolderuTeritorijas_all2 = poligoni[!st_is_empty(poligoni),,drop=FALSE] # 0 table(st_is_valid(PolderuTeritorijas_all2)) # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_polderterritory&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_PolderuTeritorijas&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;MULTIPOLYGON&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) PolderuTeritorijas_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_PolderuTeritorijas&quot;) PolderuTeritorijas_all2 = PolderuTeritorijas_all[!st_is_empty(PolderuTeritorijas_all),,drop=FALSE] # 0 table(st_is_valid(PolderuTeritorijas_all2)) write_sf(PolderuTeritorijas_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;PolderuTeritorijas&quot;, append=FALSE) rm(list=ls()) # catchment basins ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_catchment&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_catchment&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_SatecesBaseini&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) ensure_multipolygons &lt;- function(X) { tmp1 &lt;- tempfile(fileext = &quot;.gpkg&quot;) tmp2 &lt;- tempfile(fileext = &quot;.gpkg&quot;) st_write(X, tmp1) ogr2ogr(tmp1, tmp2, f = &quot;GPKG&quot;, nlt = &quot;MULTIPOLYGON&quot;) Y &lt;- st_read(tmp2) st_sf(st_drop_geometry(X), geom = st_geometry(Y)) } chunk &lt;- ensure_multipolygons(chunk) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) SatecesBaseini_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_SatecesBaseini&quot;) SatecesBaseini_all2 = SatecesBaseini_all[!st_is_empty(SatecesBaseini_all),,drop=FALSE] # 0 table(st_is_valid(SatecesBaseini_all2)) SatecesBaseini_all3=st_make_valid(SatecesBaseini_all2) table(st_is_valid(SatecesBaseini_all3)) SatecesBaseini_all3 write_sf(SatecesBaseini_all3, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;SatecesBaseini&quot;, append=FALSE) rm(list=ls()) # drenage connection points ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_connectionpoints&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_connectionpoints&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_Savienojumi&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) chunk=st_cast(chunk,&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) Savienojumi_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_Savienojumi&quot;) Savienojumi_all2 = Savienojumi_all[!st_is_empty(Savienojumi_all),,drop=FALSE] # 0 table(st_is_valid(Savienojumi_all2)) write_sf(Savienojumi_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;Savienojumi&quot;, append=FALSE) rm(list=ls()) # state controlled rivers ----- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_statecontrolledrivers&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_statecontrolledrivers&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_ValstsNozimesUdensnotekas&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) chunk=st_cast(chunk,&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) ValstsNozimesUdensnotekas_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_ValstsNozimesUdensnotekas&quot;) ValstsNozimesUdensnotekas_all2 = ValstsNozimesUdensnotekas_all[!st_is_empty(ValstsNozimesUdensnotekas_all),,drop=FALSE] # 0 table(st_is_valid(ValstsNozimesUdensnotekas_all2)) write_sf(ValstsNozimesUdensnotekas_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;ValstsNozimesUdensnotekas&quot;, append=FALSE) rm(list=ls()) # zmni regions ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_zmniregion&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam library(gdalUtilities) # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_zmniregion&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_ZMNIRegions&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) ensure_multipolygons &lt;- function(X) { tmp1 &lt;- tempfile(fileext = &quot;.gpkg&quot;) tmp2 &lt;- tempfile(fileext = &quot;.gpkg&quot;) st_write(X, tmp1) ogr2ogr(tmp1, tmp2, f = &quot;GPKG&quot;, nlt = &quot;MULTIPOLYGON&quot;) Y &lt;- st_read(tmp2) st_sf(st_drop_geometry(X), geom = st_geometry(Y)) } chunk &lt;- ensure_multipolygons(chunk) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) ZMNIRegions_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_ZMNIRegions&quot;) ZMNIRegions_all2 = ZMNIRegions_all[!st_is_empty(ZMNIRegions_all),,drop=FALSE] # 0 table(st_is_valid(ZMNIRegions_all2)) write_sf(ZMNIRegions_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;ZMNIRegions&quot;, append=FALSE) rm(list=ls()) # water drenage ditches ----- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_waterdrainditches&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_waterdrainditches&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_UdensnotekasNovadgravji&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) chunk=st_cast(chunk,&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) UdensnotekasNovadgravji_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_UdensnotekasNovadgravji&quot;) UdensnotekasNovadgravji_all2 = UdensnotekasNovadgravji_all[!st_is_empty(UdensnotekasNovadgravji_all),,drop=FALSE] # 0 table(st_is_valid(UdensnotekasNovadgravji_all2)) write_sf(UdensnotekasNovadgravji_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;UdensnotekasNovadgravji&quot;, append=FALSE) rm(list=ls()) # ditch pickets ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_ditchpicket&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_ditchpicket&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_UdensnotekuNovadgravjuPiketi&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) %&gt;% st_cast(&quot;POINT&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) UdensnotekuNovadgravjuPiketi_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_UdensnotekuNovadgravjuPiketi&quot;) UdensnotekuNovadgravjuPiketi_all2 = UdensnotekuNovadgravjuPiketi_all[!st_is_empty(UdensnotekuNovadgravjuPiketi_all),,drop=FALSE] # 0 table(st_is_valid(UdensnotekuNovadgravjuPiketi_all2)) write_sf(UdensnotekuNovadgravjuPiketi_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;UdensnotekuNovadgravjuPiketi&quot;, append=FALSE) rm(list=ls()) # state river axis ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_stateriversline&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_stateriversline&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_UdenstecuAsis&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) chunk=st_cast(chunk,&quot;MULTILINESTRING&quot;) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) UdenstecuAsis_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_UdenstecuAsis&quot;) UdenstecuAsis_all2 = UdenstecuAsis_all[!st_is_empty(UdenstecuAsis_all),,drop=FALSE] # 0 table(st_is_valid(UdenstecuAsis_all2)) write_sf(UdenstecuAsis_all2, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;UdenstecuAsis&quot;, append=FALSE) rm(list=ls()) # river surface ---- link=&quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; url=parse_url(link) url$query &lt;- list(service = &quot;wfs&quot;,request = &quot;GetCapabilities&quot;) request &lt;- build_url(url) bwk_client &lt;- WFSClient$new(link,serviceVersion = &quot;2.0.0&quot;) bwk_client$getFeatureTypes(pretty = TRUE) # geoms url$query &lt;- list(service = &quot;wfs&quot;, request = &quot;GetFeature&quot;, srsName=&quot;EPSG:3059&quot;, typename = &quot;zmni:zmni_stateriverspolygon&quot;, count=100) request &lt;- build_url(url) geometrijam &lt;- read_sf(request) geometrijam # download base_url &lt;- &quot;https://lvmgeoserver.lvm.lv/geoserver/zmni/ows?&quot; type_name &lt;- &quot;zmni:zmni_stateriverspolygon&quot; crs_code &lt;- 3059 chunk_size &lt;- 100000 gpkg_path &lt;- &quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot; layer_name &lt;- &quot;temp_UdenstecuVirsmasLaukumi&quot; i &lt;- 0 repeat { message(&quot;Fetching features &quot;, i * chunk_size + 1, &quot; to &quot;, (i + 1) * chunk_size, &quot;...&quot;) query &lt;- list( service = &quot;WFS&quot;, version = &quot;2.0.0&quot;, request = &quot;GetFeature&quot;, typename = type_name, srsName = paste0(&quot;EPSG:&quot;, crs_code), count = chunk_size, startIndex = i * chunk_size ) req_url &lt;- modify_url(base_url, query = query) try({ chunk &lt;- read_sf(req_url) if (nrow(chunk) == 0) break # Set CRS and cast to MULTILINESTRING, POINT, MULTIPOLYGON chunk &lt;- chunk %&gt;% st_set_crs(st_crs(crs_code)) ensure_multipolygons &lt;- function(X) { tmp1 &lt;- tempfile(fileext = &quot;.gpkg&quot;) tmp2 &lt;- tempfile(fileext = &quot;.gpkg&quot;) st_write(X, tmp1) ogr2ogr(tmp1, tmp2, f = &quot;GPKG&quot;, nlt = &quot;MULTIPOLYGON&quot;) Y &lt;- st_read(tmp2) st_sf(st_drop_geometry(X), geom = st_geometry(Y)) } chunk &lt;- ensure_multipolygons(chunk) # Write chunk to GeoPackage (append mode after first) st_write( chunk, dsn = gpkg_path, layer = layer_name, append = i != 0, quiet = FALSE ) i &lt;- i + 1 }, silent = TRUE) Sys.sleep(0.5) } message(&quot;All chunks written to &quot;, gpkg_path, &quot; in layer &quot;, layer_name) UdenstecuVirsmasLaukumi_all=st_read(&quot;./Geodata/2024/MKIS/temp_MKIS_2025.gpkg&quot;, layer=&quot;temp_UdenstecuVirsmasLaukumi&quot;) UdenstecuVirsmasLaukumi_all2 = UdenstecuVirsmasLaukumi_all[!st_is_empty(UdenstecuVirsmasLaukumi_all),,drop=FALSE] # 0 table(st_is_valid(UdenstecuVirsmasLaukumi_all2)) UdenstecuVirsmasLaukumi_all3=st_make_valid(UdenstecuVirsmasLaukumi_all2) table(st_is_valid(UdenstecuVirsmasLaukumi_all3)) write_sf(UdenstecuVirsmasLaukumi_all3, &quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;, layer=&quot;UdenstecuVirsmasLaukumi&quot;, append=FALSE) rm(list=ls()) 4.4 Topographic Map To support research process at the University of Latvia, the third (completed by January 1, 2018) and fourth (unfinished) versions of the Latvian Geospatial Information Agency’s topographic map M:10000 vector geodatabase were received. The most recent version is available for public viewing, but access to the vector data is restricted. For the purposes of this project, the ESRI geodatabase has been converted to a GeoPackage file. As part of the file format change, geometries (empty, their validity checked and corrected where necessary) and coordinate system have been checked. Files were stored at Geodata/2024/TopographicMap/. After processing each database separately, we combined the layers used in this project, selecting the most recent layer per map sheet. These layers are: brigde_L, describing bridges as lines; bridge_P, describing bridges as points; hidro_A, describing waterbodies as polygons; hidro_L, describing ditches and small rivers as lines; landus_A, describing LULC as polygons; road_A, describing larger roads as polygons; road_L, including very small or disused ones, as lines; swamp_A, describing bogs as polygons; flora_L, describing linear tree and shrub formations; build_A, describing types of built-up areas. Version 4 available at the University of Latvia does not include all the classes present in Version 3, therefore version 3 is used. Code # libs ---- if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(openxlsx)) {install.packages(&quot;openxlsx&quot;); require(openxlsx)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # v4 ---- slani_v4=st_layers(&quot;./Geodata/2024/TopographicMap/Latvija_LKS92_v4_20250703.gdb/&quot;) write.xlsx(slani_v4,&quot;./Geodata/2024/TopographicMap/slani_v4partial.xlsx&quot;) slani_v4$geometrijai=as.character(slani_v4$geomtype) table(slani_v4$geometrijai) slani_v4$geometrijai2=ifelse(slani_v4$geometrijai==&quot;3D Point&quot;,&quot;POINT&quot;, ifelse(slani_v4$geometrijai==&quot;Multi Polygon&quot;,&quot;MULTIPOLYGON&quot;, ifelse(slani_v4$geometrijai==&quot;3D Multi Line String&quot;,&quot;MULTILINESTRING&quot;, ifelse(slani_v4$geometrijai==&quot;3D Multi Polygon&quot;,&quot;MULTIPOLYGON&quot;,NA)))) slani4x=data.frame(name=slani_v4$name, geometrija=slani_v4$geometrijai2) ciklam4x=levels(factor(slani4x$name)) for(i in seq_along(ciklam4x)){ print(i) sakums=Sys.time() nosaukums=ciklam4x[i] objekts=slani4x %&gt;% filter(name==nosaukums) print(nosaukums) slanis=read_sf(&quot;./Geodata/2024/TopographicMap/topo10v4/Latvija_LKS92_v4_20250703.gdb/&quot;,layer=nosaukums) slanisZM=st_zm(slanis) slanis2=st_cast(slanisZM,to=objekts$geometrija) write_sf(slanis2,&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=nosaukums,append=FALSE) ilgums=Sys.time()-sakums print(ilgums) } # v3 ---- slani_v3=st_layers(&quot;./Geodata/2024/TopographicMap/Latvija_LKS92_v3_pilnais.gdb/&quot;) write.xlsx(slani_v3,&quot;./Geodata/2024/TopographicMap/slani_v3.xlsx&quot;) slani_v3$geometrijai=as.character(slani_v3$geomtype) table(slani_v3$geometrijai) slani_v3$geometrijai2=ifelse(slani_v3$geometrijai==&quot;3D Point&quot;,&quot;POINT&quot;, ifelse(slani_v3$geometrijai==&quot;Multi Polygon&quot;,&quot;MULTIPOLYGON&quot;, ifelse(slani_v3$geometrijai==&quot;3D Multi Line String&quot;,&quot;MULTILINESTRING&quot;, ifelse(slani_v3$geometrijai==&quot;3D Multi Polygon&quot;,&quot;MULTIPOLYGON&quot;, ifelse(slani_v3$geometrijai==&quot;Point&quot;,&quot;POINT&quot;, ifelse(slani_v3$geometrijai==&quot;Multi Line String&quot;,&quot;MULTILINESTRING&quot;, ifelse(slani_v3$geometrijai==&quot;3D Measured Point&quot;,&quot;POINT&quot;,NA))))))) slani3x=data.frame(name=slani_v3$name, geometrija=slani_v3$geometrijai2) ciklam3x=levels(factor(slani3x$name)) for(i in seq_along(ciklam3x)){ print(i) sakums=Sys.time() nosaukums=ciklam3x[i] objekts=slani3x %&gt;% filter(name==nosaukums) print(nosaukums) slanis=read_sf(&quot;./Geodata/2024/TopographicMap/Latvija_LKS92_v3_pilnais.gdb/&quot;,layer=nosaukums) slanisZM=st_zm(slanis) slanis2=st_cast(slanisZM,to=objekts$geometrija) write_sf(slanis2,&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=nosaukums,append=FALSE) ilgums=Sys.time()-sakums print(ilgums) } # combination ---- st_layers(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;) pages4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;Topo10_lapas&quot;) pages4_united=st_union(pages4) ggplot(pages4_united)+geom_sf() # landus_A landus_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;landus_A&quot;) landus_not4=st_difference(landus_3,pages4_united) landus_not4=landus_not4 %&gt;% dplyr::select(FNAME,FCODE) landus_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;landus_A&quot;) landus_4=landus_4 %&gt;% dplyr::select(FNAME,FCODE) landus_new=rbind(landus_not4,landus_4) sfarrow::st_write_parquet(landus_new,&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) # bridge_L data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;bridge_L&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;bridge_L&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/BridgeL_COMB.parquet&quot;) # bridge_P data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;bridge_P&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;bridge_P&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/BridgeP_COMB.parquet&quot;) # hidro_A data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;hidro_A&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;hidro_A&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/HidroA_COMB.parquet&quot;) # hidro_L data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;hidro_L&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;hidro_L&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/HidroL_COMB.parquet&quot;) # road_A data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;road_A&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;road_A&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/RoadA_COMB.parquet&quot;) # road_L data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;road_L&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;road_L&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/RoadL_COMB.parquet&quot;) # swamp_A data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;swamp_A&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;swamp_A&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/SwampA_COMB.parquet&quot;) # flora_L data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;flora_L&quot;) data_not4=st_difference(data_3,pages4_united) data_not4=data_not4 %&gt;% dplyr::select(FNAME,FCODE) data_4=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v4partial.gpkg&quot;,layer=&quot;flora_L&quot;) data_4=data_4 %&gt;% dplyr::select(FNAME,FCODE) data_new=rbind(data_not4,data_4) sfarrow::st_write_parquet(data_new,&quot;./Geodata/2024/TopographicMap/FloraL_COMB.parquet&quot;) # build_A data_3=st_read(&quot;./Geodata/2024/TopographicMap/LGIAtopo10K_v3.gpkg&quot;,layer=&quot;build_A&quot;) data_3=data_3 %&gt;% dplyr::select(FNAME,FCODE) sfarrow::st_write_parquet(data_3,&quot;./Geodata/2024/TopographicMap/BuildA_v3.parquet&quot;) 4.5 Corine Land Cover 2018 Corine Land Cover is publicly available geodata that characterizes land cover and land use (LULC) across Europe over a long period of time using a generally consistent (comparable) methodology (https://land.copernicus.eu/content/corine-land -cover-nomenclature-guidelines/docs/pdf/CLC2018_Nomenclature_illustrated_guide_20190510.pdf), providing results for individual years - 1990, 2000, 2006, 2012, 2018 (https://land.copernicus.eu/en/products/corine-land-cover). Although the dataset has a coarse resolution – the mapping unit is 25 ha areas that are at least 100 m wide – it provides sufficient information for general use, such as workflow testing and observation filtering. This project uses data from 2018. The downloaded data set has been transformed into the Latvian coordinate system (EPSG:3059), and the file format has been changed to GeoParquet to facilitate and speed up further work. As part of the file format change, geometries (empty, validity) have been checked. Data are stored at Geodata/2024/CLC/. Code # libs ---- if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} # downloaded data clcLV=st_read(&quot;./Geodata/2024/CLC/clcLV.gpkg&quot;,layer=&quot;clcLV&quot;) # empty geoms clcLV2 = clcLV[!st_is_empty(clcLV),,drop=FALSE] # OK # validation validity=st_is_valid(clcLV2) table(validity) # 3 non-valid clcLV3=st_make_valid(clcLV2) # crs clcLV3=st_transform(clcLV3,crs=3059) # saving sfarrow::st_write_parquet(clcLV3, &quot;./Geodata/2024/CLC/CLC_LV_2018.parquet&quot;) 4.6 Publicly available LVM data Latvian State Forests geospatial data on forest infrastructure and its description. The following datasets were used in the project: roads: forest roads; forest roads to be developed; turning areas; changeover areas; driveways; drainage systems: ditches; drainage systems; renovated drainage facilities. Initially, no additional processing of this data was performed. It was used to prepare geodata products (more specifically, Landscape classification). Data were downloaded to Geodata/2024/LVM_OpenData 4.7 Soil data Directory Geodata/2024/Soils/ contains various soil related datasets that need to be combined (soil texture) or can be used individually (soil chemistry). These datasets and their location in the file tree are documented in following subchapters. 4.7.1 Soil chemistry Data on soil chemistry are obtained from European Soil Data Centre’s European Soil database (Panagos et al., 2022). Dataset decribing soil chemistry is derived from LUCAS 2009/2012 topsoil data. There are several chemical properties available for download, however not all of them were choser by experts for SDM: “P”: used; “N”: used; “K”: used; “CEC”: not used; “CN”: used; “pH_CaCl”: not used; “ph_H2O_ration_ph_CaCl”: not used; “pH_H2O”: used; “CaCO3”: used. Files were downloaded to Geodata/2024/Soils/ESDAC/chemistry/ and no preprocessing was carried out. 4.7.2 Soil texture: Europe Data on soil texture were obtained from European Soil Data Centre’s European Soil database (Panagos et al., 2022). Dataset is available as European Soil Database v2 Raster Library 1kmx1km. There are several properties available for download, TXT was used to create soil texture product. Files were downloaded to Geodata/2024/Soils/ESDAC/texture/. During the preprocessing (see code below) the layer was projected to match 10 m template with “near” as interpolation method, value 0 substituted with NA and the result wars masked and cropped to the template. Result was saved for further processing. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # ESDAC texture ---- sdTEXT=rast(&quot;./Geodata/2024/Soils/ESDAC/texture/SoilDatabaseV2_raster/ESDB-Raster-Library-1k-GeoTIFF-20240507/TEXT/TEXT.tif&quot;) plot(sdTEXT) sdTEXT=project(sdTEXT,template10,method=&quot;near&quot;) plot(sdTEXT) sdTEXT=subst(sdTEXT,0,NA) plot(sdTEXT) sdTEXT2=mask(sdTEXT,template10, filename=&quot;./RasterGrids_10m/2024/SoilTXT_ESDAC.tif&quot;, overwrite=TRUE) plot(sdTEXT2) 4.7.3 Soil texture: Farmland Topsoil characteristics in Latvia were mapped in the mid-20th century, almost exclusively in farmlands. With time, data were digitised and combined with some other information resulting in artefacts. Therefore preprocessing was necessary. The version we used was obtained from the project “GOODWATER” C1D1_Deliverable_R2. File is stored at Geodata/2024/Soils/TopSoil_LV/. Preprocessing included: reclassification based on the field GrSast: sand (1): “mS”, “mSp”, “S”, “sS”, “iS”, “Gr”, “mGr”, “D”; silt (2): “sM”, “sMp”, “sM2”, “sMp2”, “sM3”, “sMp3”; clay (3): “M”,“M1”,“Mp”,“M2”,“sM1”,“sMp1”; organic (4): “l”, “vd”, “vj”, “n”,“T”; and other categories were left unclassified. coordinate transformation to EPSG:3059; invsestigation of the resulting layer looking for anomalies by scrolling in interactive GIS, which led to exclusion of land parcels larger than 200 ha. rasterisation to 10 m template with the highest class code prevailing. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # Farmland soil texture ---- augsnes=st_read(&quot;./Geodata/2024/Soils/TopSoil_LV/soil.gpkg&quot;,layer=&quot;soilunion&quot;) # calculate parcels area augsnes$platiba_ha=as.numeric(st_area(augsnes))/10000 # only parcels with existing information on texture tuksas=augsnes %&gt;% filter(GrSast==&quot;&quot;) # classification clay=c(&quot;M&quot;,&quot;M1&quot;,&quot;Mp&quot;,&quot;M2&quot;,&quot;sM1&quot;,&quot;sMp1&quot;) silt=c(&quot;sM&quot;, &quot;sMp&quot;, &quot;sM2&quot;, &quot;sMp2&quot;, &quot;sM3&quot;, &quot;sMp3&quot;) sand=c(&quot;mS&quot;, &quot;mSp&quot;, &quot;S&quot;, &quot;sS&quot;, &quot;iS&quot;, &quot;Gr&quot;, &quot;mGr&quot;, &quot;D&quot;) peat=c(&quot;l&quot;, &quot;vd&quot;, &quot;vj&quot;, &quot;n&quot;,&quot;T&quot;) augsnes=augsnes %&gt;% mutate(grupas=case_when(GrSast %in% sand~&quot;Sand&quot;, GrSast %in% silt~&quot;Silt&quot;, GrSast %in% clay~&quot;Clay&quot;, GrSast %in% peat~&quot;organika&quot;, .default=NA)) %&gt;% mutate(grupas_num=case_when(GrSast %in% sand~&quot;1&quot;, GrSast %in% silt~&quot;2&quot;, GrSast %in% clay~&quot;3&quot;, GrSast %in% peat~&quot;4&quot;, .default=NA)) # crs augsnes_3059=st_transform(augsnes,crs=3059) # only existing texture classification augsnes_3059=augsnes_3059 %&gt;% filter(!is.na(grupas_num)) # parcels up to 200 ha augsnes_3059small=augsnes_3059 %&gt;% filter(!is.na(grupas_num)) %&gt;% filter(platiba_ha&lt;200) # rasterisation virsaugsnem2=rasterize(augsnes_3059small,template10,field=&quot;grupas_num&quot;,fun=&quot;max&quot;, filename=&quot;./RasterGrids_10m/2024/SoilTXT_topSoilLV.tif&quot;, overwrite=TRUE) plot(virsaugsnem2) 4.7.4 Soil texture: Quaternary Data on Quaternary Geology are digitised and stored by the University of Latvia Department of Geology. File is stored at Geodata/2024/Soils/QuaternaryGeology_LV/. Preprocessing included: reclassification based on field Litologija: sand (1): “smilts”, “smilts_aleiritiska”, “smilts_dunjaina”, “smilts_grants”, “smilts_grants_oli”, “smilts_grants_oli_aleirits”, “smilts_kudraina”, “smilts_videjgraudaina, malsmilts”, “smilts_videjgraudaina”~“Sand”; silt (2): “aleirits”, “aleirits_malains”, “morena”, “smilts_aleirits_mals”, “smilts_aleirits_sapropelis”, “smilts_malaina_dazadgraudaina, malsmilts”; clay (3): “mals”, “mals_aleiritisks”; organic (4): “dunjas”, “kudra”; coordinate transformation to EPSG:3059; rasterisation to 10 m template with the highest class code prevailing. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # Quarternary geology ---- kvartars=sfarrow::st_read_parquet(&quot;./Geodata/2024/Soils/QuaternaryGeology_LV/Kvartargeologija.parquet&quot;) # reclassification kvartars=kvartars %&gt;% mutate(grupas = case_when(Litologija==&quot;aleirits&quot;~&quot;Silt&quot;, Litologija==&quot;aleirits_malains&quot;~&quot;Silt&quot;, Litologija==&quot;dunjas&quot;~&quot;organika&quot;, Litologija==&quot;kudra&quot;~&quot;organika&quot;, Litologija==&quot;mals&quot;~&quot;Clay&quot;, Litologija==&quot;mals_aleiritisks&quot;~&quot;Clay&quot;, Litologija==&quot;morena&quot;~&quot;Silt&quot;, Litologija==&quot;smilts&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_aleiritiska&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_aleirits_mals&quot;~&quot;Silt&quot;, Litologija==&quot;smilts_aleirits_sapropelis&quot;~&quot;Silt&quot;, Litologija==&quot;smilts_dunjaina&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_grants&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_grants_oli&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_grants_oli_aleirits&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_kudraina&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_malaina_dazadgraudaina, malsmilts&quot;~&quot;Silt&quot;, Litologija==&quot;smilts_videjgraudaina, malsmilts&quot;~&quot;Sand&quot;, Litologija==&quot;smilts_videjgraudaina&quot;~&quot;Sand&quot;, .default=NA)) # numeric codes kvartars=kvartars %&gt;% mutate(grupas_num=case_when(grupas == &quot;Sand&quot; ~&quot;1&quot;, grupas == &quot;Silt&quot; ~&quot;2&quot;, grupas == &quot;Clay&quot; ~&quot;3&quot;, grupas == &quot;organika&quot; ~&quot;4&quot;, .default=NA)) # crs transformation kvartars_3059=st_transform(kvartars,crs=3059) # nonmissing classes kvartars_3059=kvartars_3059 %&gt;% filter(!is.na(grupas_num)) # rasterisation apaksaugsnem=rasterize(kvartars_3059,template10,field=&quot;grupas_num&quot;,fun=&quot;max&quot;, filename=&quot;./RasterGrids_10m/2024/SoilTXT_QuarternaryLV.tif&quot;, overwrite=TRUE) plot(apaksaugsnem) 4.7.5 Organic soils: SILAVA The distribution of organic soils was modelled under the EU LIFE Programme project “Demonstration of climate change mitigation potential of nutrients rich organic soils in Baltic States and Finland” at the scientific institue SILAVA. Results were downloaded and stored at Geodata/2024/Soils/OrganicSoils_SILAVA/. Even though the layer covers all of Latvia, it has visible inconsistencies, particularly stripes. These were digitised manually (as vector polygons) and masked out as a part of preprocessing. For further soil texture analysis we saved a GeoTIFF file with only presences. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # Organic Soils SILAVA ---- organika_silava=rast(&quot;./Geodata/2024/Soils/OrganicSoils_SILAVA/Silava_OrgSoils.tif&quot;) plot(organika_silava) # visible stripes # only 40+ cm deep organika_silava=ifel(organika_silava==2,1,NA) organika_silavaLV=project(organika_silava,template10) # stripes drawn manually, rasterisation silavas_telpai=st_read(&quot;./Geodata/2024/Soils/OrganicSoils_SILAVA/stripam.gpkg&quot;, layer=&quot;stripam&quot;) silavas_telpai=st_transform(silavas_telpai,crs=3059) silavas_telpai$yes=1 SilavasTelpa_10=rasterize(silavas_telpai,template10,field=&quot;yes&quot;) # presence-only layer without stripes silava_BezStripam1=ifel(organika_silavaLV==1&amp;SilavasTelpa_10==1,1,NA) silava_BezStripam=mask(silava_BezStripam1,template10) plot(silava_BezStripam) writeRaster(silava_BezStripam, &quot;./RasterGrids_10m/2024/SoilTXT_OrganicSilava.tif&quot;, overwrite=TRUE) 4.7.6 Organic soils: LU The distribution of organic soils in farmlands was modelled by the University of Latvia project “Improvement of sustainable soil resource management in agriculture: E2SOILAGRI”. From all the results we used layer YN_prognozes_smooth.tif stored at Geodata/2024/Soils/OrganicSoils_LU/. Preprocessing consisted of projecting the layer to match 10 m template. Both presences and absences were saved for further processing. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # Organic Soils LU ---- kudra_norvegi=rast(&quot;./Geodata/2024/Soils/OrganicSoils_LU/YN_prognozes_smooth.tif&quot;) kudra_norvLV=project(kudra_norvegi,template10) plot(kudra_norvLV) writeRaster(kudra_norvLV, &quot;./RasterGrids_10m/2024/SoilTXT_OrganicLU.tif&quot;, overwrite=TRUE) 4.8 Dynamic World data Dynamic World (DW) is a relatively new Earth observation system product that classifies land cover and land use (LULC) into nine categories (0=water, 1=trees, 2=grass, 3=flooded_vegetation, 4=crops, 5=shrub_and_scrub, 6=built, 7=bare, 8=snow_and_ice), for each ESA Copernicus Sentinel-2 image with identified cloudiness ≤35, allowing for filtering and various aggregations (Brown et al., 2022). DW input information - raster layer for each season in each year - was prepared on the Google Earth Engine platform (Gorelick et al., 2017) using a replication script. To use this script, you need a GEE account and project and sufficient space on Google Drive. When executing the command line, a download will be offered for a file covering the time period from the value in row 7 to the value in row 8 (the file name should be specified in row 32, its description in row 33 and the directory on Google Drive in row 31, or all of this can be specified by confirming the save). This script is not optimized for preparing all seasonal sections for all years, so in order to reproduce or expand this study, it is necessary to change it manually. Downloaded files are to be stored at Geodata/2024/DynamicWorld/RAW/. During download, it can be seen that each layer covering the whole of Latvia is divided into several sheets. This is because, in order to ensure a true zero class (class “water” rather than background), the layers are encoded as Float rather than integers. All of these tiles need to be downloaded, and the following R command lines combine them, ensuring that the coordinate system and pixels correspond to the reference raster. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # 10 m template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # DW export no GEE ---- faili=data.frame(faili=list.files(&quot;./Geodata/2024/DynamicWorld/RAW/&quot;)) faili$celi_sakums=paste0(&quot;./Geodata/2024/DynamicWorld/RAW/&quot;,faili$faili) # prepping ---- faili=faili %&gt;% separate(faili,into=c(&quot;DW&quot;,&quot;gads&quot;,&quot;periods&quot;,&quot;parejais&quot;),sep=&quot;_&quot;,remove = FALSE) %&gt;% mutate(unikalais=paste0(DW,&quot;_&quot;,gads,&quot;_&quot;,periods), mosaic_name=paste0(unikalais,&quot;.tif&quot;), masaic_cels=paste0(&quot;./Geodata/2024/DynamicWorld/&quot;,mosaic_name)) # every layer consists of two tiles unikalie=levels(factor(faili$unikalais)) min(table(faili$unikalais)) max(table(faili$unikalais)) # job for(i in seq_along(unikalie)){ unikalais=faili %&gt;% filter(unikalais==unikalie[i]) beigu_cels=unique(unikalais$masaic_cels) print(i) viens=rast(unikalais$celi_sakums[1]) divi=rast(unikalais$celi_sakums[2]) viens2=project(viens,template10) divi2=project(divi,template10) mozaika=mosaic(viens2,divi2,fun=&quot;first&quot;) maskets=mask(mozaika,template10, filename=beigu_cels, overwrite=TRUE) print(beigu_cels) } 4.9 The Global Forest Watch The Global Forest Watch (GFW) is a widely known product that describes tree canopy cover in 2000, its annual growth from 2001 to 2012, and its annual loss from 2001 to the current version, which is updated annually (Hansen et al., 2013). The data is available both on the project website and on GEE, where it was developed. This project used v1.12, in which the last year of tree loss dating was 2024, preparing it for download on the GEE platform with this replication script. To use this script, you need a GEE account and project and sufficient space on Google Drive. When executing the command lines, you will be offered to download the file, which you need to save to Google Drive. After executing the command lines and preparing the results in Google Drive, four files become available for download. The location to download them is Geodata/2024/Trees/GFW/RAW/. After download, these files need to be projected to match the reference raster. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # 10 m rastra template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # TreeCoverLoss ---- treecoverloss=rast(&quot;./Geodata/2024/Trees/GFW/RAW/TreeCoverLoss_v1_12.tif&quot;) tcl=ifel(treecoverloss&lt;1,NA,treecoverloss) tcl2=terra::project(tcl,paraugs) tcl3=mask(tcl2,paraugs,filename=&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;,overwrite=TRUE) 4.10 Palsar The Palsar Forests resource is based on PALSAR-2 synthetic aperture radar (SAR) reflectance classification of forest and non-forest land with a pixel resolution of 25 m. Forests are classified as areas of at least 0.5 ha covered with trees, where tree cover (at least 5 m high) is at least 10% (Shimada et al., 2013). The data is available at GEE. This project used a 4-class version (1=Dense Forest, 2=Non-dense Forest, 3=Non-Forest, 4=Water), in which the last tree cover dating year was 2020, prepared for download on the GEE platform with this replication script. To use this script, you need a GEE account and project and sufficient space on Google Drive. When executing the command lines, you will be offered to download the file, which you need to save to Google Drive. After executing the command lines and preparing the results in Google Drive, four files become available for download. The location to download them is Geodata/2024/Trees/Palsar/RAW/. After download, these files need to be projected to match the reference raster and merged. In this resource, trees are coded into two groups: 1=Dense Forest and 2=Non-dense Forest, which need to be merged and the rest converted to missing values (see code below). Although this resource reflects conditions in 2020 rather than 2024, we used it because The Global Forest Watch data provides reliable data on canopy loss, but the appearance of canopy cover is not so rapid that there would be significant changes over a four-year period. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # 10 m rastra template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # PALSAR Forests ---- fnf1=rast(&quot;./Geodata/2024/Trees/Palsar/RAW/ForestNonForest-0000023296-0000023296.tif&quot;) fnf2=rast(&quot;./Geodata/2024/Trees/Palsar/RAW/ForestNonForest-0000023296-0000000000.tif&quot;) fnf3=rast(&quot;./Geodata/2024/Trees/Palsar/RAW/ForestNonForest-0000000000-0000023296.tif&quot;) fnf4=rast(&quot;./Geodata/2024/Trees/Palsar/RAW/ForestNonForest-0000000000-0000000000.tif&quot;) fnf1p=terra::project(fnf1,template10) fnf2p=terra::project(fnf2,template10) fnf3p=terra::project(fnf3,template10) fnf4p=terra::project(fnf4,template10) fnfA=terra::merge(fnf1p,fnf2p) fnfB=terra::merge(fnfA,fnf3p) fnfC=terra::merge(fnfB,fnf4p) plot(fnfC) fnf_X=ifel(fnfC&lt;=2&amp;fnfC&gt;=1,1,NA) plot(fnf_X) fnf_XX=mask(fnf_X,template10, filename=&quot;./Geodata/2024/Trees/Palsar/Palsar_Forests.tif&quot;, overwrite=TRUE) 4.11 CHELSA v2.1 Climatologies at high resolution for the Earth’s land surface areas (CHELSA) is 30 arc second global downscaled climate data set (Karger et al., 2017). The temperature algorithm is based on statistical downscaling of atmospheric temperatures. The precipitation algorithm incorporates orographic predictors including wind fields, valley exposition, and boundary layer height, with a subsequent bias correction. CHELSA climatological data has a similar accuracy as other products for temperature, but its predictions of precipitation patterns are better (Karger et al., 2017). Data (1980-2010 baseline) are freely available for download from homepage forwarding to download server, providing download links for selected products. There is also technical specification available, to decode layer names (https://chelsa-climate.org/wp-admin/download-page/CHELSA_tech_specification_V2.pdf). The download links we used together with the renaming scheme are included with this document. The following command lines perform download, crop to the extent of Latvia (using 1 km vector grid) and save the files for further processing described with other EGVs. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(curl)) {install.packages(&quot;curl&quot;); require(curl)} # templates ---- # 1km grid tikls1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) telpai=tikls1km %&gt;% mutate(yes=1) %&gt;% summarise(yes=max(yes)) %&gt;% st_buffer(.,dist=10000) # download and crop ---- links_names=read_csv(&quot;./Geodata/2024/CHELSA/CHELSAdownload_rename.csv&quot;) links_names=links_names %&gt;% filter(todownload==1) for(i in seq_along(links_names$localname)){ print(i) sakums=Sys.time() links=links_names$weblocation[i] saving1=&quot;./Geodata/2024/CHELSA/draza.tif&quot; saving2=paste0(&quot;./Geodata/2024/CHELSA/&quot;,links_names$localname[i]) curl_download(url=links,destfile = saving1,quiet = FALSE) fails=rast(saving1) telpa=st_transform(telpai,crs=st_crs(fails)) nogriezts=crop(fails,telpa, filename=saving2, overwrite=TRUE) unlink(saving1) beigas=Sys.time() ilgums=beigas-sakums print(ilgums) } 4.12 HydroClim data HydroClim is a near-global freshwater-specific environmental variable dataset, created for biodiversity analysis at 1 km resolution (Domisch et al., 2015). Dataset contains many different variables along the HydroSHEDS river network (Lehner et al., 2008), including upstream climate recalculated from worldclim (Hijmans et al., 2005). We downloaded (to Geodata/2024/HydroClim/) averaged upstream climate from Zenodo repository (available also from Dryad) and cropped to the extent of Latvia and renamed files for further processing with the code below. Renaming scheme is published with document. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) tikls1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) # reading HydroClim ---- videjie=terra::rast(&quot;./Geodata/2024/HydroClim/hydroclim_average+sum.nc&quot;) # reading dictionary ----- slanu_nosaukumi=read_csv(&quot;./Geodata/2024/HydroClim/HydroClim_renaming.csv&quot;) # cropping --- tikls1km_reproj=st_transform(tikls1km,crs=st_crs(videjie)) telpai=tikls1km %&gt;% mutate(yes=1) %&gt;% summarise(yes=max(yes)) %&gt;% st_buffer(.,dist=10000) %&gt;% st_transform(.,crs=st_crs(videjie)) videjie=terra::crop(videjie,telpai) # layer names ---- names(videjie)=slanu_nosaukumi$local_name # saving files ---- for(i in seq_along(slanu_nosaukumi$local_name)){ nosaukumam=slanu_nosaukumi$local_name[i] writeRaster(videjie[[i]], paste0(&quot;./Geodata/2024/HydroClim/&quot;,nosaukumam), overwrite=TRUE) } The raster dataset contains values only where large enough rivers are detected in HydroSHEDS. However, for species distribution modelling in this project we need continuously covered raster surfaces. For necessary geoprocessing to create such surfaces, we downloaded also HydroBASINS (Lehner and Grill, 2013) dataset to Geodata/2024/HydroClim/. These procedures were EGV-specific and are described with other EGVs. 4.13 Sentinel-2 indices The European Space Agency (ESA) Copernicus program’s Sentinel-2 mission is a constellation of two (three since 09/05/2024) identical satellites orbiting in the same orbit. The first satellite, Sentinel-2A, entered its orbit and underwent calibration tests on 2015-06-23, the second (Sentinel-2B) on 2017-03-07, with the first images available earlier. Each satellite captures high-resolution images (from 10 m (at the equator) pixel resolution) in 13 spectral channels with a return time of up to 5 days (more frequently closer to the poles) (https://www.esa.int/Applications/Observing_the_Earth/Copernicus/Sentinel-2). The data from this mission is freely available, including on the Google Earth Engine platform (Gorelick et al., 2017) for various large-scale pre-processing and analysis. We used the harmonized Level-2A (https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED#description) product, applying a cloud mask that includes not only cloud filtering but also shadow filtering. For each filtered image (cloud-free, April-October, 2020-2024), we computed the normalized difference vegetation index (NDVI), the normalized difference moisture index (NDMI), and the normalized difference water index (NDWI) as well as various metrics. A replication script can be used to prepare the data. To use this script, you need a GEE account and project and sufficient space on Google Drive. When executing the command lines, the following files will be offered for download: NDVI_median-ST-[runtag, 20250820 by default] - NDVI short-term median (2020-2024) of annual medians (April to October) NDVI_p25-ST-[runtag, 20250820 by default] - NDVI short-term median (2020-2024) of annual 25th percentiles (April to October) NDVI_p75-ST-[runtag, 20250820 by default]- NDVI short-term median (2020-2024) of annual 75th percentiles (April to October) NDVI_iqr-ST-[runtag, 20250820 by default] - NDVI short-term median (2020-2024) of inter-quartile ranges (April to October) NDVI_median-LY-[runtag, 20250820 by default] - NDVI last-years (2024) median (April to October) NDMI_median-ST-[runtag, 20250820 by default] - NDMI short-term median (2020-2024) of annual medians (April to October) NDMI_p25-ST-[runtag, 20250820 by default] - NDMI short-term median (2020-2024) of annual 25th percentiles (April to October) NDMI_p75-ST-[runtag, 20250820 by default] - NDMI short-term median (2020-2024) of annual 75th percentiles (April to October) NDMI_iqr-ST-[runtag, 20250820 by default] - NDMI short-term median (2020-2024) of inter-quartile ranges (April to October) NDMI_median-LY-[runtag, 20250820 by default] - NDMI last-years (2024) median (April to October) NDWI_median-ST-[runtag, 20250820 by default] - NDMI short-term median (2020-2024) of annual medians (April to October) NDWI_p25-ST-[runtag, 20250820 by default] - NDWI short-term median (2020-2024) of annual 25th percentiles (April to October) NDWI_p75-ST-[runtag, 20250820 by default] - NDWI short-term median (2020-2024) of annual 75th percentiles (April to October) NDWI_iqr-ST-[runtag, 20250820 by default] - NDWI short-term median (2020-2024) of inter-quartile ranges (April to October) NDWI_median-LY-[runtag, 20250820 by default] - NDWI last-years (2024) median (April to October) After executing the command line and preparing the results in Google Drive, it can be seen that each layer covering the whole of Latvia is divided into several tiles. This is because the layers are encoded as Float and exceed 4 GB in size before GeoTIFF compression. All of these files need to be downloaded and located at Geodata/2024/S2indices/RAW. The following R commands combine them, ensuring the coordinate systems and its naming, and pixels match the reference raster, while renaming files to EO_[index]-[term: ST or LY][statistic]. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # 10 m raster template ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # Fails as exported from GEE ---- faili=data.frame(fails=list.files(&quot;./Geodata/2024/S2indices/RAW/&quot;,pattern = &quot;.tif&quot;)) faili$celi_sakums=paste0(&quot;./Geodata/2024/S2indices/RAW/&quot;,faili$fails) # file names ---- faili=faili %&gt;% separate(fails,into=c(&quot;nosaukums&quot;,&quot;vidus&quot;,&quot;beigas&quot;),sep=&quot;-&quot;,remove = FALSE) %&gt;% mutate(mosaic_name=paste0(&quot;EO_&quot;,nosaukums,&quot;-&quot;,beigas,tolower(vidus),&quot;.tif&quot;), masaic_cels=paste0(&quot;./Geodata/2024/S2indices/Mosaics/&quot;,mosaic_name)) unikalie=levels(factor(faili$mosaic_name)) min(table(faili$mosaic_name)) max(table(faili$mosaic_name)) # preparation of mosaics ---- for(i in seq_along(unikalie)){ sakums=Sys.time() unikalais=faili %&gt;% filter(mosaic_name==unikalie[i]) beigu_cels=unique(unikalais$masaic_cels) print(i) # there are exactly 2 tiles per file viens=rast(unikalais$celi_sakums[1]) divi=rast(unikalais$celi_sakums[2]) viens2=terra::project(viens,template10) divi2=terra::project(divi,template10) mozaika=terra::merge(viens2,divi2) maskets=mask(mozaika,template10, filename=beigu_cels,overwrite=TRUE, gdal=c(&quot;COMPRESS=LZW&quot;,&quot;TILED=YES&quot;,&quot;BIGTIFF=IF_SAFER&quot;), datatype=&quot;FLT4S&quot;, NAflag=NA) plot(maskets,main=unikalie[i]) print(beigu_cels) beigas=Sys.time() ilgums=beigas-sakums print(ilgums) } 4.14 Waste and garbage disposal sites, landfills Information on landfills has been compiled from The Ministry of Smart Administration and Regional Development and Latvian Environment, Geology and Meteorology Centre’s report, “Report on landfills in Latvia in 2023” listed landfills and their addresses. The coordinates required for the preparation of EGVs were obtained by combining the resources https://www.google.com/maps and https://balticmaps.eu/. In addition to the resources mentioned above, an object was added at the address “Dardedzes C, Mārupes pag., Mārupes nov., Latvia, LV-2166”. In addition, information from the State Environmental Service on separated waste and deposit packaging collection points was used, exporting it to an Excel file. Both data sets were combined into a single file and added to this material. 4.15 Digital elevation/terrain models With the publication of continuous aerial laser scanning data for the territory of Latvia (https://www.lgia.gov.lv/lv/digitalie-augstuma-modeli-0), various high-resolution (1 m and higher) digital surface models (DSM) and digital elevation models (DEM) have been developed. Since the input data was the same in all cases, the values of these (corresponding) models were identical across almost the entire territory of the country. However, airborne laser scanning data (1) was not available for the entire territory of the country, and (2) there were differences between the models in terms of filling (availability of values) outside inland waters and (3) filling of water bodies themselves. However, for areas covered by data on land, the values were almost identical. Pearson’s correlation coefficients between the DEMs developed by LU ĢZZF, LVMI Silava, and LĢIA were greater than 0.999999. The two DEMs (LU ĢZZF and LVMI Silava) were combined (arithmetic mean) within the University of Latvia project “Improvement of sustainable soil resource management in agriculture: E2SOILAGRI”, was used as the working DEM. The resolution of this DEM is 1 m, which is too detailed for species distribution modeling input data, therefore the layer was designed to correspond to the reference 10 m raster. When investigating the combined DEM, there were clearly visible areas with no data. This has been solved by using the DEM with a resolution of 10 m developed by Māris Nartišs (LU ĢZZF) in 2018, which covers the entire territory of Latvia without gaps. To avoid sharp edges and ensure smooth transitions, we created an arithmetic mean layer covering all of Latvia and aligned to the reference raster. A slope layer has also been created from this raster, which is designed in accordance with the reference. The slope is expressed in degrees and calculated using the 8-neighbor approach. The same applies to the aspect or slope direction. Code # libs if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} # reference template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # LiDAR DEM 1 m to 10 m lapas_1m=data.frame(faili=list.files(&quot;./Geodata/2024/DEM/meanDEM_1mOLD/&quot;,pattern=&quot;*.tif$&quot;)) lapas_1m$numurs=substr(lapas_1m$faili,10,13) lapas_1m$cels1=paste0(&quot;./Geodata/2024/DEM/meanDEM_1mOLD/&quot;,lapas_1m$faili) lapas_1m$cels2=paste0(&quot;./Geodata/2024/DEM/meanDEM_10mOLD/&quot;,lapas_1m$faili) kvadrati=st_read(dsn=&quot;GIS_Latvija10.2.gdb&quot;,layer=&quot;tks93_50000&quot;) kvadrati$name=as.character(kvadrati$num50tk) moz2=rast(&quot;./Geodata/2024/DEM/Nartiss_visa_Latvija/dem10_20_kopa.tif&quot;) for(i in 1:length(kvadrati$name)){ kvadrats=kvadrati[i,] nosaukums=kvadrats$name telpa=terra::ext(kvadrats) paraugs=crop(template10,telpa) nart=crop(moz2,telpa) nart2=project(nart,paraugs,mask=TRUE) dem1m=lapas_1m[lapas_1m$numurs==kvadrats$name,] if(nrow(dem1m)&gt;0){ sakumcels=dem1m$cels1 dem=rast(sakumcels) reproj=project(dem,paraugs,mask=TRUE,method=&quot;bilinear&quot;,use_gdal=TRUE) videjais &lt;- ifel(is.na(nart2),nart2,ifel(is.na(reproj),nart2, app(c(nart2,reproj), mean))) writeRaster(videjais,overwrite=TRUE, filename=paste0(&quot;./Geodata/2024/DEM/meanDEM_10m/&quot;,&quot;vidDEM_&quot;, nosaukums,&quot;.tif&quot;)) } else{ writeRaster(nart2,overwrite=TRUE, filename=paste0(&quot;./Geodata/2024/DEM/meanDEM_10m/&quot;,&quot;vidDEM_&quot;, nosaukums,&quot;.tif&quot;)) } } # vrt un mozaic lapas_10=data.frame(faili=list.files(&quot;./Geodata/2024/DEM/meanDEM_10m/&quot;,pattern=&quot;*.tif$&quot;)) lapas_10$celi1=paste0(&quot;./Geodata/2024/DEM/meanDEM_10m/&quot;,lapas_10$faili) mozaikai=vrt(lapas_10$celi1,overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/vrtDEM_10m.tif&quot;) mozaika=rast(&quot;./Geodata/2024/DEM/vrtDEM_10m.tif&quot;) writeRaster(mozaika,&quot;./Geodata/2024/DEM/mozDEM_10m.tif&quot;) ## slope reljefs=rast(&quot;./Geodata/2024/DEM/mozDEM_10m.tif&quot;) slipumi=terrain(reljefs, v=&quot;slope&quot;, neighbors=8, unit=&quot;degrees&quot;, filename=&quot;./Geodata/2024/DEM/Terrain_Slope_10m.tif&quot;, overwrite=TRUE) ## aspect reljefs=rast(&quot;./Geodata/2024/DEM/mozDEM_10m.tif&quot;) virzieni=terrain(reljefs, v=&quot;aspect&quot;, neighbors=8, unit=&quot;degrees&quot;, filename=&quot;./Geodata/2024/DEM/Terrain_Aspect_10m.tif&quot;, overwrite=TRUE) 4.16 Latvian Exclusive Economic Zone polygon The waters of Latvia’s Exclusive Economic Zone were obtained from the HELCOM map and data service. After downloading, this line file was analogically connected to the coastline file obtained from the same resource. 4.17 Bogs and Mires: EDI Data (training and classification) used in project “Remote Sensing and Machine Learning for Peatland Habitat Monitoring (PurvEO)” by the Institute of electronics and computer science were stored at Geodata/2024/Bogs_EDI. Preprocessing was carried out to create two layers: EDI_BogsYN.tif: training and classification results on open raised bogs (EU protected habitat codes 7110 and 7120) and locations where one of those overlapped with transitional mires (EU protected habitat code 7140); EDI_TransitionalMiresYN.tif: training and classification results on transitional mires (EU protected habitat code 7140) with no overlap with open rised bogs. Code # libs if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # Templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) nulles10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # Bogs ---- neatklata71107120=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/Neatklata_purviem_raksturiga_zemsedze_7110_7120.tif&quot;) neatklata71107120=ifel(neatklata71107120&gt;0,1,NA) plot(neatklata71107120) neatklata7140=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/Neatklata_purviem_raksturiga_zemsedze_7140.tif&quot;) neatklata7140=ifel(neatklata7140&gt;0,1,NA) raskturiga71107120=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/Purviem_neraksturiga_zemsedze_7110_7120.tif&quot;) raskturiga71107120=ifel(raskturiga71107120&gt;0,1,NA) raksturiga7140=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/Purviem_neraksturiga_zemsedze_7140.tif&quot;) raksturiga7140=ifel(raksturiga7140&gt;0,1,NA) labels71107120=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/latvija_Labels_B7110_7120.tif&quot;) labels71107120=ifel(labels71107120&gt;0,1,NA) labels7140=rast(&quot;./Geodata/2024/Bogs_EDI/purvi_EDI_projekts/purvi/!LV_kopa_apv1020_30_05_2022/!LV_kopa_apv1020_30_05_2022/latvija_Labels_B7140.tif&quot;) labels7140=ifel(labels7140&gt;0,1,NA) augstie=cover(cover(neatklata71107120,raskturiga71107120),labels71107120) parejas=cover(cover(neatklata7140,raksturiga7140),labels7140) tikai_parejas=ifel(parejas==1&amp;augstie==1,NA,parejas) sunainie=ifel(parejas==1&amp;augstie==1,parejas,NA) sunu_purvi=cover(augstie,sunainie) sunu_proj=project(sunu_purvi,template10) sunuYN=cover(sunu_proj,nulles10) plot(sunuYN) writeRaster(sunuYN, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/EDI_BogsYN.tif&quot;) # Transitional mires ---- parejas_proj=project(tikai_parejas,template10) parejasYN=cover(parejas_proj,nulles10) plot(parejasYN) writeRaster(parejasYN, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif&quot;) References Brown, C.F., Brumby, S.P., Guzder-Williams, B., Birch, T., Hyde, S.B., Mazzariello, J., Czerwinski, W., Pasquarella, V.J., Haertel, R., Ilyushchenko, S., Schwehr, K., Weisse, M., Stolle, F., Hanson, C., Guinan, O., Moore, R., Tait, A.M., 2022. Dynamic World, Near real-time global 10 m land use land cover mapping. Scientific Data 9, 251. https://doi.org/10.1038/s41597-022-01307-4 Domisch, S., Amatulli, G., Jetz, W., 2015. Near-global freshwater-specific environmental variables for biodiversity analyses in 1 km resolution. Scientific Data 2:150073, 1–13. https://doi.org/10.1038/sdata.2015.73 Gorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., Moore, R., 2017. Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment 202, 18–27. https://doi.org/10.1016/j.rse.2017.06.031 Hansen, M.C., Potapov, P.V., Moore, R., Hancher, M., Turubanova, S.A., Tyukavina, A., Thau, D., Stehman, S.V., Goetz, S.J., Loveland, T.R., Kommareddy, A., Egorov, A., Chini, L., Justice, C.O., Townshend, J.R.G., 2013. High-resolution Global maps of 21st-century forest cover change. Science 342, 850–853. https://doi.org/10.1126/science.1244693 Hijmans, R.J., Cameron, S.E., Parra, J.L., Jones, P.G., Jarvis, A., 2005. Very high resolution interpolated climate surfaces for global land areas. International Journal of Climatology 25, 1965–1978. https://doi.org/10.1002/joc.1276 Karger, D.N., Conrad, O., Böhner, J., Kawohl, T., Kreft, H., Soria-Auza, R.W., Zimmermann, N.E., Linder, H.P., Kessler, M., 2017. Data Descriptor: Climatologies at high resolution for the earth’s land surface areas. Scientific Data 4:170122. https://doi.org/10.1038/sdata.2017.122 Lehner, B., Grill, G., 2013. Global river hydrography and network routing: Baseline data and new approaches to study the world’s large river systems. Hydrological Processes 27, 2171–2186. https://doi.org/10.1002/hyp.9740 Lehner, B., Verdin, K., Jarvis, A., 2008. New global hydrography derived from spaceborne elevation data. Eos, Transactions, American Geophysical Union 89, 93–94. https://doi.org/10.1029/2008EO100001 Panagos, P., Liedekerke, M.V., Borrelli, P., Köninger, J., Ballabio, C., Orgiazzi, A., Lugato, E., Liakos, L., Hervas, J., Jones, A., Montanarella, L., 2022. European Soil Data Centre 2.0: Soil data and knowledge in support of the EU policies. European Journal of Soil Science 73, e13315. https://doi.org/10.1111/ejss.13315 Shimada, M., Itoh, T., Motooka, T., Watanabe, M., Shiraishi, T., Thapa, R., Lucas, R., 2013. New global forest/non-forest maps from ALOS PALSAR data (2007–2010). Remote Sensing of Environment 155, 13–31. https://doi.org/10.1016/j.rse.2014.04.014 "],["Ch05.html", "5 Geodata products 5.1 Terrain products 5.2 Soil texture product 5.3 Landscape classification 5.4 Landscape diversity", " 5 Geodata products Some raw data need extensive processing prior to EGVs creation. Often, EGVs relay on transforming raw geodata into intermediate products; in other cases, an EGV itself could be created from raw geodata, but it has to be spatially restricted to certain locations. This chapter describes these geodata products and the procedures involved in creating them. 5.1 Terrain products In order to develop the topographic wetness index (TWI) and non-drainage depressions, it was necessary to address water flow in the environment. This is a multi-step procedure that is logical and reliable in mountainous areas and in environments with little hydrological impact. However, in the context of Latvia, this was challenging. These challenges can be addressed in various ways. For example, if reliable (accurate) information on the exact locations of rivers and ditches were available, it could be incorporated into the terrain. Unfortunately, there is no sufficiently accurate information available. Therefore, information about network structures from the Melioration Cadastre Information System database buffered by 10 m, bridges from the topographic map and transport structures and bridges from LVM Open Data were used to address the challenges (both buffered by 10 m). Information about the minimum height above sea level was incorporated into the DEM to be used in further processing. Code # libs if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)){install.packages(&quot;exactextractr&quot;);require(exactextractr)} # reference template=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # part one ---- # dem raster reljefs=rast(&quot;./Geodata/2024/DEM/mozDEM_10m.tif&quot;) # drainage network structures st_layers(&quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;) dtb=st_read(&quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;,layer=&quot;DrenazasTiklaBuves&quot;) dtb_buffer=st_buffer(dtb,dist=10) # bridges tiltiL=sfarrow::st_read_parquet(&quot;./Geodata/2024/TopographicMap/BridgeL_COMB.parquet&quot;) tiltiL_buffer=st_buffer(tiltiL,dist=30) tiltiP=sfarrow::st_read_parquet(&quot;./Geodata/2024/TopographicMap/BridgeL_COMB.parquet&quot;) tiltiP_buffer=st_buffer(tiltiP,dist=30) # LVM lvm_caurtekas=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_CAURTEKAS/LVM_CAURTEKAS_Shape.shp&quot;) lvm_buffer=st_buffer(lvm_caurtekas,dist=30) # buffers st_geometry(dtb_buffer)=&quot;geometry&quot; st_geometry(tiltiL_buffer)=&quot;geometry&quot; st_geometry(tiltiP_buffer)=&quot;geometry&quot; st_geometry(lvm_buffer)=&quot;geometry&quot; visi_buferi=bind_rows(dtb_buffer,tiltiL_buffer,tiltiP_buffer,lvm_buffer) # incorporation in DEM visi_buferi$vertiba=exactextractr::exact_extract(reljefs,visi_buferi,&quot;min&quot;) caurumi=fasterize::fasterize(visi_buferi,templis,field=&quot;vertiba&quot;) caurumi2=rast(caurumi) caurumains=app(c(reljefs,caurumi2),fun=&quot;min&quot;,na.rm=TRUE, overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/caurtDEM_10m.tif&quot;) # cleaning rm(caurumi) rm(caurumi2) rm(dtb) rm(dtb_buffer) rm(lvm_buffer) rm(lvm_caurtekas) rm(reljefs) rm(tiltiL) rm(tiltiL_buffer) rm(tiltiP) rm(tiltiP_buffer) rm(visi_buferi) rm(caurumains) This DEM was then used for geoprocessing to identify terrain depressions and determine the topographic wetness index (TWI): drainage depressions and their depth layers were prepared after incorporating flow breaks; to calculate the topographic wetness index, terrain depressions without runoff were reviewed, allowing up to ten cell breaks in areas of lower resistance; the rest were filled in; for additional security, the procedure of the second step was repeated to search for and fill in terrain depressions (Wang and Liu, 2006); the result of the third step was used to determine the specific catchment area using D-infinity flow direction; by combining the specific catchment area layer with the slope layer, the topographic wetness index was calculated. A graphical evaluation revealed individual extreme values, which were limited to 20. Code # libs if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(whitebox)){install.packages(&quot;whitebox&quot;);require(whitebox)} # reference template=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # part two ---- # DEM caurumainis=rast(&quot;./Geodata/2024/DEM/caurtDEM_10m.tif&quot;) # Sinks ## breached sinks and depth in sinks wbt_breach_depressions_least_cost( dem = &quot;./Geodata/2024/DEM/caurtDEM_10m.tif&quot;, output = &quot;./Geodata/2024/DEM/caurtDEM_breachedNF.tif&quot;, dist = 10, fill = FALSE) wbt_depth_in_sink(dem=&quot;./Geodata/2024/DEM/caurtDEM_breachedNF.tif&quot;, output=&quot;./Geodata/2024/DEM/Terrain_DiS_breached_10m.tif&quot;, zero_background = TRUE) wbt_sink(input = &quot;./Geodata/2024/DEM/caurtDEM_breachedNF.tif&quot;, output = &quot;./Geodata/2024/DEM/Terrain_Sink_breached_10m.tif&quot;, verbose_mode = FALSE,zero_background = TRUE) sinks=rast(&quot;./Geodata/2024/DEM/Terrain_Sink_breached_10m.tif&quot;) sinks2 &lt;- ifel(sinks &gt;= 1, 1, sinks, filename=&quot;./Geodata/2024/DEM/Terrain_SinkYN_breached_10m.tif&quot;) plot(sinks2) unlink(&quot;./Geodata/2024/DEM/Terrain_Sink_breached_10m.tif&quot;) # TWI ## breaching wbt_breach_depressions_least_cost( dem = &quot;./Geodata/2024/DEM/caurtDEM_10m.tif&quot;, output = &quot;./Geodata/2024/DEM/caurtDEM_breachedF.tif&quot;, dist = 10, fill = TRUE) ### filling wbt_fill_depressions_wang_and_liu( dem = &quot;./Geodata/2024/DEM/caurtDEM_breachedF.tif&quot;, output = &quot;./Geodata/2024/DEM/caurtDEM_BreachFill.tif&quot; ) ### (d inf) flow direction wbt_d_inf_flow_accumulation(input = &quot;./Geodata/2024/DEM/caurtDEM_BreachFill.tif&quot;, output = &quot;./Geodata/2024/DEM/caurtDEM_DInfAccu_SCA.tif&quot;, out_type = &quot;Specific Contributing Area&quot;) ### twi wbt_wetness_index(sca = &quot;./Geodata/2024/DEM/caurtDEM_DInfAccu_SCA.tif&quot;, slope = &quot;./Geodata/2024/DEM/Terrain_Slope_10m.tif&quot;, output = &quot;./Geodata/2024/DEM/TWI_caurtDEM.tif&quot;) twi=rast(&quot;./Geodata/2024/DEM/TWI_caurtDEM.tif&quot;) hist(twi) # excessively large values plot(twi) twi2=ifel(twi&gt;20,20,twi) plot(twi2) twi2x=ifel(is.na(twi2)&amp;!is.na(template),20,twi2) # Lake Burtnieks writeRaster(twi2x,filename=&quot;./Geodata/2024/DEM/Terrain_TWI_lim20_caurtDEM.tif&quot;) # cleaning rm(sinks) rm(sinks2) rm(caurumainis) rm(twi) rm(twi2) Since the initial DEM input was created by filling in water bodies using interpolation methods, the water bodies show a pronounced terrain, which had to be removed. This was done by overlaying arithmetic mean values of these polygons. Code # libs if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)){install.packages(&quot;exactextractr&quot;);require(exactextractr)} # reference template=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) # third part ---- # dealing with waterbodies udeni=sfarrow::st_read_parquet(&quot;./Geodata/2024/TopographicMap/HidroA_COMB.parquet&quot;) slope=rast(&quot;./Geodata/2024/DEM/Terrain_Slope_10m.tif&quot;) aspect=rast(&quot;./Geodata/2024/DEM/Terrain_Aspect_10m.tif&quot;) twi=rast(&quot;./Geodata/2024/DEM/Terrain_TWI_lim20_caurtDEM.tif&quot;) dis=rast(&quot;./Geodata/2024/DEM/Terrain_DiS_breached_10m.tif&quot;) # average per waterbody udeni$slopes=exactextractr::exact_extract(slope,udeni,&quot;mean&quot;) caurumi_slope=fasterize::fasterize(udeni,templis,field=&quot;slopes&quot;) caurumi_slope2=rast(caurumi_slope) caurumains_slope=app(c(caurumi_slope2,slope),fun=&quot;first&quot;,na.rm=TRUE, overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/Terrain_Slope_udeni_10m.tif&quot;) caurumains_slope=terra::rast(&quot;./Geodata/2024/DEM/Terrain_Slope_udeni_10m.tif&quot;) caurumains_slope2=terra::mask(caurumains_slope,template, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif&quot;) rm(slope) rm(caurumi_slope) rm(caurumi_slope2) rm(caurumains_slope) rm(caurumains_slope2) udeni$aspect=exactextractr::exact_extract(aspect,udeni,&quot;mean&quot;) caurumi_aspect=fasterize::fasterize(udeni,templis,field=&quot;aspect&quot;) caurumi_aspect2=rast(caurumi_aspect) caurumi_aspect=app(c(caurumi_aspect2,aspect),fun=&quot;first&quot;,na.rm=TRUE, overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/Terrain_Aspect_udeni_10m.tif&quot;) caurumains_aspect=terra::rast(&quot;./Geodata/2024/DEM/Terrain_Aspect_udeni_10m.tif&quot;) caurumains_aspect2=terra::mask(caurumains_aspect,template, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif&quot;) rm(aspect) rm(caurumi_aspect) rm(caurumi_aspect2) rm(caurumains_aspect) rm(caurumains_aspect2) udeni$twis=exactextractr::exact_extract(twi,udeni,&quot;mean&quot;) caurumi_TWI=fasterize::fasterize(udeni,templis,field=&quot;twis&quot;) caurumi_TWI2=rast(caurumi_TWI) caurumains_TWI=app(c(caurumi_TWI2,twi),fun=&quot;first&quot;,na.rm=TRUE, overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/Terrain_TWI_udeni_10m.tif&quot;) caurumains_TWI=terra::rast(&quot;./Geodata/2024/DEM/Terrain_TWI_udeni_10m.tif&quot;) caurumains_TWI2=terra::mask(caurumains_TWI,template, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/Terrain_TWI_udeni2_10m.tif&quot;) rm(twi) rm(caurumi_TWI) rm(caurumi_TWI2) rm(caurumains_TWI) rm(caurumains_TWI2) udeni$disi=exactextractr::exact_extract(dis,udeni,&quot;mean&quot;) caurumi_DiS=fasterize::fasterize(udeni,templis,field=&quot;disi&quot;) caurumi_DiS2=rast(caurumi_DiS) caurumains_DiS=app(c(caurumi_DiS2,dis),fun=&quot;first&quot;,na.rm=TRUE, overwrite=TRUE, filename=&quot;./Geodata/2024/DEM/Terrain_DiS_udeni_10m.tif&quot;) caurumains_DiS=terra::rast(&quot;./Geodata/2024/DEM/Terrain_DiS_udeni_10m.tif&quot;) caurumains_DiS2=terra::mask(caurumains_DiS,template, overwrite=TRUE, filename=&quot;./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif&quot;) rm(udeni) rm(dis) rm(caurumi_DiS) rm(caurumi_DiS2) rm(caurumains_DiS) rm(caurumains_DiS2) # cleaning unlink(&quot;./Geodata/2024/DEM/caurtDEM_breachedF.tif&quot;) unlink(&quot;./Geodata/2024/DEM/caurtDEM_breachedNF.tif&quot;) unlink(&quot;./Geodata/2024/DEM/caurtDEM_BreachFill.tif&quot;) unlink(&quot;./Geodata/2024/DEM/caurtDEM_DInfAccu_SCA.tif&quot;) unlink(&quot;./Geodata/2024/DEM/Terrain_Slope_udeni_10m.tif&quot;) unlink(&quot;./Geodata/2024/DEM/Terrain_Aspect_udeni_10m.tif&quot;) unlink(&quot;./Geodata/2024/DEM/Terrain_DiS_udeni_10m.tif&quot;) unlink(&quot;./Geodata/2024/DEM/Terrain_TWI_udeni_10m.tif&quot;) 5.2 Soil texture product In this section, a unified layer describing categorised soil texture (sand = 1, silt = 2, clay = 3, organic = 4) was created from multiple preprocessed soil texture data sources. The creation of the soil texture product consisted of multiple overlay steps. These steps, along with the processed geodata used, are illustrated as follows: the base soil texture source was Soil texture layer from the European Soil Database. This layer had to be reclassified to match the other layers, as this was not performed during preprocessing; the layer from the first step was overlaid with the Latvian Quarternary geology data coded as numeric starting with 1; the layer from the second step was overlaid with the 20th century topsoil data in Latvian farmland coded as numeric starting with 1; the layer from Organic soils as modelled by the LVMI Silava (presence-only) was overlaid with the Organic soils as modelled by the University of Latvia (presence-absence). After the overlay, it was classified as presence-only; the layer from the third step was the overlaid with the layer from the fourth step and saved for EGV creation. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # step 1 step1=rast(&quot;./RasterGrids_10m/2024/SoilTXT_ESDAC.tif&quot;) step1x=ifel(step1==1,1, ifel(step1==2,2, ifel(step1==3,2, ifel(step1==4,3, ifel(step1==8,4,NA))))) plot(step1x) step1xy=as.numeric(step1x) plot(step1xy) # step 2 step2a=rast(&quot;./RasterGrids_10m/2024/SoilTXT_QuarternaryLV.tif&quot;) step2a=as.numeric(step2a)+1 plot(step2a) step2=cover(step2a,step1x) plot(step2) # step 3 step3a=rast(&quot;./RasterGrids_10m/2024/SoilTXT_topSoilLV.tif&quot;) step3a=as.numeric(step3a)+1 plot(step3a) step3=cover(step3a,step2) plot(step3) # step 4 step4a=rast(&quot;./RasterGrids_10m/2024/SoilTXT_OrganicLU.tif&quot;) step4b=rast(&quot;./RasterGrids_10m/2024/SoilTXT_OrganicSilava.tif&quot;) step4c=cover(step4a,step4b) step4=ifel(step4c==1,4,NA) plot(step4) # step 5 step5=cover(step4,step3) plot(step5) writeRaster(step5, &quot;./RasterGrids_10m/2024/SoilTXT_combined.tif&quot;, overwrite=TRUE) 5.3 Landscape classification In this exercise, “landscape” refers to the representation of different types of land cover and land use classes. The order in which these classes are drawn is important because spatial data from different sources often have mismatching boundaries. This requires addressing both their overlap (1) and filling in gaps where no database information is available (2), as well as deciding how to emphasize objects through certain processing steps, such as buffering. Some elements that are important for characterizing the environment (especially edge effects) may be so small or poorly positioned that they disappear during the rasterisation process (3). The general landscape layer also serves as a mask for the preparation of further environmental descriptions. This section describes the development of a general (simple) landscape and, in the following document, its enrichment with more specific environmental eco-geographical variables. The general landscape is stored in the file Ainava_vienk_mask.tif. The classes and the procedure for their creation are described in the list below: Class 100 - Roads: roads from various sources, filled in sequence - dominates over classes with higher values so that relatively small objects are not lost and information about edges is provided. The following sources have been combined to create this class: layers RoadA_COMB and RoadL_COMB (except the smallest size groups) from topographic map, buffered by 10 m before rasterisation; LVM open data layers LVM_MEZA_AUTOCELI, LVM_ATTISTAMIE_AUTOCELI, LVM_APGRIESANAS_LAUKUMI, LVM_IZMAINISANAS_VIETAS, and LVM_NOBRAUKTUVES buffered by 10 m; information from the State Forest Register on unpaved forest tracks has not been used, as these roads do not usually form a continuous break in the canopy. Information on roads from this register is also available in other resources and has not been duplicated. The command lines below create a layer with landscape class 100, which is saved in the file SimpleLandscape_class100_celi.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(gdalUtilities)){install.packages(&quot;gdalUtilities&quot;);require(gdalUtilities)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 100 ---- #poly celi_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/RoadA_COMB.parquet&quot;) celi_topo=celi_topo %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) ctb=st_buffer(celi_topo,dist=10) r_celi_topo=fasterize(ctb,template_r,field=&quot;yes&quot;) # pts nobrauktuves=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_NOBRAUKTUVES/LVM_NOBRAUKTUVES_Shape.shp&quot;) nobrauktuves=nobrauktuves %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) izmainisanas=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_IZMAINISANAS_VIETAS/LVM_IZMAINISANAS_VIETAS_Shape.shp&quot;) izmainisanas=izmainisanas %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) apgriesanas=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_APGRIESANAS_LAUKUMI/LVM_APGRIESANAS_LAUKUMI_Shape.shp&quot;) apgriesanas=apgriesanas %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) cp=rbind(nobrauktuves,izmainisanas,apgriesanas) cpb=st_buffer(cp,dist=10) r_celi_pts=fasterize(cpb,template_r,field=&quot;yes&quot;) # lines meza_autoceli=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_MEZA_AUTOCELI/LVM_MEZA_AUTOCELI_Shape.shp&quot;) meza_autoceli=meza_autoceli %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) attistamie=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_ATTISTAMIE_AUTOCELI/LVM_ATTISTAMIE_AUTOCELI_Shape.shp&quot;) attistamie=attistamie %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) topo_lines=st_read_parquet(&quot;./Geodata/2024/TopographicMap/RoadL_COMB.parquet&quot;) topo_lines=topo_lines %&gt;% mutate(yes=100) %&gt;% dplyr::select(yes) cl=bind_rows(meza_autoceli,attistamie,topo_lines) cl=cl %&gt;% dplyr::select(yes) clb=st_buffer(cl,dist=10) r_celi_lines=fasterize(clb,template_r,field=&quot;yes&quot;) # cleaning rm(apgriesanas) rm(attistamie) rm(celi_topo) rm(topo_lines) rm(ctb) rm(cl) rm(clb) rm(cp) rm(cpb) rm(izmainisanas) rm(meza_autoceli) rm(nobrauktuves) # to terra t_celi_topo=rast(r_celi_topo) t_celi_pts=rast(r_celi_pts) t_celi_lines=rast(r_celi_lines) # cleaning rm(r_celi_lines) rm(r_celi_pts) rm(r_celi_topo) # union plot(t_celi_topo) road_union1=cover(t_celi_topo,t_celi_pts) road_union2=cover(road_union1,t_celi_lines, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class100_celi.tif&quot;, overwrite=TRUE) # cleaning rm(t_celi_topo) rm(t_celi_pts) rm(t_celi_lines) rm(road_union1) rm(road_union2) Class 200 - Waters: water bodies from various sources, filled in sequence (but see “merging and filling” step of this section) - dominate over classes with higher values ensuring that relatively small objects are not lost and information about the edges is preserved. The following are combined to create this class: – topographic map layers HidroA_COMB and HidroL_COMB (buffered by 5 m); – MKIS layer Gravji, buffered by 3 m; – LVM open data layers LVM_GRAVJI, buffered by 5 m. – information about ditches from the State Forest Register was not used, as it is either already available in other resources or consists of structures so small that they do not cause a continuous break in the tree canopy. The command lines below create a layer with landscape class 200, which is saved in the file SimpleLandscape_class200_udens_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(gdalUtilities)){install.packages(&quot;gdalUtilities&quot;);require(gdalUtilities)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 200 ---- # topo topo_udens_poly=st_read_parquet(&quot;./Geodata/2024/TopographicMap/HidroA_COMB.parquet&quot;) topo_udens_poly=topo_udens_poly %&gt;% mutate(yes=200) %&gt;% dplyr::select(yes) %&gt;% st_transform(crs=3059) topo_udens_lines=st_read_parquet(&quot;./Geodata/2024/TopographicMap/HidroL_COMB.parquet&quot;) topo_udens_lines=topo_udens_lines %&gt;% mutate(yes=200) %&gt;% st_buffer(dist=5) %&gt;% dplyr::select(yes) %&gt;% st_transform(crs=3059) topo_udens=rbind(topo_udens_poly,topo_udens_lines) r_topo_udens=fasterize(topo_udens,template_r,field=&quot;yes&quot;) raster::writeRaster(r_topo_udens, &quot;./RasterGrids_10m/2024/SimpleLandscape_class200_topo.tif&quot;, progress=&quot;text&quot;) # cleaning rm(topo_udens_lines) rm(topo_udens_poly) rm(topo_udens) rm(r_topo_udens) # mkis st_layers(&quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;) mkis_gravji=st_read(&quot;./Geodata/2024/MKIS/MKIS_2025.gpkg&quot;,layer=&quot;Gravji&quot;) mkis_gravji=mkis_gravji %&gt;% mutate(yes=200) %&gt;% st_buffer(dist=3) %&gt;% dplyr::select(yes) r_mkis_udens=fasterize(mkis_gravji,template_r,field=&quot;yes&quot;) raster::writeRaster(r_mkis_udens, &quot;./RasterGrids_10m/2024/SimpleLandscape_class200_mkis.tif&quot;, progress=&quot;text&quot;) # cleaning rm(mkis_gravji) rm(mkis_gravji2) rm(mkis_gravji3) rm(r_mkis_udens) # lvm lvm_gravji=st_read(&quot;./Geodata/2024/LVM_OpenData/LVM_GRAVJI/LVM_GRAVJI_Shape.shp&quot;) lvm_gravji=lvm_gravji %&gt;% mutate(yes=200) %&gt;% st_buffer(dist=5) %&gt;% dplyr::select(yes) r_lvm_gravji=fasterize(lvm_gravji,template_r,field=&quot;yes&quot;) raster::writeRaster(r_lvm_gravji, &quot;./RasterGrids_10m/2024/SimpleLandscape_class200_lvm.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(lvm_gravji) rm(r_lvm_gravji) # merging a200=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_topo.tif&quot;) b200=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_mkis.tif&quot;) c200=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_lvm.tif&quot;) udens_cover1=cover(a200,b200) udens_cover2=cover(udens_cover1,c200, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_udens_premask.tif&quot;, overwrite=TRUE) # cleaning rm(a200) rm(b200) rm(c200) rm(udens_cover1) rm(udens_cover2) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_mkis.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_lvm.tif&quot;) Class 300 - Farmland: agricultural land in LAD database filled in sequence - dominates over classes with higher values. After the general classes are created, the gaps are filled in with information from Dynamic World. The following sources are combined to create this class: – LAD database, which, following the decision on grouping (classes are available here), is divided into three broad groups (in order of overlap): – arable land with class code `310`; – fallow land with class code `320`; – grassland with class code `330`; – orchards and perennial shrub plantations in the general landscape are placed in other landscape classes. The command lines below create a layer with landscape class 300 and its subclasses, which are saved in the file SimpleLandscape_class300_lauki_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(gdalUtilities)){install.packages(&quot;gdalUtilities&quot;);require(gdalUtilities)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 300 ---- # lad lad_klasem=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) lad=st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) ## arable amazemem=lad_klasem %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;aramz&quot;)) aramzemes=lad %&gt;% filter(PRODUCT_CODE %in% amazemem$kods) %&gt;% mutate(yes=310) %&gt;% dplyr::select(yes) r_aramzemes_lad=fasterize(aramzemes,template_r,field=&quot;yes&quot;) raster::writeRaster(r_aramzemes_lad, &quot;./RasterGrids_10m/2024/SimpleLandscape_class310_aramzemes_lad.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(amazemem) rm(aramzemes) rm(r_aramzemes_lad) ## fallow papuvem=lad_klasem %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;papuv&quot;)) papuves=lad %&gt;% filter(PRODUCT_CODE %in% papuvem$kods) %&gt;% mutate(yes=320) %&gt;% dplyr::select(yes) r_papuves_lad=fasterize(papuves,template_r,field=&quot;yes&quot;) raster::writeRaster(r_papuves_lad, &quot;./RasterGrids_10m/2024/SimpleLandscape_class320_papuves_lad.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(papuvem) rm(papuves) rm(r_papuves_lad) ## grassland zalajiem=lad_klasem %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;zālā&quot;)) zalaji=lad %&gt;% filter(PRODUCT_CODE %in% zalajiem$kods) %&gt;% mutate(yes=330) %&gt;% dplyr::select(yes) r_zalaji_lad=fasterize(zalaji,template_r,field=&quot;yes&quot;) raster::writeRaster(r_zalaji_lad, &quot;./RasterGrids_10m/2024/SimpleLandscape_class330_zalaji_lad.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(zalajiem) rm(zalaji) rm(r_zalaji_lad) # merging a300=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class310_aramzemes_lad.tif&quot;) b300=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class320_papuves_lad.tif&quot;) c300=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class330_zalaji_lad.tif&quot;) farmland_cover1=cover(a300,b300) farmland_cover2=cover(farmland_cover1,c300, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class300_lauki_premask.tif&quot;, overwrite=TRUE) # cleaning rm(lad) rm(lad_klasem) rm(a300) rm(b300) rm(c300) rm(farmland_cover1) rm(farmland_cover2) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class310_aramzemes_lad.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class320_papuves_lad.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class330_zalaji_lad.tif&quot;) Class 400 - Allotment Gardens, Orchards and Cottages, filled in order - dominates over classes with higher values. To create this class, the following are combined (in order of overlap): – topographic map layer BuildA_v3 values: “poligons_Vasarnīcu_apbūve”, “poligons_Viensētu_apbūve”, coded as 410; – topographic map layer LandusA_COMB values: “poligons_Augludarzs”, “poligons_Augļudārzs”, “poligons_Sakņudārzs”, “poligons_Ogulājs”, “poligons_Ogulajs”, “poligons_Saknudarzs”, coded as 420; – LAD database rural information layer group (classes are available here) “augļudārzi”, the result of which is coded as 420. The command lines below create a layer with landscape class 400, which is saved in the file SimpleLandscape_class400_vasarnicas_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 400 ---- # topo built-up viensvasar=st_read_parquet(&quot;./Geodata/2024/TopographicMap/BuildA_v3.parquet&quot;) table(viensvasar$FNAME,useNA=&quot;always&quot;) viensvasar=viensvasar %&gt;% filter(FNAME %in% c(&quot;poligons_Vasarnīcu_apbūve&quot;,&quot;poligons_Viensētu_apbūve&quot;)) %&gt;% mutate(yes=410) %&gt;% dplyr::select(yes) r_viensetasvasarnicas=fasterize(viensvasar,template_r,field=&quot;yes&quot;) raster::writeRaster(r_viensetasvasarnicas, &quot;./RasterGrids_10m/2024/SimpleLandscape_class410_vasarnicasviensetas_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(viensvasar) rm(r_darzini_topo) # topo darzini_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) table(darzini_topo$FNAME,useNA=&quot;always&quot;) darzini_topo=darzini_topo %&gt;% filter(FNAME %in% c(&quot;poligons_Augludarzs&quot;,&quot;poligons_Augļudārzs&quot;,&quot;poligons_Sakņudārzs&quot;, &quot;poligons_Ogulājs&quot;,&quot;poligons_Ogulajs&quot;,&quot;poligons_Saknudarzs&quot;)) %&gt;% mutate(yes=410) %&gt;% dplyr::select(yes) r_darzini_topo=fasterize(darzini_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_darzini_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class410_darzini_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(darzini_topo) rm(r_darzini_topo) # lad lad_klasem=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) table(lad_klasem$SDM_grupa_sakums,useNA=&quot;always&quot;) augludarziem=lad_klasem %&gt;% filter(SDM_grupa_sakums==&quot;augļudārzi&quot;) lad=st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad=lad %&gt;% filter(PRODUCT_CODE %in% augludarziem$kods) %&gt;% mutate(yes=420) %&gt;% dplyr::select(yes) r_darzini_lad=fasterize(lad,template_r,field=&quot;yes&quot;) raster::writeRaster(r_darzini_lad, &quot;./RasterGrids_10m/2024/SimpleLandscape_class420_darzini_lad.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(lad_klasem) rm(augludarziem) rm(lad) rm(r_darzini_lad) # merging a400=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class410_vasarnicasviensetas_topo.tif&quot;) b400=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class420_darzini_topo.tif&quot;) c400=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class420_darzini_lad.tif&quot;) allotment_cover=cover(a400,b400, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class400_varnicas_premask.tif&quot;, overwrite=TRUE) # cleaning rm(a400) rm(b400) rm(allotment_cover) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class410_vasarnicasviensetas_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class420_darzini_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class420_darzini_lad.tif&quot;) Class 500 - Built-up: built-up areas, filled in at the end (see section “merging and filling” of this chapter) using information from Dynamic World for places not covered by other classes. Class 600 - Forests, Shrublands, Clearings: areas covered with trees and shrubs, clearings, and dead forest stands, filled in order - dominates over classes with higher values. The following sources have been combined to create this class (in order of overlap): – The Global Forest Watch layer records of tree canopy cover loss since 2020, coded as 610; – Forest State Register clearings and dead forest stands, the result of which is coded as 610; – Forest State Register marked forest stands that are lower than 5 m and seed production plantations, the result of which is coded as 620; – topographic map layer FloraL_COMB classes related to shrubs, buffered by 10 m, coded as 620; – topographic map layers LandusA_COMB classes: “poligons_Krūmājs”, “poligons_Krumajs”, “poligons_Krūmaugu_plant”, “poligons_Plantacija_krum”, coded as 620; – LAD database group (classes are available here) “krūmveida ilggadīgie stādījumi”, the result of which is coded with 620; – Forest State Register forest stands with a height of at least 5 m, coded as 630; – topographic map layer LandusA_COMB classes: “poligons_Parks”, “poligons_Meza_kapi”, “poligons_Kapi”, “poligons_Kapi_meza”, the result of which is coded as 640; – topographic map layer FloraL_COMB with tree-related classes, buffered by 10 m, coded as 640; – PALSAR Forests layer, coded as 630. The command lines below create a layer with landscape class 600, which is saved in the file SimpleLandscape_class600_meziem_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 600 ---- # mvr mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) # clearcuts izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% mutate(yes=610) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,template_r,field=&quot;yes&quot;) raster::writeRaster(r_izcirtumi_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class610_izcirtumi_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(izcirtumi) rm(r_izcirtumi_mvr) # low stands # also zkat 16 zemas_audzes=mvr %&gt;% filter((zkat ==&quot;10&quot; &amp; h10&lt;5)|zkat==&quot;16&quot;) %&gt;% mutate(yes=620) %&gt;% dplyr::select(yes) r_zemas_mvr=fasterize(zemas_audzes,template_r,field=&quot;yes&quot;) raster::writeRaster(r_zemas_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class620_zemas_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(zemas_audzes) rm(r_zemas_mvr) # high stands augstas_audzes=mvr %&gt;% filter(zkat ==&quot;10&quot; &amp; h10&gt;=5) %&gt;% mutate(yes=630) %&gt;% dplyr::select(yes) r_augstas_mvr=fasterize(augstas_audzes,template_r,field=&quot;yes&quot;) raster::writeRaster(r_augstas_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class630_augstas_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(augstas_audzes) rm(r_augstas_mvr) rm(mvr) # tcl - since 2020 tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,NA,610, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class610_TCL.tif&quot;, overwrite=TRUE) # cleaning rm(tcl) rm(tcl2) # palsar palsar=rast(&quot;./Geodata/2024/Trees/Palsar/Palsar_Forests.tif&quot;) palsar2=ifel(palsar==1,630,NA, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class630_Palsar.tif&quot;, overwrite=TRUE) # cleaning rm(palsar) rm(palsar2) # lad lad_klasem=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) table(lad_klasem$SDM_grupa_sakums,useNA=&quot;always&quot;) lad=st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) krumiem=lad_klasem %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;krūmv&quot;)) krumi=lad %&gt;% filter(PRODUCT_CODE %in% krumiem$kods) %&gt;% mutate(yes=620) %&gt;% dplyr::select(yes) r_krumi_lad=fasterize(krumi,template_r,field=&quot;yes&quot;) raster::writeRaster(r_krumi_lad, &quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_lad.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(lad_klasem) rm(lad) rm(krumiem) rm(krumi) rm(r_krumi_lad) # topo - pkk pkk_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) table(pkk_topo$FNAME,useNA=&quot;always&quot;) pkk_topo=pkk_topo %&gt;% filter(FNAME %in% c(&quot;poligons_Parks&quot;,&quot;poligons_Meza_kapi&quot;,&quot;poligons_Kapi&quot;, &quot;poligons_Kapi_meza&quot;)) %&gt;% mutate(yes=640) %&gt;% dplyr::select(yes) r_pkk_topo=fasterize(pkk_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_pkk_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class640_pkk_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(pkk_topo) rm(r_pkk_topo) # topo - shrubs krumi_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) table(krumi_topo$FNAME,useNA=&quot;always&quot;) krumi_topo=krumi_topo %&gt;% filter(FNAME %in% c(&quot;poligons_Krūmājs&quot;,&quot;poligons_Krumajs&quot;, &quot;poligons_Krūmaugu_plant&quot;,&quot;poligons_Plantacija_krum&quot;)) %&gt;% mutate(yes=620) %&gt;% dplyr::select(yes) r_krumi_topo=fasterize(krumi_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_krumi_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(krumi_topo) rm(r_krumi_topo) # topo - linear vegetation linijas_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/FloraL_COMB.parquet&quot;) table(linijas_topo$FNAME,useNA=&quot;always&quot;) # linear shrubs krumu_linijas_topo=linijas_topo %&gt;% filter(FNAME==&quot;Krūmu rinda dzīvzogs&quot;|FNAME==&quot;Krūmu rinda gar ceļiem upēm&quot;| FNAME==&quot;Krumu_rinda_dzivzogs&quot;|FNAME==&quot;Krumu_rinda_gar_celiem_upem&quot;) %&gt;% mutate(yes=620) %&gt;% st_buffer(dist=10) %&gt;% dplyr::select(yes) r_krumu_linijas_topo=fasterize(krumu_linijas_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_krumu_linijas_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class620_KrumuLinijas_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(krumu_linijas_topo) rm(r_krumu_linijas_topo) # linear trees koku_linijas_topo=linijas_topo %&gt;% filter(str_detect(FNAME,&quot;Koku&quot;)) %&gt;% mutate(yes=640) %&gt;% st_buffer(dist=10) %&gt;% dplyr::select(yes) r_koku_linijas_topo=fasterize(koku_linijas_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_koku_linijas_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class640_KokuLinijas_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(koku_linijas_topo) rm(r_koku_linijas_topo) rm(linijas_topo) # merging r_krumi_lad=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_lad.tif&quot;) r_pkk_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class640_pkk_topo.tif&quot;) r_krumi_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_topo.tif&quot;) r_krumu_linijas_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_KrumuLinijas_topo.tif&quot;) r_koku_linijas_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class640_KokuLinijas_topo.tif&quot;) r_palsar=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class630_palsar.tif&quot;) r_tcl=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class610_TCL.tif&quot;) r_augstas_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class630_augstas_mvr.tif&quot;) r_zemas_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_zemas_mvr.tif&quot;) r_izcirtumi_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class610_izcirtumi_mvr.tif&quot;) mezu_cover=cover(r_tcl,r_izcirtumi_mvr) mezu_cover=cover(mezu_cover,r_zemas_mvr) mezu_cover=cover(mezu_cover,r_krumu_linijas_topo) mezu_cover=cover(mezu_cover,r_krumi_topo) mezu_cover=cover(mezu_cover,r_krumi_lad) mezu_cover=cover(mezu_cover,r_augstas_mvr) mezu_cover=cover(mezu_cover,r_pkk_topo) mezu_cover=cover(mezu_cover,r_koku_linijas_topo) mezu_cover=cover(mezu_cover,r_palsar, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class600_meziem_premask.tif&quot;, overwrite=TRUE) # cleaning rm(r_krumi_lad) rm(r_pkk_topo) rm(r_krumi_topo) rm(r_krumu_linijas_topo) rm(r_koku_linijas_topo) rm(r_palsar) rm(r_tcl) rm(r_augstas_mvr) rm(r_zemas_mvr) rm(r_izcirtumi_mvr) rm(mezu_cover) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_lad.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class640_pkk_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_krumi_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_KrumuLinijas_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class640_KokuLinijas_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class630_palsar.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class610_TCL.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class630_augstas_mvr.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class620_zemas_mvr.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class610_izcirtumi_mvr.tif&quot;) Class 700 - Wetlands: combining geospatial data related to reed beds, marshes, mires, and bogs, filled in order except class 720 that dominates over waters - dominates classes with higher values. To create this class, the following sources are combined (in order of overlap): – topographic map layer LandusA_COMB classes: “Meldrājs_ūdenī_poligons”, “poligons_Grislajs”, “poligons_Grīslājs”, “poligons_Meldrajs”, “poligons_Meldrājs”, “poligons_Meldrajs_udeni”, “poligons_Nec_purvs_grīslājs”, “poligons_Nec_purvs_meldrājs”, “Sēklis_poligons”, the result of which is coded with 720; – topographic map layer LandusA_COMB classes: “poligons_Nec_purvs_sūnājs”, “poligons_Sunajs”, “poligons_Sūnājs”, the result of which is coded with 710; – topographic map layer SwampA_COMB, the result of which is coded as 710; – land categories “21”, “22”, and “23” marked in the State Forest Register, the result of which is coded as 710; – land categories “41” and “42” marked in the State Forest Register, the result of which is coded as 730; bogs from Bogs and Mires: EDI; transitional mires from Bogs and Mires: EDI; The command lines below create a layer with landscape class 700, which is saved in the file SimpleLandscape_class700_mitraji_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 700 ---- # topo topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) table(topo$FNAME,useNA=&quot;always&quot;) ## ReedSedgeRush niedraji_topo=topo %&gt;% filter(FNAME %in% c(&quot;Meldrājs_ūdenī_poligons&quot;,&quot;poligons_Grislajs&quot;,&quot;poligons_Grīslājs&quot;, &quot;poligons_Meldrajs&quot;,&quot;poligons_Meldrājs&quot;,&quot;poligons_Meldrajs_udeni&quot;, &quot;poligons_Nec_purvs_grīslājs&quot;, &quot;poligons_Nec_purvs_meldrājs&quot;, &quot;Sēklis_poligons&quot;)) %&gt;% mutate(yes=720) %&gt;% dplyr::select(yes) r_niedraji_topo=fasterize(niedraji_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_niedraji_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class720_niedraji_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(niedraji_topo) rm(r_niedraji_topo) ## bogs purvi_topo=topo %&gt;% filter(FNAME %in% c(&quot;poligons_Nec_purvs_sūnājs&quot;, &quot;poligons_Sunajs&quot;,&quot;poligons_Sūnājs&quot;)) %&gt;% mutate(yes=710) %&gt;% dplyr::select(yes) topo_purvi=st_read_parquet(&quot;./Geodata/2024/TopographicMap/SwampA_COMB.parquet&quot;) topo_purvi=topo_purvi %&gt;% mutate(yes=710) %&gt;% dplyr::select(yes) purvi=rbind(purvi_topo,topo_purvi) r_purvi_topo=fasterize(purvi,template_r,field=&quot;yes&quot;) raster::writeRaster(r_purvi_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_topo.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(purvi_topo) rm(topo_purvi) rm(purvi) rm(r_purvi_topo) # mvr mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) # bogs and mires mvr_purvi=mvr %&gt;% filter(zkat %in% c(&quot;21&quot;,&quot;22&quot;,&quot;23&quot;)) %&gt;% mutate(yes=710) %&gt;% dplyr::select(yes) r_purvi_mvr=fasterize(mvr_purvi,template_r,field=&quot;yes&quot;) raster::writeRaster(r_purvi_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(mvr_purvi) rm(r_purvi_mvr) # beavers mvr_bebri=mvr %&gt;% filter(zkat %in% c(&quot;41&quot;,&quot;42&quot;)) %&gt;% mutate(yes=730) %&gt;% dplyr::select(yes) r_bebri_mvr=fasterize(mvr_bebri,template_r,field=&quot;yes&quot;) raster::writeRaster(r_bebri_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class730_bebri_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(mvr_bebri) rm(r_bebri_mvr) rm(mvr) # merging r_niedraji_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class720_niedraji_topo.tif&quot;) r_purvi_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_topo.tif&quot;) r_purvi_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_mvr.tif&quot;) r_bebri_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class730_bebri_mvr.tif&quot;) mires=rast(&quot;./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif&quot;) miresY=ifel(mires==1,710,NA) bogs=rast(&quot;./RasterGrids_10m/2024/EDI_BogsYN.tif&quot;) bogsY=ifel(bogs==1,710,NA) wetlands_cover=cover(r_niedraji_topo,r_purvi_topo) wetlands_cover=cover(wetlands_cover,r_purvi_mvr) wetlands_cover=cover(wetlands_cover,r_bebri_mvr) wetlands_cover=cover(wetlands_cover,miresY) wetlands_cover=cover(wetlands_cover,bogsY, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class700_mitraji_premask.tif&quot;, overwrite=TRUE) # cleaning rm(r_niedraji_topo) rm(r_purvi_topo) rm(r_purvi_mvr) rm(r_bebri_mvr) rm(bogs) rm(bogsY) rm(mires) rm(miresY) rm(topo) rm(wetlands_cover) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class710_purvi_mvr.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class730_bebri_mvr.tif&quot;) Class 800 - Bare Soil and Quarries: combining layers related to bare soil, heaths, and quarries, filled in order - as this is the highest class, it dominates only over Dynamic World used to fill gaps. The following have been combined to create this class (in order of overlap): – topographic map layer LandusA_COMB classes: “poligons_Smiltājs”, “poligons_Smiltajs”, “poligons_Grants”, “poligons_Kūdra”, “poligons_Virsajs”, the result of which is coded with 800; – land categories “33” and “34” marked in the State Forest Register, the result of which is coded as 800. The command lines below create a layer with landscape class 800, which is saved in the file SimpleLandscape_class800_smiltaji_premask.tif for further processing. Code # Libs ---- if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # class 800 ---- smiltaji_topo=st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) table(smiltaji_topo$FNAME,useNA=&quot;always&quot;) smiltaji_topo=smiltaji_topo %&gt;% filter(FNAME %in% c(&quot;poligons_Smiltājs&quot;,&quot;poligons_Smiltajs&quot;,&quot;poligons_Grants&quot;, &quot;poligons_Kūdra&quot;,&quot;poligons_Virsajs&quot;)) %&gt;% mutate(yes=800) %&gt;% dplyr::select(yes) r_smiltaji_topo=fasterize(smiltaji_topo,template_r,field=&quot;yes&quot;) raster::writeRaster(r_smiltaji_topo, &quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltajiKudra_topo.tif&quot;, progress=&quot;text&quot;) # cleaning rm(smiltaji_topo) rm(r_smiltaji_topo) # mvr zkat 33 un 34 mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) smiltajiem=mvr %&gt;% filter(zkat %in% c(&quot;33&quot;,&quot;34&quot;)) %&gt;% mutate(yes=800) %&gt;% dplyr::select(yes) r_smiltaji_mvr=fasterize(smiltajiem,template_r,field=&quot;yes&quot;) raster::writeRaster(r_smiltaji_mvr, &quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltVirs_mvr.tif&quot;, progress=&quot;text&quot;, overwrite=TRUE) # cleaning rm(mvr) rm(smiltajiem) rm(r_smiltaji_mvr) # merging r_smiltaji_topo=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltajiKudra_topo.tif&quot;) r_smiltaji_mvr=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltVirs_mvr.tif&quot;) bare_cover=terra::merge(r_smiltaji_topo,r_smiltaji_mvr, filename=&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_smiltaji_premask.tif&quot;, overwrite=TRUE) # cleaning rm(r_smiltaji_topo) rm(r_smiltaji_mvr) rm(bare_cover) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltajiKudra_topo.tif&quot;) unlink(&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_SmiltVirs_mvr.tif&quot;) Merging and filling The command lines below combine the previously created layers with the landscape classes in the correct order and ensure that gaps are filled with the appropriately classified Dynamic World composite for April-August 2024. After masking to only the analysis space, the layer is saved in the file Ainava_vienk_mask.tif for further processing. Code # Libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # final merging and covering ---- # DW dynworld=rast(&quot;Geodata/2024/DynamicWorld/DW_2024_apraug.tif&quot;) klases=matrix(c(0,200, 1,620, 2,330, 3,720, 4,310, 5,710, 6,500, 7,800, 8,500),ncol=2,byrow=TRUE) dw2=terra::classify(dynworld,klases) writeRaster(dw2, &quot;./RasterGrids_10m/2024/DW_reclass.tif&quot;, overwrite=TRUE) # other layers celi=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class100_celi.tif&quot;) plot(celi) niedraji=rast(&quot;RasterGrids_10m/2024/SimpleLandscape_class720_niedraji_topo.tif&quot;) plot(niedraji) udeni=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class200_udens_premask.tif&quot;) plot(udeni) lauki=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class300_lauki_premask.tif&quot;) plot(lauki) vasarnicas=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class400_varnicas_premask.tif&quot;) plot(vasarnicas) mezi=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class600_meziem_premask.tif&quot;) plot(mezi) mitraji=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class700_mitraji_premask.tif&quot;) plot(mitraji) smiltaji=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class800_smiltaji_premask.tif&quot;) plot(smiltaji) dw2=rast(&quot;./RasterGrids_10m/2024/DW_reclass.tif&quot;) plot(dw2) # covering in correct order rastri_ainavai=cover(celi,niedraji) rastri_ainavai=cover(rastri_ainavai,udeni) rastri_ainavai=cover(rastri_ainavai,lauki) rastri_ainavai=cover(rastri_ainavai,vasarnicas) rastri_ainavai=cover(rastri_ainavai,mezi) rastri_ainavai=cover(rastri_ainavai,mitraji) rastri_ainavai=cover(rastri_ainavai,smiltaji) rastri_ainavai=cover(rastri_ainavai,dw2, filename=&quot;./RasterGrids_10m/2024/Ainava_vienkarsa.tif&quot;, overwrite=TRUE) plot(rastri_ainavai) # cleaning rm(celi) rm(niedraji) rm(udeni) rm(lauki) rm(vasarnicas) rm(mezi) rm(mitraji) rm(smiltaji) rm(klases) rm(dynworld) rm(dw2) rm(rastri_ainavai) # masking rastrs_ainava=rast(&quot;./RasterGrids_10m/2024/Ainava_vienkarsa.tif&quot;) plot(rastrs_ainava) freq(rastrs_ainava) masketa_ainava=terra::mask(rastrs_ainava, template_t, filename=&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;, overwrite=TRUE) plot(masketa_ainava) # cleaning rm(rastrs_ainava) rm(masketa_ainava) 5.4 Landscape diversity This subsection summarizes the input products related to the landscape described in the previous section – raster layers prepared at a 10 m resolution, which characterize the classes found in the landscape (environment), as well as the subsequent preprocessing for the preparation of the EGVs. The calculations of the Shannon diversity index are so computationally intensive that it is not rationally possible to perform them at every landscape scale around each analysis cell (EGV-cell). Furthermore, they cannot be directly aggregated to speed up the calculation. Therefore, a decision has been made on the raster cell size, which: is formed as a multiplication of the EGV-cell by an integer; is large enough to account for environmental variability. Therefore, the EGV-cell itself (or multiplication by 1) is not suitable - there is very little variability in land cover and land use within an area of 1 ha. Consequently, the raster cell size for calculation of Shannon index should be as large as possible without becoming so large that it artificially inflates spatial autocorrelation and loose spatial relevance; allows to build every landscape scale from several diversity-index–level cells. Since we use spatially weighted zonal statistics in the preparation of EGVs, and the smallest landscape scale is r = 500 m around the centre of the EGV-cell, it has been decided to calculate the landscape diversity index for individual cells with a side length of 500 m (i.e., 25 ha landscapes). This means that the smallest number of units used for the development of the EGVs is nine (for a landscape scale of r = 500 m around the centre of the EGV-cell). Three principal environments are described using diversity indices: overall landscape, farmland, and forests. To make them easier to reproduce and locate, each is described in a separate section below. 5.4.1 Overall landscape Combination of three layers is involved to describe overall landscape diversity: as the lowest in hierarchy is Ainava_vienk_mask.tif, prepared in section Landscape classification; farmland diversity as the top layer in the hierarhy. Prepared based on relatively broad agricultural codes (field - SDM_grupa_sakums) from Rural Support Service’s information on declared fields. Only cells corresponding to declared fields contain values; others are empty will inherit values from other layers during overlay. Codes used range from 351 to 362; forest diversity is the second layer in hierarchy. This layer describes dominant tree species groups in each stand with stand, derived from stand-level inventory data combined with age group as used in forestry practice. Values used in this classification are available from database description. tree species groups: coniferous species codes: “1”, “3”, “13”, “14”, “15”, “22”, “23”, “28”; boreal deciduous species codes: “4”, “6”, “8”, “9”, “19”, “20”, “21”, “32”, “35”, “68”; temperate deciduous species codes: “10”, “11”, “12”, “16”, “17”, “18”, “24”, “25”, “26”, “27”, “28”, “29”, “50”, “61”, “62”, “63”, “64”, “65”, “66”, “67”, “69”; classification: a forest is considered coniferous if timber volume of coniferous species in the top tree layer constitutes at least 75% of the total timer volume. Otherwise, it can be considered boreal deciduous if the respective proportion is at least 75%, or temperate deciduous if the respective proportion is at least 50%; else it is considered mixed. tree age groups: forests are considered young if they are registered with age groups “1”, “2” or “3”; forests are considered old if they are registered with age groups “4”, or “5”; created codes are formatted as factors and then again as scalars, with 660 added. Once the landscape classification is done, diversity index is calculated for 25 ha landscapes using the function egvtools::landscape_function. To guard value coverage, inverse distance weighted (power = 2) gap filling is incorporated; however, there were no gaps to fill. Code # Libs ---- if(!require(egvtools)) {install.packages(&quot;egvtools&quot;); require(egvtools)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # overall diversity ---- ## Farmland broad ---- # classification culturecodes=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) culturecodes$kods=as.character(culturecodes$kods) lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad2=lad %&gt;% left_join(culturecodes, by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) %&gt;% mutate(numeric_code=as.numeric(as.factor(SDM_grupa_sakums))+350) %&gt;% filter(!is.na(numeric_code)) table(lad2$numeric_code,useNA = &quot;always&quot;) # input layer polygon2input(vector_data = lad2, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;Diversity_FarmlandBroad_only.tif&quot;, value_field = &quot;numeric_code&quot;, fun=&quot;first&quot;, prepare=FALSE, project_mode = &quot;auto&quot;) # cleaning rm(culturecodes) rm(lad) rm(lad2) ## Forests broad ---- # data mvr=sfarrow::st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) # species groups skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 # classification mvr2=mvr %&gt;% mutate(vol_coniferous=ifelse(s10 %in% coniferous,v10,0)+ ifelse(s11 %in% coniferous,v11,0)+ifelse(s12 %in% coniferous,v12,0)+ ifelse(s13 %in% coniferous,v13,0)+ifelse(s14 %in% coniferous,v14,0), vol_boreal=ifelse(s10 %in% boreal_deciduous,v10,0)+ ifelse(s11 %in% boreal_deciduous,v11,0)+ifelse(s12 %in% boreal_deciduous,v12,0)+ ifelse(s13 %in% boreal_deciduous,v13,0)+ifelse(s14 %in% boreal_deciduous,v14,0), vol_temperate=ifelse(s10 %in% temperate_deciduous,v10,0)+ ifelse(s11 %in% temperate_deciduous,v11,0)+ifelse(s12 %in% temperate_deciduous,v12,0)+ ifelse(s13 %in% temperate_deciduous,v13,0)+ifelse(s14 %in% temperate_deciduous,v14,0)) %&gt;% mutate(vol_total=vol_coniferous+vol_boreal+vol_temperate) %&gt;% mutate(forest_type=ifelse(vol_coniferous/vol_total&gt;=0.75,&quot;coniferous&quot;, ifelse(vol_boreal/vol_total&gt;=0.75,&quot;boreal&quot;, ifelse(vol_temperate/vol_total&gt;0.5,&quot;temperate&quot;, &quot;mixed&quot;)))) %&gt;% mutate(forest_age=ifelse(vgr==&quot;1&quot;|vgr==&quot;2&quot;|vgr==&quot;3&quot;,&quot;young&quot;, ifelse(vgr==&quot;4&quot;|vgr==&quot;5&quot;,&quot;old&quot;,NA))) %&gt;% filter(!is.na(forest_type)) %&gt;% filter(!is.na(forest_age)) %&gt;% mutate(divbroad_class=paste0(forest_type,&quot;_&quot;,forest_age)) %&gt;% mutate(divbroad_numeric=as.numeric(as.factor(divbroad_class))+660) %&gt;% filter(!is.na(divbroad_numeric)) # input layer polygon2input(vector_data = mvr2, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;Diversity_ForestBroad_only.tif&quot;, value_field = &quot;divbroad_numeric&quot;, fun=&quot;first&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, overwrite = TRUE) # cleaning rm(mvr) rm(mvr2) ## overall classification ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) ## Covered classes for general diversity ---- farmland_broad=rast(&quot;./RasterGrids_10m/2024/Diversity_FarmlandBroad_only.tif&quot;) forests_broad=rast(&quot;./RasterGrids_10m/2024/Diversity_ForestBroad_only.tif&quot;) diversity_classes=cover(farmland_broad,forests_broad) diversity_classes2=cover(diversity_classes,simple_landscape, filename=&quot;./RasterGrids_10m/2024/Diversity_GeneralLandscapeBroad.tif&quot;, overwrite=TRUE) rm(simple_landscape) rm(farmland_broad) rm(forests_broad) rm(diversity_classes) rm(diversity_classes2) ## Diversity index at 25ha ----- res_tbl &lt;- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Diversity_GeneralLandscapeBroad.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls500_sauzeme.parquet&quot;, id_field = &quot;rinda500&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV500m_10km.tif&quot;, out_dir = &quot;./RasterGrids_500m/2024/&quot;, out_filename = &quot;Diversity_GeneralLandscape_500x.tif&quot;, out_layername = &quot;Diversity_GeneralLandscape_500x&quot;, what = &quot;lsm_l_shdi&quot;, rasterize_engine = &quot;fasterize&quot;, n_workers = 8, future_max_size = 3 * 1024^3, fill_gaps = TRUE, plot_gaps = TRUE, plot_result = TRUE ) print(res_tbl) plot(rast(&quot;./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif&quot;)) rm(res_tbl) 5.4.2 Forest diversity An input grid with a cell size of 10 m covers the entire territory of Latvia. It contains the following values, in order of hierarchy: State Forest Service’s Forest State Register code, in which the code of the dominant tree species is multiplied by 1000 and the age group code is added. However, before rasterisation, geometries in which no code has been assigned or one of the code components is 0 are excluded; forest diversity class values prepared in Overall landscape diversity; forest classes from Landscape classification; value 1 for all other cells located in the territory of Latvia. Once the landscape classification is done, the Shannon’s diversity index is calculated for 25 ha landscapes using the function egvtools::landscape_function. To ensure value coverage, inverse distance weighted (power = 2) gap filling is incorporated; however, there were no gaps to fill. Code # Libs ---- if(!require(egvtools)) {install.packages(&quot;egvtools&quot;); require(egvtools)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # forest diversity ---- ## forest broad ---- forest_broad=rast(&quot;./RasterGrids_10m/2024/Diversity_ForestBroad_only.tif&quot;) ## forest codes ---- # mezi mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr=mvr %&gt;% mutate(kods1=as.numeric(s10)*1000, kods2=as.numeric(vgr), kods=kods1+kods2) %&gt;% filter(!is.na(kods)) %&gt;% filter(kods1&gt;0) %&gt;% filter(kods2&gt;0) # input layer polygon2input(vector_data = mvr, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;Diversity_ForestCodes_only.tif&quot;, value_field = &quot;kods&quot;, fun=&quot;first&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, overwrite = TRUE) # cleaning rm(mvr) # simple forests simple_forests=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class600_meziem_premask.tif&quot;) ## Covered classes for forest diversity ---- forest_codes=rast(&quot;./RasterGrids_10m/2024/Diversity_ForestCodes_only.tif&quot;) plot(forest_codes) forest_covered=cover(forest_codes,forest_broad) forest_covered=cover(forest_covered,simple_forests) plot(forest_covered) forest_covered2=cover(forest_covered,template_t, filename=&quot;./RasterGrids_10m/2024/Diversity_ForestsDetailed.tif&quot;, overwrite=TRUE) plot(forest_covered2) # cleaning rm(forest_codes) rm(forest_covered) rm(forest_covered2) rm(forest_broad) rm(simple_forests) ## Diversity index at 25ha ----- res_tbl &lt;- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Diversity_ForestsDetailed.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls500_sauzeme.parquet&quot;, id_field = &quot;rinda500&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV500m_10km.tif&quot;, out_dir = &quot;./RasterGrids_500m/2024/&quot;, out_filename = &quot;Diversity_Forests_500x.tif&quot;, out_layername = &quot;Diversity_Forests_500x&quot;, what = &quot;lsm_l_shdi&quot;, rasterize_engine = &quot;fasterize&quot;, n_workers = 8, future_max_size = 3 * 1024^3, fill_gaps = TRUE, plot_gaps = TRUE, plot_result = TRUE ) print(res_tbl) plot(rast(&quot;./RasterGrids_500m/2024/Diversity_Forests_500x.tif&quot;)) rm(res_tbl) 5.4.3 Farmland diversity A grid with a cell size of 10 m covers the entire territory of Latvia. It contains the following values, listed in order of hierarchy: Rural Support Service crop codes with 1000 added; farmland diversity class values prepared in Overall landscape diversity; farmland classes from Landscape classification; value 1 for all other cells located within the territory of Latvia. Once the landscape classification is done, diversity index is calculated for 25 ha landscapes with function egvtools::landscape_function. To guard value coverage, inverse distance weighted (power = 2) gap filling is incorporated; however, there were no gaps to fill. Code # Libs ---- if(!require(egvtools)) {install.packages(&quot;egvtools&quot;); require(egvtools)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(arrow)) {install.packages(&quot;arrow&quot;); require(arrow)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} # templates ---- template_t=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template_r=raster(template_t) # farmland diversity ----- ## Farmland broad ---- farmland_broad=rast(&quot;./RasterGrids_10m/2024/Diversity_FarmlandBroad_only.tif&quot;) ## Farmland codes ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$product_code=as.numeric(lad$PRODUCT_CODE)+1000 # input layer polygon2input(vector_data = lad, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;Diversity_FarmlandCodes_only.tif&quot;, value_field = &quot;product_code&quot;, fun=&quot;first&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, overwrite = TRUE) # cleaning rm(lad) # simple landscapes input simple_farmland=rast(&quot;./RasterGrids_10m/2024/SimpleLandscape_class300_lauki_premask.tif&quot;) ## Covered classes for farmland diversity ---- farmland_codes=rast(&quot;./RasterGrids_10m/2024/Diversity_FarmlandCodes_only.tif&quot;) farmland_covered=cover(farmland_codes,farmland_broad) farmland_covered=cover(farmland_covered,simple_farmland) farmland_covered2=cover(farmland_covered,template_t, filename=&quot;./RasterGrids_10m/2024/Diversity_FarmlandDetailed.tif&quot;, overwrite=TRUE) plot(farmland_covered2) # cleaning rm(farmland_codes) rm(farmland_covered) rm(farmland_covered2) rm(simple_farmland) rm(farmland_broad) ## Diversity index at 25ha ----- res_tbl &lt;- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Diversity_FarmlandDetailed.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls500_sauzeme.parquet&quot;, id_field = &quot;rinda500&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV500m_10km.tif&quot;, out_dir = &quot;./RasterGrids_500m/2024/&quot;, out_filename = &quot;Diversity_Farmland_500x.tif&quot;, out_layername = &quot;Diversity_Farmland_500x&quot;, what = &quot;lsm_l_shdi&quot;, rasterize_engine = &quot;fasterize&quot;, n_workers = 8, future_max_size = 3 * 1024^3, fill_gaps = TRUE, plot_gaps = TRUE, plot_result = TRUE ) print(res_tbl) plot(rast(&quot;./RasterGrids_500m/2024/Diversity_Farmland_500x.tif&quot;)) rm(res_tbl) References Wang, L., Liu, H., 2006. An efficient method for identifying and filling surface depressions in digital elevation models for hydrologic analysis and modelling. International Journal of Geographical Information Science 20, 193–213. https://doi.org/10.1080/13658810500433453 "],["Ch06.html", "6 Ecogeographical variables 6.1 Climate_CHELSAv2.1-bio1_cell 6.2 Climate_CHELSAv2.1-bio10_cell 6.3 Climate_CHELSAv2.1-bio11_cell 6.4 Climate_CHELSAv2.1-bio12_cell 6.5 Climate_CHELSAv2.1-bio13_cell 6.6 Climate_CHELSAv2.1-bio14_cell 6.7 Climate_CHELSAv2.1-bio15_cell 6.8 Climate_CHELSAv2.1-bio16_cell 6.9 Climate_CHELSAv2.1-bio17_cell 6.10 Climate_CHELSAv2.1-bio18_cell 6.11 Climate_CHELSAv2.1-bio19_cell 6.12 Climate_CHELSAv2.1-bio2_cell 6.13 Climate_CHELSAv2.1-bio3_cell 6.14 Climate_CHELSAv2.1-bio4_cell 6.15 Climate_CHELSAv2.1-bio5_cell 6.16 Climate_CHELSAv2.1-bio6_cell 6.17 Climate_CHELSAv2.1-bio7_cell 6.18 Climate_CHELSAv2.1-bio8_cell 6.19 Climate_CHELSAv2.1-bio9_cell 6.20 Climate_CHELSAv2.1-clt-max_cell 6.21 Climate_CHELSAv2.1-clt-mean_cell 6.22 Climate_CHELSAv2.1-clt-min_cell 6.23 Climate_CHELSAv2.1-clt-range_cell 6.24 Climate_CHELSAv2.1-cmi-max_cell 6.25 Climate_CHELSAv2.1-cmi-mean_cell 6.26 Climate_CHELSAv2.1-cmi-min_cell 6.27 Climate_CHELSAv2.1-cmi-range_cell 6.28 Climate_CHELSAv2.1-fcf_cell 6.29 Climate_CHELSAv2.1-fgd_cell 6.30 Climate_CHELSAv2.1-gdd0_cell 6.31 Climate_CHELSAv2.1-gdd10_cell 6.32 Climate_CHELSAv2.1-gdd5_cell 6.33 Climate_CHELSAv2.1-gddlgd0_cell 6.34 Climate_CHELSAv2.1-gddlgd10_cell 6.35 Climate_CHELSAv2.1-gddlgd5_cell 6.36 Climate_CHELSAv2.1-gdgfgd0_cell 6.37 Climate_CHELSAv2.1-gdgfgd10_cell 6.38 Climate_CHELSAv2.1-gdgfgd5_cell 6.39 Climate_CHELSAv2.1-gsl_cell 6.40 Climate_CHELSAv2.1-gsp_cell 6.41 Climate_CHELSAv2.1-gst_cell 6.42 Climate_CHELSAv2.1-hurs-max_cell 6.43 Climate_CHELSAv2.1-hurs-mean_cell 6.44 Climate_CHELSAv2.1-hurs-min_cell 6.45 Climate_CHELSAv2.1-hurs-range_cell 6.46 Climate_CHELSAv2.1-lgd_cell 6.47 Climate_CHELSAv2.1-ngd0_cell 6.48 Climate_CHELSAv2.1-ngd10_cell 6.49 Climate_CHELSAv2.1-ngd5_cell 6.50 Climate_CHELSAv2.1-npp_cell 6.51 Climate_CHELSAv2.1-pet-penman-max_cell 6.52 Climate_CHELSAv2.1-pet-penman-mean_cell 6.53 Climate_CHELSAv2.1-pet-penman-min_cell 6.54 Climate_CHELSAv2.1-pet-penman-range_cell 6.55 Climate_CHELSAv2.1-rsds-max_cell 6.56 Climate_CHELSAv2.1-rsds-mean_cell 6.57 Climate_CHELSAv2.1-rsds-min_cell 6.58 Climate_CHELSAv2.1-rsds-range_cell 6.59 Climate_CHELSAv2.1-scd_cell 6.60 Climate_CHELSAv2.1-sfcWind-max_cell 6.61 Climate_CHELSAv2.1-sfcWind-mean_cell 6.62 Climate_CHELSAv2.1-sfcWind-min_cell 6.63 Climate_CHELSAv2.1-sfcWind-range_cell 6.64 Climate_CHELSAv2.1-swb_cell 6.65 Climate_CHELSAv2.1-swe_cell 6.66 Climate_CHELSAv2.1-vpd-max_cell 6.67 Climate_CHELSAv2.1-vpd-mean_cell 6.68 Climate_CHELSAv2.1-vpd-min_cell 6.69 Climate_CHELSAv2.1-vpd-range_cell 6.70 HydroClim_01-max_cell 6.71 HydroClim_02-max_cell 6.72 HydroClim_03-max_cell 6.73 HydroClim_04-max_cell 6.74 HydroClim_05-max_cell 6.75 HydroClim_06-min_cell 6.76 HydroClim_07-max_cell 6.77 HydroClim_08-max_cell 6.78 HydroClim_09-min_cell 6.79 HydroClim_10-max_cell 6.80 HydroClim_11-min_cell 6.81 HydroClim_12-max_cell 6.82 HydroClim_13-max_cell 6.83 HydroClim_14-max_cell 6.84 HydroClim_15-max_cell 6.85 HydroClim_16-max_cell 6.86 HydroClim_17-max_cell 6.87 HydroClim_18-max_cell 6.88 HydroClim_19-max_cell 6.89 Distance_Builtup_cell 6.90 Distance_ForestInside_cell 6.91 Distance_GrasslandPermanent_cell 6.92 Distance_Landfill_cell 6.93 Distance_Sea_cell 6.94 Distance_Trees_cell 6.95 Distance_Waste_cell 6.96 Distance_Water_cell 6.97 Distance_WaterInside_cell 6.98 Diversity_Farmland_r500 6.99 Diversity_Farmland_r1250 6.100 Diversity_Farmland_r3000 6.101 Diversity_Farmland_r10000 6.102 Diversity_Forest_r500 6.103 Diversity_Forest_r1250 6.104 Diversity_Forest_r3000 6.105 Diversity_Forest_r10000 6.106 Diversity_Total_r500 6.107 Diversity_Total_r1250 6.108 Diversity_Total_r3000 6.109 Diversity_Total_r10000 6.110 Edges_Bogs-Trees_cell 6.111 Edges_Bogs-Trees_r500 6.112 Edges_Bogs-Trees_r1250 6.113 Edges_Bogs-Trees_r3000 6.114 Edges_Bogs-Trees_r10000 6.115 Edges_Bogs-Water_cell 6.116 Edges_Bogs-Water_r500 6.117 Edges_Bogs-Water_r1250 6.118 Edges_Bogs-Water_r3000 6.119 Edges_Bogs-Water_r10000 6.120 Edges_Farmland-Builtup_cell 6.121 Edges_Farmland-Builtup_r500 6.122 Edges_Farmland-Builtup_r1250 6.123 Edges_Farmland-Builtup_r3000 6.124 Edges_Farmland-Builtup_r10000 6.125 Edges_Trees-Builtup_cell 6.126 Edges_Trees-Builtup_r500 6.127 Edges_Trees-Builtup_r1250 6.128 Edges_Trees-Builtup_r3000 6.129 Edges_Trees-Builtup_r10000 6.130 Edges_CropsFallow_cell 6.131 Edges_CropsFallow_r500 6.132 Edges_CropsFallow_r1250 6.133 Edges_CropsFallow_r3000 6.134 Edges_CropsFallow_r10000 6.135 Edges_FarmlandShrubs-Trees_cell 6.136 Edges_FarmlandShrubs-Trees_r500 6.137 Edges_FarmlandShrubs-Trees_r1250 6.138 Edges_FarmlandShrubs-Trees_r3000 6.139 Edges_FarmlandShrubs-Trees_r10000 6.140 Edges_Grasslands_cell 6.141 Edges_Grasslands_r500 6.142 Edges_Grasslands_r1250 6.143 Edges_Grasslands_r3000 6.144 Edges_Grasslands_r10000 6.145 Edges_OldForests_cell 6.146 Edges_OldForests_r500 6.147 Edges_OldForests_r1250 6.148 Edges_OldForests_r3000 6.149 Edges_OldForests_r10000 6.150 Edges_Roads_cell 6.151 Edges_Roads_r500 6.152 Edges_Roads_r1250 6.153 Edges_Roads_r3000 6.154 Edges_Roads_r10000 6.155 Edges_Trees_cell 6.156 Edges_Trees_r500 6.157 Edges_Trees_r1250 6.158 Edges_Trees_r3000 6.159 Edges_Trees_r10000 6.160 Edges_Water_cell 6.161 Edges_Water_r500 6.162 Edges_Water_r1250 6.163 Edges_Water_r3000 6.164 Edges_Water_r10000 6.165 Edges_Water-Farmland_cell 6.166 Edges_Water-Farmland_r500 6.167 Edges_Water-Farmland_r1250 6.168 Edges_Water-Farmland_r3000 6.169 Edges_Water-Farmland_r10000 6.170 Edges_Water-Grassland_cell 6.171 Edges_Water-Grassland_r500 6.172 Edges_Water-Grassland_r1250 6.173 Edges_Water-Grassland_r3000 6.174 Edges_Water-Grassland_r10000 6.175 Edges_ReedSedgeRushBeds-Water_cell 6.176 Edges_ReedSedgeRushBeds-Water_r500 6.177 Edges_ReedSedgeRushBeds-Water_r1250 6.178 Edges_ReedSedgeRushBeds-Water_r3000 6.179 Edges_ReedSedgeRushBeds-Water_r10000 6.180 FarmlandCrops_CropsAll_cell 6.181 FarmlandCrops_CropsAll_r500 6.182 FarmlandCrops_CropsAll_r1250 6.183 FarmlandCrops_CropsAll_r3000 6.184 FarmlandCrops_CropsAll_r10000 6.185 FarmlandCrops_CropsHoed_cell 6.186 FarmlandCrops_CropsHoed_r500 6.187 FarmlandCrops_CropsHoed_r1250 6.188 FarmlandCrops_CropsHoed_r3000 6.189 FarmlandCrops_CropsHoed_r10000 6.190 FarmlandCrops_CropsOther_cell 6.191 FarmlandCrops_CropsOther_r500 6.192 FarmlandCrops_CropsOther_r1250 6.193 FarmlandCrops_CropsOther_r3000 6.194 FarmlandCrops_CropsOther_r10000 6.195 FarmlandCrops_CropsSpring_cell 6.196 FarmlandCrops_CropsSpring_r500 6.197 FarmlandCrops_CropsSpring_r1250 6.198 FarmlandCrops_CropsSpring_r3000 6.199 FarmlandCrops_CropsSpring_r10000 6.200 FarmlandCrops_CropsWinter_cell 6.201 FarmlandCrops_CropsWinter_r500 6.202 FarmlandCrops_CropsWinter_r1250 6.203 FarmlandCrops_CropsWinter_r3000 6.204 FarmlandCrops_CropsWinter_r10000 6.205 FarmlandCrops_RapeseedsSpring_cell 6.206 FarmlandCrops_RapeseedsSpring_r500 6.207 FarmlandCrops_RapeseedsSpring_r1250 6.208 FarmlandCrops_RapeseedsSpring_r3000 6.209 FarmlandCrops_RapeseedsSpring_r10000 6.210 FarmlandCrops_RapeseedsWinter_cell 6.211 FarmlandCrops_RapeseedsWinter_r500 6.212 FarmlandCrops_RapeseedsWinter_r1250 6.213 FarmlandCrops_RapeseedsWinter_r3000 6.214 FarmlandCrops_RapeseedsWinter_r10000 6.215 FarmlandGrassland_GrasslandsAbandoned_cell 6.216 FarmlandGrassland_GrasslandsAbandoned_r500 6.217 FarmlandGrassland_GrasslandsAbandoned_r1250 6.218 FarmlandGrassland_GrasslandsAbandoned_r3000 6.219 FarmlandGrassland_GrasslandsAbandoned_r10000 6.220 FarmlandGrassland_GrasslandsAll_cell 6.221 FarmlandGrassland_GrasslandsAll_r500 6.222 FarmlandGrassland_GrasslandsAll_r1250 6.223 FarmlandGrassland_GrasslandsAll_r3000 6.224 FarmlandGrassland_GrasslandsAll_r10000 6.225 FarmlandGrassland_GrasslandsPermanent_cell 6.226 FarmlandGrassland_GrasslandsPermanent_r500 6.227 FarmlandGrassland_GrasslandsPermanent_r1250 6.228 FarmlandGrassland_GrasslandsPermanent_r3000 6.229 FarmlandGrassland_GrasslandsPermanent_r10000 6.230 FarmlandGrassland_GrasslandsTemporary_cell 6.231 FarmlandGrassland_GrasslandsTemporary_r500 6.232 FarmlandGrassland_GrasslandsTemporary_r1250 6.233 FarmlandGrassland_GrasslandsTemporary_r3000 6.234 FarmlandGrassland_GrasslandsTemporary_r10000 6.235 FarmlandParcels_FieldsActive_cell 6.236 FarmlandParcels_FieldsActive_r500 6.237 FarmlandParcels_FieldsActive_r1250 6.238 FarmlandParcels_FieldsActive_r3000 6.239 FarmlandParcels_FieldsActive_r10000 6.240 FarmlandPloughed_CropsFallow_cell 6.241 FarmlandPloughed_CropsFallow_r500 6.242 FarmlandPloughed_CropsFallow_r1250 6.243 FarmlandPloughed_CropsFallow_r3000 6.244 FarmlandPloughed_CropsFallow_r10000 6.245 FarmlandPloughed_CropsFallowTempGrass_cell 6.246 FarmlandPloughed_CropsFallowTempGrass_r500 6.247 FarmlandPloughed_CropsFallowTempGrass_r1250 6.248 FarmlandPloughed_CropsFallowTempGrass_r3000 6.249 FarmlandPloughed_CropsFallowTempGrass_r10000 6.250 FarmlandPloughed_Fallow_cell 6.251 FarmlandPloughed_Fallow_r500 6.252 FarmlandPloughed_Fallow_r1250 6.253 FarmlandPloughed_Fallow_r3000 6.254 FarmlandPloughed_Fallow_r10000 6.255 FarmlandSubsidies_BiologicalSubsidies_cell 6.256 FarmlandSubsidies_BiologicalSubsidies_r500 6.257 FarmlandSubsidies_BiologicalSubsidies_r1250 6.258 FarmlandSubsidies_BiologicalSubsidies_r3000 6.259 FarmlandSubsidies_BiologicalSubsidies_r10000 6.260 FarmlandTrees_PermanentCrops_cell 6.261 FarmlandTrees_PermanentCrops_r500 6.262 FarmlandTrees_PermanentCrops_r1250 6.263 FarmlandTrees_PermanentCrops_r3000 6.264 FarmlandTrees_PermanentCrops_r10000 6.265 FarmlandTrees_ShortRotationCoppice_cell 6.266 FarmlandTrees_ShortRotationCoppice_r500 6.267 FarmlandTrees_ShortRotationCoppice_r1250 6.268 FarmlandTrees_ShortRotationCoppice_r3000 6.269 FarmlandTrees_ShortRotationCoppice_r10000 6.270 ForestsAge_ClearcutsLowStands_cell 6.271 ForestsAge_ClearcutsLowStands_r500 6.272 ForestsAge_ClearcutsLowStands_r1250 6.273 ForestsAge_ClearcutsLowStands_r3000 6.274 ForestsAge_ClearcutsLowStands_r10000 6.275 ForestsAge_Middle_cell 6.276 ForestsAge_Middle_r500 6.277 ForestsAge_Middle_r1250 6.278 ForestsAge_Middle_r3000 6.279 ForestsAge_Middle_r10000 6.280 ForestsAge_Old_cell 6.281 ForestsAge_Old_r500 6.282 ForestsAge_Old_r1250 6.283 ForestsAge_Old_r3000 6.284 ForestsAge_Old_r10000 6.285 ForestsAge_YoungTallStandsShrubs_cell 6.286 ForestsAge_YoungTallStandsShrubs_r500 6.287 ForestsAge_YoungTallStandsShrubs_r1250 6.288 ForestsAge_YoungTallStandsShrubs_r3000 6.289 ForestsAge_YoungTallStandsShrubs_r10000 6.290 ForestsQuant_AgeProp-average_cell 6.291 ForestsQuant_DominantDiameter-max_cell 6.292 ForestsQuant_LargestDiameter-max_cell 6.293 ForestsQuant_TimeSinceDisturbance-average_cell 6.294 ForestsQuant_VolumeAspen-sum_cell 6.295 ForestsQuant_VolumeBirch-sum_cell 6.296 ForestsQuant_VolumeBlackAlder-sum_cell 6.297 ForestsQuant_VolumeBorealDeciduousOther-sum_cell 6.298 ForestsQuant_VolumeBorealDeciduousTotal-sum_cell 6.299 ForestsQuant_VolumeConiferous-sum_cell 6.300 ForestsQuant_VolumeOak-sum_cell 6.301 ForestsQuant_VolumeOakMaple-sum_cell 6.302 ForestsQuant_VolumePine-sum_cell 6.303 ForestsQuant_VolumeSpruce-sum_cell 6.304 ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell 6.305 ForestsQuant_VolumeTemperateWithoutOak-sum_cell 6.306 ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell 6.307 ForestsQuant_VolumeTotal-sum_cell 6.308 ForestsSoil_EutrophicDrained_cell 6.309 ForestsSoil_EutrophicDrained_r500 6.310 ForestsSoil_EutrophicDrained_r1250 6.311 ForestsSoil_EutrophicDrained_r3000 6.312 ForestsSoil_EutrophicDrained_r10000 6.313 ForestsSoil_EutrophicMineral_cell 6.314 ForestsSoil_EutrophicMineral_r500 6.315 ForestsSoil_EutrophicMineral_r1250 6.316 ForestsSoil_EutrophicMineral_r3000 6.317 ForestsSoil_EutrophicMineral_r10000 6.318 ForestsSoil_EutrophicOrganic_cell 6.319 ForestsSoil_EutrophicOrganic_r500 6.320 ForestsSoil_EutrophicOrganic_r1250 6.321 ForestsSoil_EutrophicOrganic_r3000 6.322 ForestsSoil_EutrophicOrganic_r10000 6.323 ForestsSoil_MesotrophicMineral_cell 6.324 ForestsSoil_MesotrophicMineral_r500 6.325 ForestsSoil_MesotrophicMineral_r1250 6.326 ForestsSoil_MesotrophicMineral_r3000 6.327 ForestsSoil_MesotrophicMineral_r10000 6.328 ForestsSoil_OligotrophicDrained_cell 6.329 ForestsSoil_OligotrophicDrained_r500 6.330 ForestsSoil_OligotrophicDrained_r1250 6.331 ForestsSoil_OligotrophicDrained_r3000 6.332 ForestsSoil_OligotrophicDrained_r10000 6.333 ForestsSoil_OligotrophicMineral_cell 6.334 ForestsSoil_OligotrophicMineral_r500 6.335 ForestsSoil_OligotrophicMineral_r1250 6.336 ForestsSoil_OligotrophicMineral_r3000 6.337 ForestsSoil_OligotrophicMineral_r10000 6.338 ForestsSoil_OligotrophicOrganic_cell 6.339 ForestsSoil_OligotrophicOrganic_r500 6.340 ForestsSoil_OligotrophicOrganic_r1250 6.341 ForestsSoil_OligotrophicOrganic_r3000 6.342 ForestsSoil_OligotrophicOrganic_r10000 6.343 ForestsTreesAge_BorealDeciduousOld_cell 6.344 ForestsTreesAge_BorealDeciduousOld_r500 6.345 ForestsTreesAge_BorealDeciduousOld_r1250 6.346 ForestsTreesAge_BorealDeciduousOld_r3000 6.347 ForestsTreesAge_BorealDeciduousOld_r10000 6.348 ForestsTreesAge_BorealDeciduousYoung_cell 6.349 ForestsTreesAge_BorealDeciduousYoung_r500 6.350 ForestsTreesAge_BorealDeciduousYoung_r1250 6.351 ForestsTreesAge_BorealDeciduousYoung_r3000 6.352 ForestsTreesAge_BorealDeciduousYoung_r10000 6.353 ForestsTreesAge_ConiferousOld_cell 6.354 ForestsTreesAge_ConiferousOld_r500 6.355 ForestsTreesAge_ConiferousOld_r1250 6.356 ForestsTreesAge_ConiferousOld_r3000 6.357 ForestsTreesAge_ConiferousOld_r10000 6.358 ForestsTreesAge_ConiferousYoung_cell 6.359 ForestsTreesAge_ConiferousYoung_r500 6.360 ForestsTreesAge_ConiferousYoung_r1250 6.361 ForestsTreesAge_ConiferousYoung_r3000 6.362 ForestsTreesAge_ConiferousYoung_r10000 6.363 ForestsTreesAge_MixedOld_cell 6.364 ForestsTreesAge_MixedOld_r500 6.365 ForestsTreesAge_MixedOld_r1250 6.366 ForestsTreesAge_MixedOld_r3000 6.367 ForestsTreesAge_MixedOld_r10000 6.368 ForestsTreesAge_MixedYoung_cell 6.369 ForestsTreesAge_MixedYoung_r500 6.370 ForestsTreesAge_MixedYoung_r1250 6.371 ForestsTreesAge_MixedYoung_r3000 6.372 ForestsTreesAge_MixedYoung_r10000 6.373 ForestsTreesAge_TemperateDeciduousOld_cell 6.374 ForestsTreesAge_TemperateDeciduousOld_r500 6.375 ForestsTreesAge_TemperateDeciduousOld_r1250 6.376 ForestsTreesAge_TemperateDeciduousOld_r3000 6.377 ForestsTreesAge_TemperateDeciduousOld_r10000 6.378 ForestsTreesAge_TemperateDeciduousYoung_cell 6.379 ForestsTreesAge_TemperateDeciduousYoung_r500 6.380 ForestsTreesAge_TemperateDeciduousYoung_r1250 6.381 ForestsTreesAge_TemperateDeciduousYoung_r3000 6.382 ForestsTreesAge_TemperateDeciduousYoung_r10000 6.383 ForestsTrees_BorealDeciduous_cell 6.384 ForestsTrees_BorealDeciduous_r500 6.385 ForestsTrees_BorealDeciduous_r1250 6.386 ForestsTrees_BorealDeciduous_r3000 6.387 ForestsTrees_BorealDeciduous_r10000 6.388 ForestsTrees_Coniferous_cell 6.389 ForestsTrees_Coniferous_r500 6.390 ForestsTrees_Coniferous_r1250 6.391 ForestsTrees_Coniferous_r3000 6.392 ForestsTrees_Coniferous_r10000 6.393 ForestsTrees_Mixed_cell 6.394 ForestsTrees_Mixed_r500 6.395 ForestsTrees_Mixed_r1250 6.396 ForestsTrees_Mixed_r3000 6.397 ForestsTrees_Mixed_r10000 6.398 ForestsTrees_TemperateDeciduous_cell 6.399 ForestsTrees_TemperateDeciduous_r500 6.400 ForestsTrees_TemperateDeciduous_r1250 6.401 ForestsTrees_TemperateDeciduous_r3000 6.402 ForestsTrees_TemperateDeciduous_r10000 6.403 General_AllotmentGardens_cell 6.404 General_AllotmentGardens_r500 6.405 General_AllotmentGardens_r1250 6.406 General_AllotmentGardens_r3000 6.407 General_AllotmentGardens_r10000 6.408 General_BareSoilQuarry_cell 6.409 General_BareSoilQuarry_r500 6.410 General_BareSoilQuarry_r1250 6.411 General_BareSoilQuarry_r3000 6.412 General_BareSoilQuarry_r10000 6.413 General_Builtup_cell 6.414 General_Builtup_r500 6.415 General_Builtup_r1250 6.416 General_Builtup_r3000 6.417 General_Builtup_r10000 6.418 General_Farmland_cell 6.419 General_Farmland_r500 6.420 General_Farmland_r1250 6.421 General_Farmland_r3000 6.422 General_Farmland_r10000 6.423 General_ForestsWithoutInventory_cell 6.424 General_ForestsWithoutInventory_r500 6.425 General_ForestsWithoutInventory_r1250 6.426 General_ForestsWithoutInventory_r3000 6.427 General_ForestsWithoutInventory_r10000 6.428 General_GardensOrchards_cell 6.429 General_GardensOrchards_r500 6.430 General_GardensOrchards_r1250 6.431 General_GardensOrchards_r3000 6.432 General_GardensOrchards_r10000 6.433 General_Roads_cell 6.434 General_ShrubsOrchards_cell 6.435 General_ShrubsOrchards_r500 6.436 General_ShrubsOrchards_r1250 6.437 General_ShrubsOrchards_r3000 6.438 General_ShrubsOrchards_r10000 6.439 General_ShrubsOrchardsGardens_cell 6.440 General_ShrubsOrchardsGardens_r500 6.441 General_ShrubsOrchardsGardens_r1250 6.442 General_ShrubsOrchardsGardens_r3000 6.443 General_ShrubsOrchardsGardens_r10000 6.444 General_SwampsMiresBogsHelophytes_cell 6.445 General_SwampsMiresBogsHelophytes_r500 6.446 General_SwampsMiresBogsHelophytes_r1250 6.447 General_SwampsMiresBogsHelophytes_r3000 6.448 General_SwampsMiresBogsHelophytes_r10000 6.449 General_Trees_cell 6.450 General_Trees_r500 6.451 General_Trees_r1250 6.452 General_Trees_r3000 6.453 General_Trees_r10000 6.454 General_TreesOutsideForests_cell 6.455 General_TreesOutsideForests_r500 6.456 General_TreesOutsideForests_r1250 6.457 General_TreesOutsideForests_r3000 6.458 General_TreesOutsideForests_r10000 6.459 General_Water_cell 6.460 General_Water_r500 6.461 General_Water_r1250 6.462 General_Water_r3000 6.463 General_Water_r10000 6.464 Wetlands_Bogs_cell 6.465 Wetlands_Bogs_r500 6.466 Wetlands_Bogs_r1250 6.467 Wetlands_Bogs_r3000 6.468 Wetlands_Bogs_r10000 6.469 Wetlands_Mires_cell 6.470 Wetlands_Mires_r500 6.471 Wetlands_Mires_r1250 6.472 Wetlands_Mires_r3000 6.473 Wetlands_Mires_r10000 6.474 Wetlands_ReedSedgeRushBeds_cell 6.475 Wetlands_ReedSedgeRushBeds_r500 6.476 Wetlands_ReedSedgeRushBeds_r1250 6.477 Wetlands_ReedSedgeRushBeds_r3000 6.478 Wetlands_ReedSedgeRushBeds_r10000 6.479 EO_NDMI-LYmed-average_cell 6.480 EO_NDMI-LYmedian-iqr_cell 6.481 EO_NDMI-STiqr-median_cell 6.482 EO_NDMI-STmedian-average_cell 6.483 EO_NDMI-STmedian-iqr_cell 6.484 EO_NDMI-STp25-min_cell 6.485 EO_NDMI-STp75-max_cell 6.486 EO_NDVI-LYmedian-average_cell 6.487 EO_NDVI-LYmedian-iqr_cell 6.488 EO_NDVI-STiqr-median_cell 6.489 EO_NDVI-STmedian-average_cell 6.490 EO_NDVI-STmedian-iqr_cell 6.491 EO_NDVI-STp25-min_cell 6.492 EO_NDVI-STp75-max_cell 6.493 EO_NDWI-LYmedian-average_cell 6.494 EO_NDWI-LYmedian-iqr_cell 6.495 EO_NDWI-STiqr-median_cell 6.496 EO_NDWI-STmedian-average_cell 6.497 EO_NDWI-STmedian-iqr_cell 6.498 EO_NDWI-STp25-min_cell 6.499 EO_NDWI-STp75-max_cell 6.500 SoilChemistry_ESDAC-CN_cell 6.501 SoilChemistry_ESDAC-CaCo3_cell 6.502 SoilChemistry_ESDAC-K_cell 6.503 SoilChemistry_ESDAC-N_cell 6.504 SoilChemistry_ESDAC-P_cell 6.505 SoilChemistry_ESDAC-phH2O_cell 6.506 SoilTexture_Clay_cell 6.507 SoilTexture_Clay_r500 6.508 SoilTexture_Clay_r1250 6.509 SoilTexture_Clay_r3000 6.510 SoilTexture_Clay_r10000 6.511 SoilTexture_Organic_cell 6.512 SoilTexture_Organic_r500 6.513 SoilTexture_Organic_r1250 6.514 SoilTexture_Organic_r3000 6.515 SoilTexture_Organic_r10000 6.516 SoilTexture_Sand_cell 6.517 SoilTexture_Sand_r500 6.518 SoilTexture_Sand_r1250 6.519 SoilTexture_Sand_r3000 6.520 SoilTexture_Sand_r10000 6.521 SoilTexture_Silt_cell 6.522 SoilTexture_Silt_r500 6.523 SoilTexture_Silt_r1250 6.524 SoilTexture_Silt_r3000 6.525 SoilTexture_Silt_r10000 6.526 Terrain_ASL-average_cell 6.527 Terrain_Aspect-average_cell 6.528 Terrain_Aspect-iqr_cell 6.529 Terrain_DiS-area_cell 6.530 Terrain_DiS-area_r500 6.531 Terrain_DiS-area_r1250 6.532 Terrain_DiS-area_r3000 6.533 Terrain_DiS-area_r10000 6.534 Terrain_DiS-max_cell 6.535 Terrain_DiS-mean_cell 6.536 Terrain_Slope-average_cell 6.537 Terrain_Slope-iqr_cell 6.538 Terrain_TWI-average_cell", " 6 Ecogeographical variables This section names and provides description (R code with its explanation in procedure) of each of the 538 EGVs created. For a better undestanding of the relatedness of these vairables, refer to the flowchart below (Fig. 6.1). The names used in figure correspond to EGV layer names and follow naming convention: [group] _ [specific name] _ [scale], where: group is a broader collection of EGVs describing the same phenomena or ecosystem, derived from the same source, etc.; specific name briefly describes the landscape class and/or metrics used in the creation of the layer; scale is one of: cell, 500, 1250, 3000, 10000 m around the centre of the EGV-cell. The resolution of each EGV is 1 ha; larger scales are summarised to this resolution. Figure 6.1: Relationships of ecogeographical variables created. For cover fraction and edge variables, we first calculated values at the EGV-cell resolution and then used {exactextract} to summarise values from larger scales. This package uses pixel area weights to calculate weighted summary statistics, making the aggregation error negligible, particularly at larger scales, but reduces computation time thousands up to even hundreds of thousands times compared to input resolution (10 m). To further speed up the procedures, we used “sparse” mode in the workflow egvtools::radius_function(), thus summarising zonal statistics every 300 m for 3000 m radius buffers and every 1000 m for 10000 m buffers, obtaining near linear reduction in time relative to the number of zones (ninefold and 100 fold further computation time reduction), while loosing less than 0.001 % of variability overall. We used a slightly different approach with diversity metrics. First, we calculated Shanon’s diversity index at 25 ha raster grid cells, as there is nearly no variability of landscape classes at 1 ha grid cells. Next, we calculated arithmetic mean as zonal statictics value (using the “sparse” mode with the workflow egvtools::radius_function()), but we did not create this EGV at the analysis cells scale. 6.1 Climate_CHELSAv2.1-bio1_cell filename: Climate_CHELSAv2.1-bio1_cell.tif layername: egv_001 English name: Mean annual daily mean air temperature (°C) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējā ikdienas gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio1_cell.tif&quot; layername=&quot;egv_001&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio1_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio1_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.2 Climate_CHELSAv2.1-bio10_cell filename: Climate_CHELSAv2.1-bio10_cell.tif layername: egv_002 English name: Mean daily mean air temperatures (°C) of the warmest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada siltākā ceturkšņa vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio10_cell.tif&quot; layername=&quot;egv_002&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio10_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio10_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.3 Climate_CHELSAv2.1-bio11_cell filename: Climate_CHELSAv2.1-bio11_cell.tif layername: egv_003 English name: Mean daily mean air temperatures (°C) of the coldest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada aukstākā ceturkšņa vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio11_cell.tif&quot; layername=&quot;egv_003&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio11_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio11_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.4 Climate_CHELSAv2.1-bio12_cell filename: Climate_CHELSAv2.1-bio12_cell.tif layername: egv_004 English name: Annual precipitation amount (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada nokrišņu daudzums (kg m⁻² gadā) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio12_cell.tif&quot; layername=&quot;egv_004&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio12_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio12_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.5 Climate_CHELSAv2.1-bio13_cell filename: Climate_CHELSAv2.1-bio13_cell.tif layername: egv_005 English name: Precipitation amount (kg m⁻² month⁻¹) of the wettest month (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Slapjākā mēneša nokrišņu daudzums (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio13_cell.tif&quot; layername=&quot;egv_005&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio13_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio13_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.6 Climate_CHELSAv2.1-bio14_cell filename: Climate_CHELSAv2.1-bio14_cell.tif layername: egv_006 English name: Precipitation amount (kg m⁻² month⁻¹) of the driest month (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Sausākā mēneša nokrišņu daudzums (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio14_cell.tif&quot; layername=&quot;egv_006&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio14_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio14_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.7 Climate_CHELSAv2.1-bio15_cell filename: Climate_CHELSAv2.1-bio15_cell.tif layername: egv_007 English name: Precipitation seasonality (kg m⁻²) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Nokrišņu sezonalitāte (kg m⁻²) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio15_cell.tif&quot; layername=&quot;egv_007&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio15_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio15_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.8 Climate_CHELSAv2.1-bio16_cell filename: Climate_CHELSAv2.1-bio16_cell.tif layername: egv_008 English name: Mean monthly precipitation amount (kg m⁻² month⁻¹) of the wettest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Slapjākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio16_cell.tif&quot; layername=&quot;egv_008&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio16_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio16_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.9 Climate_CHELSAv2.1-bio17_cell filename: Climate_CHELSAv2.1-bio17_cell.tif layername: egv_009 English name: Mean monthly precipitation amount (kg m⁻² month⁻¹) of the driest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Sausākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio17_cell.tif&quot; layername=&quot;egv_009&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio17_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio17_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.10 Climate_CHELSAv2.1-bio18_cell filename: Climate_CHELSAv2.1-bio18_cell.tif layername: egv_010 English name: Mean monthly precipitation amount (kg m⁻² month⁻¹) of the warmest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Siltākā ceturkšņa vidējais nokrišņu daudzuma mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio18_cell.tif&quot; layername=&quot;egv_010&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio18_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio18_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.11 Climate_CHELSAv2.1-bio19_cell filename: Climate_CHELSAv2.1-bio19_cell.tif layername: egv_011 English name: Mean monthly precipitation amount (kg m⁻² month⁻¹) of the coldest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Aukstākā ceturkšņa vidējais nokrišņu daudzums mēnesī (kg m⁻² mēnesī) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio19_cell.tif&quot; layername=&quot;egv_011&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio19_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio19_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.12 Climate_CHELSAv2.1-bio2_cell filename: Climate_CHELSAv2.1-bio2_cell.tif layername: egv_012 English name: Mean diurnal air temperature range (°C) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Diennakts temperatūru amplitūda (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio2_cell.tif&quot; layername=&quot;egv_012&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio2_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio2_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.13 Climate_CHELSAv2.1-bio3_cell filename: Climate_CHELSAv2.1-bio3_cell.tif layername: egv_013 English name: Isothermality (ratio of diurnal variation to annual variation in temperatures) (°C) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Izotermalitāte (attiecība starp diennakts un gada temperatūras svārstībām) (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio3_cell.tif&quot; layername=&quot;egv_013&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio3_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio3_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.14 Climate_CHELSAv2.1-bio4_cell filename: Climate_CHELSAv2.1-bio4_cell.tif layername: egv_014 English name: Temperature seasonality (standard deviation of the monthly mean temperatures) (°C/100) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Temperatūru sezonalitāte (mēneša vidējo temperatūru standartnovirze) (°C/100) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio4_cell.tif&quot; layername=&quot;egv_014&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio4_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio4_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.15 Climate_CHELSAv2.1-bio5_cell filename: Climate_CHELSAv2.1-bio5_cell.tif layername: egv_015 English name: Mean daily maximum air temperature (°C) of the warmest month (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Siltākā mēneša vidējā ikdienas augstākā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio5_cell.tif&quot; layername=&quot;egv_015&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio5_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio5_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.16 Climate_CHELSAv2.1-bio6_cell filename: Climate_CHELSAv2.1-bio6_cell.tif layername: egv_016 English name: Mean daily minimum air temperature (°C) of the coldest month (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Aukstākā mēneša vidējā ikdienas zemākā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio6_cell.tif&quot; layername=&quot;egv_016&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio6_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio6_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.17 Climate_CHELSAv2.1-bio7_cell filename: Climate_CHELSAv2.1-bio7_cell.tif layername: egv_017 English name: Annual range of air temperature (°C) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada temperatūru amplitūda (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio7_cell.tif&quot; layername=&quot;egv_017&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio7_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio7_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.18 Climate_CHELSAv2.1-bio8_cell filename: Climate_CHELSAv2.1-bio8_cell.tif layername: egv_018 English name: Mean daily mean air temperatures (°C) of the wettest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Slapjākā ceturkšņa vidējā ikdienas vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio8_cell.tif&quot; layername=&quot;egv_018&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio8_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio8_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.19 Climate_CHELSAv2.1-bio9_cell filename: Climate_CHELSAv2.1-bio9_cell.tif layername: egv_019 English name: Mean daily mean air temperatures (°C) of the driest quarter (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Sausākā ceturkšņa vidējā ikdienas vidējā gaisa temperatūra (°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-bio9_cell.tif&quot; layername=&quot;egv_019&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-bio9_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-bio9_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.20 Climate_CHELSAv2.1-clt-max_cell filename: Climate_CHELSAv2.1-clt-max_cell.tif layername: egv_020 English name: Maximum monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālais mēneša vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-clt-max_cell.tif&quot; layername=&quot;egv_020&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-clt-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.21 Climate_CHELSAv2.1-clt-mean_cell filename: Climate_CHELSAv2.1-clt-mean_cell.tif layername: egv_021 English name: Mean monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-clt-mean_cell.tif&quot; layername=&quot;egv_021&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-clt-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.22 Climate_CHELSAv2.1-clt-min_cell filename: Climate_CHELSAv2.1-clt-min_cell.tif layername: egv_022 English name: Minimum monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālais mēneša vidējais mākoņu segums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-clt-min_cell.tif&quot; layername=&quot;egv_022&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-clt-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.23 Climate_CHELSAv2.1-clt-range_cell filename: Climate_CHELSAv2.1-clt-range_cell.tif layername: egv_023 English name: Annual range of monthly cloud area fraction (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada mākoņu seguma amplitūda (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-clt-range_cell.tif&quot; layername=&quot;egv_023&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-clt-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-clt-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.24 Climate_CHELSAv2.1-cmi-max_cell filename: Climate_CHELSAv2.1-cmi-max_cell.tif layername: egv_024 English name: Maximum monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālais mēneša vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-cmi-max_cell.tif&quot; layername=&quot;egv_024&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-cmi-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.25 Climate_CHELSAv2.1-cmi-mean_cell filename: Climate_CHELSAv2.1-cmi-mean_cell.tif layername: egv_025 English name: Mean monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-cmi-mean_cell.tif&quot; layername=&quot;egv_025&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-cmi-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.26 Climate_CHELSAv2.1-cmi-min_cell filename: Climate_CHELSAv2.1-cmi-min_cell.tif layername: egv_026 English name: Minimum monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālais mēneša vidējais klimata mitruma indekss (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-cmi-min_cell.tif&quot; layername=&quot;egv_026&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-cmi-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.27 Climate_CHELSAv2.1-cmi-range_cell filename: Climate_CHELSAv2.1-cmi-range_cell.tif layername: egv_027 English name: Annual range of monthly climate moisture index (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada klimata mitruma indeksa amplitūda (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-cmi-range_cell.tif&quot; layername=&quot;egv_027&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-cmi-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-cmi-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.28 Climate_CHELSAv2.1-fcf_cell filename: Climate_CHELSAv2.1-fcf_cell.tif layername: egv_028 English name: Frost change frequency (number of events in which tmin or tmax go above or below 0°C) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Sasalšanas gadījumu biežums (zemākā vai augstākā temperatūra šķērso 0°C) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-fcf_cell.tif&quot; layername=&quot;egv_028&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-fcf_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-fcf_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.29 Climate_CHELSAv2.1-fgd_cell filename: Climate_CHELSAv2.1-fgd_cell.tif layername: egv_029 English name: First day of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pirmā diena (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-fgd_cell.tif&quot; layername=&quot;egv_029&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-fgd_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-fgd_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.30 Climate_CHELSAv2.1-gdd0_cell filename: Climate_CHELSAv2.1-gdd0_cell.tif layername: egv_030 English name: Growing degree days heat sum above 0°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Aktīvo temperatūru summa no 0°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdd0_cell.tif&quot; layername=&quot;egv_030&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd0_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdd0_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.31 Climate_CHELSAv2.1-gdd10_cell filename: Climate_CHELSAv2.1-gdd10_cell.tif layername: egv_031 English name: Growing degree days heat sum above 10°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Aktīvo temperatūru summa no 10°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdd10_cell.tif&quot; layername=&quot;egv_031&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd10_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdd10_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.32 Climate_CHELSAv2.1-gdd5_cell filename: Climate_CHELSAv2.1-gdd5_cell.tif layername: egv_032 English name: Growing degree days heat sum above 5°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Aktīvo temperatūru summa no 5°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdd5_cell.tif&quot; layername=&quot;egv_032&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdd5_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdd5_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.33 Climate_CHELSAv2.1-gddlgd0_cell filename: Climate_CHELSAv2.1-gddlgd0_cell.tif layername: egv_033 English name: Last growing degree day above 0°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pēdējā diena no 0°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gddlgd0_cell.tif&quot; layername=&quot;egv_033&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd0_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gddlgd0_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.34 Climate_CHELSAv2.1-gddlgd10_cell filename: Climate_CHELSAv2.1-gddlgd10_cell.tif layername: egv_034 English name: Last growing degree day above 10°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pēdējā diena no 10°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gddlgd10_cell.tif&quot; layername=&quot;egv_034&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd10_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gddlgd10_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.35 Climate_CHELSAv2.1-gddlgd5_cell filename: Climate_CHELSAv2.1-gddlgd5_cell.tif layername: egv_035 English name: Last growing degree day above 5°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pēdējā diena no 5°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gddlgd5_cell.tif&quot; layername=&quot;egv_035&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gddlgd5_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gddlgd5_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.36 Climate_CHELSAv2.1-gdgfgd0_cell filename: Climate_CHELSAv2.1-gdgfgd0_cell.tif layername: egv_036 English name: First growing degree day above 0°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pirmā diena no 0°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdgfgd0_cell.tif&quot; layername=&quot;egv_036&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd0_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdgfgd0_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.37 Climate_CHELSAv2.1-gdgfgd10_cell filename: Climate_CHELSAv2.1-gdgfgd10_cell.tif layername: egv_037 English name: First growing degree day above 10°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pirmā diena no 10°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdgfgd10_cell.tif&quot; layername=&quot;egv_037&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd10_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdgfgd10_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.38 Climate_CHELSAv2.1-gdgfgd5_cell filename: Climate_CHELSAv2.1-gdgfgd5_cell.tif layername: egv_038 English name: First growing degree day above 5°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas pirmā diena no 5°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gdgfgd5_cell.tif&quot; layername=&quot;egv_038&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gdgfgd5_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gdgfgd5_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.39 Climate_CHELSAv2.1-gsl_cell filename: Climate_CHELSAv2.1-gsl_cell.tif layername: egv_039 English name: Length of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonas garums (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gsl_cell.tif&quot; layername=&quot;egv_039&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gsl_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gsl_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.40 Climate_CHELSAv2.1-gsp_cell filename: Climate_CHELSAv2.1-gsp_cell.tif layername: egv_040 English name: Accumulated precipitation amount (kg m⁻² year⁻¹) on growing season days (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Veģetācijas sezonā (TREELIM) uzkrātais nokrišņu daudzums (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gsp_cell.tif&quot; layername=&quot;egv_040&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gsp_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gsp_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.41 Climate_CHELSAv2.1-gst_cell filename: Climate_CHELSAv2.1-gst_cell.tif layername: egv_041 English name: Mean temperature of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējā ikdienas gaisa temperatūra (°C) veģetācijas sezonā (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-gst_cell.tif&quot; layername=&quot;egv_041&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-gst_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-gst_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.42 Climate_CHELSAv2.1-hurs-max_cell filename: Climate_CHELSAv2.1-hurs-max_cell.tif layername: egv_042 English name: Maximum monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālais mēneša vidējais gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-hurs-max_cell.tif&quot; layername=&quot;egv_042&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-hurs-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.43 Climate_CHELSAv2.1-hurs-mean_cell filename: Climate_CHELSAv2.1-hurs-mean_cell.tif layername: egv_043 English name: Mean monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējais ikmēneša gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-hurs-mean_cell.tif&quot; layername=&quot;egv_043&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-hurs-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.44 Climate_CHELSAv2.1-hurs-min_cell filename: Climate_CHELSAv2.1-hurs-min_cell.tif layername: egv_044 English name: Minimum monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālais mēneša vidējais gaisa mitrums (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-hurs-min_cell.tif&quot; layername=&quot;egv_044&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-hurs-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.45 Climate_CHELSAv2.1-hurs-range_cell filename: Climate_CHELSAv2.1-hurs-range_cell.tif layername: egv_045 English name: Annual range of monthly near-surface relative humidity (%) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada gaisa mitruma amplitūda (%) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-hurs-range_cell.tif&quot; layername=&quot;egv_045&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-hurs-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-hurs-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.46 Climate_CHELSAv2.1-lgd_cell filename: Climate_CHELSAv2.1-lgd_cell.tif layername: egv_046 English name: Last day of the growing season (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Pēdējā veģetācijas sezonas diena (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-lgd_cell.tif&quot; layername=&quot;egv_046&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-lgd_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-lgd_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.47 Climate_CHELSAv2.1-ngd0_cell filename: Climate_CHELSAv2.1-ngd0_cell.tif layername: egv_047 English name: Number of days at which 2m air temperature &gt; 0°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 0°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-ngd0_cell.tif&quot; layername=&quot;egv_047&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd0_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-ngd0_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.48 Climate_CHELSAv2.1-ngd10_cell filename: Climate_CHELSAv2.1-ngd10_cell.tif layername: egv_048 English name: Number of days at which 2m air temperature &gt; 10°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 10°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-ngd10_cell.tif&quot; layername=&quot;egv_048&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd10_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-ngd10_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.49 Climate_CHELSAv2.1-ngd5_cell filename: Climate_CHELSAv2.1-ngd5_cell.tif layername: egv_049 English name: Number of days at which 2m air temperature &gt; 5°C (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Dienu skaits, kurā gaisa temperatūra 2 m augstumā pārsniedz 5°C (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-ngd5_cell.tif&quot; layername=&quot;egv_049&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-ngd5_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-ngd5_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.50 Climate_CHELSAv2.1-npp_cell filename: Climate_CHELSAv2.1-npp_cell.tif layername: egv_050 English name: Net primary productivity (g C m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Neto primārā produkcija (g C m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-npp_cell.tif&quot; layername=&quot;egv_050&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-npp_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-npp_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.51 Climate_CHELSAv2.1-pet-penman-max_cell filename: Climate_CHELSAv2.1-pet-penman-max_cell.tif layername: egv_051 English name: Maximum monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālā mēneša potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-pet-penman-max_cell.tif&quot; layername=&quot;egv_051&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-pet-penman-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.52 Climate_CHELSAv2.1-pet-penman-mean_cell filename: Climate_CHELSAv2.1-pet-penman-mean_cell.tif layername: egv_052 English name: Mean monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējā mēneša potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-pet-penman-mean_cell.tif&quot; layername=&quot;egv_052&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-pet-penman-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.53 Climate_CHELSAv2.1-pet-penman-min_cell filename: Climate_CHELSAv2.1-pet-penman-min_cell.tif layername: egv_053 English name: Minimum monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālā mēneša vidējā potenciālā evapotranspirācija (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-pet-penman-min_cell.tif&quot; layername=&quot;egv_053&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-pet-penman-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.54 Climate_CHELSAv2.1-pet-penman-range_cell filename: Climate_CHELSAv2.1-pet-penman-range_cell.tif layername: egv_054 English name: Annual range of monthly potential evapotranspiration (kg m⁻² month⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada potenciālā evapotranspirācijas amplitūda (kg m⁻² month⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-pet-penman-range_cell.tif&quot; layername=&quot;egv_054&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-pet-penman-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-pet-penman-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.55 Climate_CHELSAv2.1-rsds-max_cell filename: Climate_CHELSAv2.1-rsds-max_cell.tif layername: egv_055 English name: Maximum monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālā mēneša vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-rsds-max_cell.tif&quot; layername=&quot;egv_055&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-rsds-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.56 Climate_CHELSAv2.1-rsds-mean_cell filename: Climate_CHELSAv2.1-rsds-mean_cell.tif layername: egv_056 English name: Mean monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-rsds-mean_cell.tif&quot; layername=&quot;egv_056&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-rsds-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.57 Climate_CHELSAv2.1-rsds-min_cell filename: Climate_CHELSAv2.1-rsds-min_cell.tif layername: egv_057 English name: Minimum monthly surface shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālā mēneša vidējā Zemes virsmu sasniedzošā saules radiācija (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-rsds-min_cell.tif&quot; layername=&quot;egv_057&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-rsds-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.58 Climate_CHELSAv2.1-rsds-range_cell filename: Climate_CHELSAv2.1-rsds-range_cell.tif layername: egv_058 English name: Annual range of monthly surface downwelling shortwave flux in air (MJ m⁻² d⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada amplitūda Zemes virsmu sasniedzošajai saules radiācijai (MJ m⁻² d⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-rsds-range_cell.tif&quot; layername=&quot;egv_058&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-rsds-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-rsds-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.59 Climate_CHELSAv2.1-scd_cell filename: Climate_CHELSAv2.1-scd_cell.tif layername: egv_059 English name: Number of days with snow cover (TREELIM) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Dienu ar sniega segu skaits (TREELIM) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-scd_cell.tif&quot; layername=&quot;egv_059&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-scd_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-scd_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.60 Climate_CHELSAv2.1-sfcWind-max_cell filename: Climate_CHELSAv2.1-sfcWind-max_cell.tif layername: egv_060 English name: Maximum monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālais mēneša vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-sfcWind-max_cell.tif&quot; layername=&quot;egv_060&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-sfcWind-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.61 Climate_CHELSAv2.1-sfcWind-mean_cell filename: Climate_CHELSAv2.1-sfcWind-mean_cell.tif layername: egv_061 English name: Mean monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-sfcWind-mean_cell.tif&quot; layername=&quot;egv_061&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-sfcWind-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.62 Climate_CHELSAv2.1-sfcWind-min_cell filename: Climate_CHELSAv2.1-sfcWind-min_cell.tif layername: egv_062 English name: Minimum monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālais mēneša vidējais piezemes slāņa vēja ātrums (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-sfcWind-min_cell.tif&quot; layername=&quot;egv_062&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-sfcWind-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.63 Climate_CHELSAv2.1-sfcWind-range_cell filename: Climate_CHELSAv2.1-sfcWind-range_cell.tif layername: egv_063 English name: Annual range of monthly near-surface wind speed (m s⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada amplitūda vidējam piezemes slāņa vēja ātrumam (m s⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-sfcWind-range_cell.tif&quot; layername=&quot;egv_063&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-sfcWind-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-sfcWind-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.64 Climate_CHELSAv2.1-swb_cell filename: Climate_CHELSAv2.1-swb_cell.tif layername: egv_064 English name: Site water balance (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Ūdens bilance (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-swb_cell.tif&quot; layername=&quot;egv_064&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-swb_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-swb_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.65 Climate_CHELSAv2.1-swe_cell filename: Climate_CHELSAv2.1-swe_cell.tif layername: egv_065 English name: Snow water equivalent (kg m⁻² year⁻¹) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Ūdens ekvivalents sniegā (kg m⁻² year⁻¹) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-swe_cell.tif&quot; layername=&quot;egv_065&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-swe_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-swe_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.66 Climate_CHELSAv2.1-vpd-max_cell filename: Climate_CHELSAv2.1-vpd-max_cell.tif layername: egv_066 English name: Maximum monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Maksimālais mēneša vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-vpd-max_cell.tif&quot; layername=&quot;egv_066&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-max_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-vpd-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.67 Climate_CHELSAv2.1-vpd-mean_cell filename: Climate_CHELSAv2.1-vpd-mean_cell.tif layername: egv_067 English name: Mean monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-vpd-mean_cell.tif&quot; layername=&quot;egv_067&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-mean_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-vpd-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.68 Climate_CHELSAv2.1-vpd-min_cell filename: Climate_CHELSAv2.1-vpd-min_cell.tif layername: egv_068 English name: Minimum monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Minimālais mēneša vidējais iztvaikošanas spiediena deficīts (Pa) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-vpd-min_cell.tif&quot; layername=&quot;egv_068&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-min_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-vpd-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.69 Climate_CHELSAv2.1-vpd-range_cell filename: Climate_CHELSAv2.1-vpd-range_cell.tif layername: egv_069 English name: Annual range of monthly vapor pressure deficit (Pa) (CHELSA v2.1) within the analysis cell (1 ha) Latvian name: Gada iztvaikošanas spiediena deficīta amplitūda (Pa) (CHELSA v2.1) analīzes šūnā (1 ha) Procedure: Directly follows CHELSA v2.1. EGV is prepared using the workflow egvtools::downscale2egv() with inverse distance weighted (power = 2) gap filling and soft smoothing (power = 0.5) over 5 km radius around each cell. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # job ---- localname=&quot;Climate_CHELSAv2.1-vpd-range_cell.tif&quot; layername=&quot;egv_069&quot; reading=&quot;./Geodata/2024/CHELSA/Climate_CHELSAv2.1-vpd-range_cell.tif&quot; df &lt;- downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = reading, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = localname, layer_name = layername, fill_gaps = TRUE, smooth = TRUE, smooth_radius_km = 5, plot_result = TRUE) print(df) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Climate_CHELSAv2.1-vpd-range_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.70 HydroClim_01-max_cell filename: HydroClim_01-max_cell.tif layername: egv_070 English name: Maximum per subcatchment upstream mean annual air temperature (°C) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā vidējā gaisa temperatūra augštecē (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_01-max_cell.tif&quot; layername=&quot;egv_070&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_01-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.71 HydroClim_02-max_cell filename: HydroClim_02-max_cell.tif layername: egv_071 English name: Maximum per subcatchment upstream mean diurnal air temperature range (°C) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā diennakts gaisa temperatūras amplitūda augštecē (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_02-max_cell.tif&quot; layername=&quot;egv_071&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_02-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.72 HydroClim_03-max_cell filename: HydroClim_03-max_cell.tif layername: egv_072 English name: Maximum per subcatchment upstream isothermality (ratio of diurnal variation to annual variation in temperatures) (°C) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā izotermalitāte augštecē (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_03-max_cell.tif&quot; layername=&quot;egv_072&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_03-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.73 HydroClim_04-max_cell filename: HydroClim_04-max_cell.tif layername: egv_073 English name: Maximum per subcatchment upstream temperature seasonality (standard deviation of the monthly mean temperatures) (°C/100) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā temperatūras sezonalitāte augštecē (°C/100) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_04-max_cell.tif&quot; layername=&quot;egv_073&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_04-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.74 HydroClim_05-max_cell filename: HydroClim_05-max_cell.tif layername: egv_074 English name: Maximum per subcatchment upstream mean daily maximum air temperature (°C) of the warmest month (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra siltākajā mēnesī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_05-max_cell.tif&quot; layername=&quot;egv_074&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_05-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.75 HydroClim_06-min_cell filename: HydroClim_06-min_cell.tif layername: egv_075 English name: Minimum per subcatchment upstream mean daily minimum air temperature (°C) of the coldest month (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina minimālā augšteces dienas vidējā gaisa temperatūra vēsākajā mēnesī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (min) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_06-min_cell.tif&quot; layername=&quot;egv_075&quot; summary_function=&quot;min&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_06-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.76 HydroClim_07-max_cell filename: HydroClim_07-max_cell.tif layername: egv_076 English name: Maximum per subcatchment upstream annual range of air temperature (°C) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces gada gaisa temperatūru amplitūda (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_07-max_cell.tif&quot; layername=&quot;egv_076&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_07-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.77 HydroClim_08-max_cell filename: HydroClim_08-max_cell.tif layername: egv_077 English name: Maximum per subcatchment upstream mean daily mean air temperatures (°C) of the wettest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra mitrākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_08-max_cell.tif&quot; layername=&quot;egv_077&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_08-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.78 HydroClim_09-min_cell filename: HydroClim_09-min_cell.tif layername: egv_078 English name: Minimum per subcatchment upstream mean daily mean air temperatures (°C) of the driest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra sausākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (min) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_09-min_cell.tif&quot; layername=&quot;egv_078&quot; summary_function=&quot;min&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_09-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.79 HydroClim_10-max_cell filename: HydroClim_10-max_cell.tif layername: egv_079 English name: Maximum per subcatchment upstream mean daily mean air temperatures (°C) of the warmest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra siltākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_10-max_cell.tif&quot; layername=&quot;egv_079&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_10-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.80 HydroClim_11-min_cell filename: HydroClim_11-min_cell.tif layername: egv_080 English name: Minimum per subcatchment upstream mean daily mean air temperatures (°C) of the coldest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālā augšteces dienas vidējā gaisa temperatūra vēsākajā ceturksnī (°C) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (min) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_11-min_cell.tif&quot; layername=&quot;egv_080&quot; summary_function=&quot;min&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_11-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.81 HydroClim_12-max_cell filename: HydroClim_12-max_cell.tif layername: egv_081 English name: Maximum per subcatchment upstream annual precipitation amount (kg m⁻² year⁻¹) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums gadā (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_12-max_cell.tif&quot; layername=&quot;egv_081&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_12-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.82 HydroClim_13-max_cell filename: HydroClim_13-max_cell.tif layername: egv_082 English name: Maximum per subcatchment upstream precipitation amount (kg m⁻² year⁻¹) of the wettest month (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums mitrākajā mēnesī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_13-max_cell.tif&quot; layername=&quot;egv_082&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_13-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.83 HydroClim_14-max_cell filename: HydroClim_14-max_cell.tif layername: egv_083 English name: Maximum per subcatchment upstream precipitation amount (kg m⁻² year⁻¹) of the driest month (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums sausākajā mēnesī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_14-max_cell.tif&quot; layername=&quot;egv_083&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_14-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.84 HydroClim_15-max_cell filename: HydroClim_15-max_cell.tif layername: egv_084 English name: Maximum per subcatchment upstream precipitation seasonality (kg m⁻²) (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzuma sezonalitāte (kg m⁻²) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_15-max_cell.tif&quot; layername=&quot;egv_084&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_15-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.85 HydroClim_16-max_cell filename: HydroClim_16-max_cell.tif layername: egv_085 English name: Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the wettest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums mitrākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_16-max_cell.tif&quot; layername=&quot;egv_085&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_16-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.86 HydroClim_17-max_cell filename: HydroClim_17-max_cell.tif layername: egv_086 English name: Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the driest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums sausākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_17-max_cell.tif&quot; layername=&quot;egv_086&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_17-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.87 HydroClim_18-max_cell filename: HydroClim_18-max_cell.tif layername: egv_087 English name: Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the warmest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums siltākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_18-max_cell.tif&quot; layername=&quot;egv_087&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_18-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.88 HydroClim_19-max_cell filename: HydroClim_19-max_cell.tif layername: egv_088 English name: Maximum per subcatchment upstream mean monthly precipitation amount (kg m⁻² year⁻¹) of the coldest quarter (HydroClim) within the analysis cell (1 ha) Latvian name: Sateces apakšbaseina maksimālais augšteces nokrišņu daudzums vēsākajā ceturksnī (kg m⁻² year⁻¹) (HydroClim) analīzes šūnā (1 ha) Procedure: Information from the HydroClim data - including both basin and raster layers - is used. First, basin CRS is transformed to EPSG:3059. Then, zonal statistics (per basin) using a layer specific summary function (max) are calculated (exactextractr::exact_extract()), and the the results are rasterised with the workflow egvtools::polygon2input(). Once rasterised to input data, EGV is created using the workflow egvtools::input2egv(). To prevent from gaps at the edges, inverse distance weighted (power = 2) gap filling is implemented. To save disk space, the intermediate input layer is unlinked. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(exactextractr)) {install.packages(&quot;exactextractr&quot;); require(exactextractr)} # basins ---- level12=st_read(&quot;./Geodata/2024/HydroClim/hybas_lake_eu_lev01-12_v1c/hybas_lake_eu_lev12_v1c.shp&quot;) grid_1km=sfarrow::st_read_parquet(&quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;) grid_1km=st_transform(grid_1km,crs=3059) level12=st_transform(level12,crs=3059) level12=level12[grid_1km,,] level12=st_make_valid(level12) # job ---- localname=&quot;HydroClim_19-max_cell.tif&quot; layername=&quot;egv_088&quot; summary_function=&quot;max&quot; slanis=rast(paste0(&quot;./Geodata/2024/HydroClim/&quot;,localname)) level12$Hydro_values=exact_extract(slanis,level12,fun=summary_function) polygon2input(vector_data = level12, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = localname, value_field = &quot;Hydro_values&quot;, fun=&quot;first&quot;, value_type = &quot;continuous&quot;, prepare=FALSE, project_mode = &quot;auto&quot;, check_na = FALSE, plot_result=FALSE, plot_gaps = FALSE, overwrite=TRUE) egvrez=input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;,localname), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, input_template = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = localname, layername = layername, idw_weight = 2, plot_gaps = FALSE,plot_final = FALSE) egvrez unlink(paste0(&quot;./RasterGrids_10m/2024/&quot;,localname)) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;HydroClim_19-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.89 Distance_Builtup_cell filename: Distance_Builtup_cell.tif layername: egv_089 English name: Distance to Built-Up features, average within the analysis cell (1 ha) Latvian name: Attālums līdz apbūvei, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Landscape classification, with class 500 reclassified as 1 and others as 0. Processed using the workflow egvtools::distance2egv(). To prevent potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Distance_Builtup_cell.tif egv_89 ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) builtup=ifel(simple_landscape==500,1,0) plot(builtup) distegv=distance2egv(input = builtup, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Builtup_cell.tif&quot;, layername = &quot;egv_089&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_Builtup_cell.tif&quot;)) rm(builtup) rm(distegv) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Builtup_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.90 Distance_ForestInside_cell filename: Distance_ForestInside_cell.tif layername: egv_090 English name: Distance to Forest Edge Inside Forests, average within the analysis cell (1 ha) Latvian name: Attālums līdz meža malai tā iekšienē, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Landscape classification, with values in a range from 630 to 700 reclassified as 0 and others as 1. Processed using the workflow egvtools::distance2egv(). To prevent potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Distance_ForestInside_cell.tif egv_90 ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) trees_inside=ifel(simple_landscape&gt;=630&amp;simple_landscape&lt;700,0,1) plot(trees_inside) distegv=distance2egv(input = trees_inside, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_ForestInside_cell.tif&quot;, layername = &quot;egv_090&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_ForestInside_cell.tif&quot;)) rm(trees_inside) rm(distegv) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_ForestInside_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.91 Distance_GrasslandPermanent_cell filename: Distance_GrasslandPermanent_cell.tif layername: egv_091 English name: Distance to Permanent Grasslands, average within the analysis cell (1 ha) Latvian name: Attālums līdz ilggadīgiem zālājiem, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Rural Support Service’s information on declared fields where PRODUCT_CODE==\"710\" classified as 1 and the rest of the country as 0. Processed using the workflow egvtools::distance2egv(). To prevent potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) rastra_pamatne=raster(template10) # Distance_GrasslandPermanent_cell.tif egv_91 ---- kodes=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) permgrass=lad %&gt;% filter(PRODUCT_CODE==&quot;710&quot;) %&gt;% mutate(yes=1) permgrass_r=fasterize(permgrass,rastra_pamatne,field=&quot;yes&quot;,fun=&quot;first&quot;) permgrass_t=rast(permgrass_r) permgrass_t2=cover(permgrass_t,nulls10) plot(permgrass_t2) distegv=distance2egv(input = permgrass_t2, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_GrasslandPermanent_cell.tif&quot;, layername = &quot;egv_091&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_GrasslandPermanent_cell.tif&quot;)) rm(distegv) rm(kodes) rm(lad) rm(permgrass) rm(permgrass_r) rm(permgrass_t) rm(permgrass_t2) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_GrasslandPermanent_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.92 Distance_Landfill_cell filename: Distance_Landfill_cell.tif layername: egv_092 English name: Distance to Landfills, average within the analysis cell (1 ha) Latvian name: Attālums līdz atkritumu poligoniem, vidējais analīzes šūnā (1 ha) Procedure: Directly follows Waste and garbage disposal sites, landfills. From the attachaed file, read sheet “Poligoni”; Create an sf object (EPSG:3059); Rasterize and cover so that cells of interest are 1 and others are 0; Create an EGV using the workflow egvtools::distance2egv(). Expect warning regarding nothing to do with aggregation. This occurs because egvtools::distance2egv() already operate at EGV template not the input template resolution. To prevent potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # Distance_Landfill_cell.tif egv_92 ---- # reading coordinates landfills=read_excel(&quot;./Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx&quot;,sheet=&quot;Poligoni&quot;) #sf object landfills_sf=st_as_sf(landfills,coords=c(&quot;X&quot;,&quot;Y&quot;),crs=3059) # rasterize landfills_rast=rasterize(landfills_sf,template100) # raster to 1=Cell of interest, 0=background landfills_bg=cover(landfills_rast,nulls100) # create an egv distegv=distance2egv(input = landfills_bg, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Landfill_cell.tif&quot;, layername = &quot;egv_092&quot;) distegv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Landfill_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.93 Distance_Sea_cell filename: Distance_Sea_cell.tif layername: egv_093 English name: Distance to Sea, average within the analysis cell (1 ha) Latvian name: Attālums līdz jūrai, vidējais analīzes šūnā (1 ha) Procedure: Directly follows Latvian Exclusive Economic Zone polygon. Read layer as sf object (it already is EPSG:3059); Rasterize and cover so that cells of interest are 1 and others are 0; Create an egv with the workflow egvtools::distance2egv(). The {fasterize} package does not write CRS with WKT from the EPSG-string; therefore, it is better to use project_to_template_input=TRUE and define input-template. However, the only difference is in how the CRS is stored, therefore this can ignored - distance will be calculated on the input CRS and only resulting layer will be projected to match EGV template (faster due to 10x aggregation of resolution). To protect against possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) rastrs10=raster::raster(template10) # Distance_Sea_cell.tif egv_93 ---- # sea layer, sf sea=st_read(&quot;./Geodata/2024/LV_EEZ/LV_EEZ.shp&quot;) # quick rasterisation sea_r=fasterize(sea,rastrs10,field=&quot;LV_EEZ&quot;) sea_rast=rast(sea_r) # raster to 1=Cell of interest, 0=background sea_bg=cover(sea_rast,nulls10) # create an egv distegv=distance2egv(input = sea_bg, template_egv = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, values_as_one = 1, project_to_template_input=TRUE, # fasterize stores CRS differently template_input=template10, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Sea_cell.tif&quot;, layername = &quot;egv_093&quot;) distegv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Sea_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.94 Distance_Trees_cell filename: Distance_Trees_cell.tif layername: egv_094 English name: Distance to Trees, average within the analysis cell (1 ha) Latvian name: Attālums līdz kokiem, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Landscape classification, with values in a range from 630 to 700 reclassified as 1 and all others as 0. Processed using the workflow egvtools::distance2egv(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Distance_Trees_cell.tif egv_94 ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) trees=ifel(simple_landscape&gt;=630&amp;simple_landscape&lt;700,1,0) plot(trees) distegv=distance2egv(input = trees, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Trees_cell.tif&quot;, layername = &quot;egv_094&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_Trees_cell.tif&quot;)) rm(trees) rm(distegv) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Trees_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.95 Distance_Waste_cell filename: Distance_Waste_cell.tif layername: egv_095 English name: Distance to Waste disposal sites, average within the analysis cell (1 ha) Latvian name: Attālums līdz atkritumu šķirošanas un uzglabāšanas vietām, vidējais analīzes šūnā (1 ha) Procedure: Directly follows Waste and garbage disposal sites, landfills. From the attachaed file, read sheet “AtkritumuVietas” and clean names; Create an sf object (EPSG:3059); Filter to non-deposit collection locations; Rasterize and cover so that cells of interest are 1 and others are 0; Create an EGV using the workflow egvtools::distance2egv(). Expect warning regarding nothing to do with aggregation. That is because egvtools::distance2egv() already operate at EGV template not the input template resolution. To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # Distance_Waste_cell.tif egv_95 ---- # reading coordinates waste=read_excel(&quot;./Geodata/2024/GarbageWasteLandfills/Atkritumi.xlsx&quot;,sheet=&quot;AtkritumuVietas&quot;) # cleaning names waste2=janitor::clean_names(waste) #sf object waste_sf=st_as_sf(waste2,coords=c(&quot;y_koordinata_lks92_tm&quot;,&quot;x_koordinata_lks92_tm&quot;),crs=3059) # filtering to non-deposit table(waste_sf$pienemsanas_vietas_tips) waste_sf2=waste_sf %&gt;% filter(!str_detect(pienemsanas_vietas_tips,&quot;Depozīta&quot;)) # rasterize waste_rast=rasterize(waste_sf2,template100) # raster to 1=Cell of interest, 0=background wastw_bg=cover(waste_rast,nulls100) # create an egv distegv=distance2egv(input = wastw_bg, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Waste_cell.tif&quot;, layername = &quot;egv_095&quot;) distegv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Waste_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.96 Distance_Water_cell filename: Distance_Water_cell.tif layername: egv_096 English name: Distance to Waterbodies, average within the analysis cell (1 ha) Latvian name: Attālums līdz ūdenstilpēm, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Landscape classification, with class 200 reclassified as 1 and all others as 0. Processed using the workflow egvtools::distance2egv(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Distance_Water_cell.tif egv_96 ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) water=ifel(simple_landscape==200,1,0) plot(water) distegv=distance2egv(input = water, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_Water_cell.tif&quot;, layername = &quot;egv_096&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_Water_cell.tif&quot;)) rm(water) rm(distegv) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_Water_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.97 Distance_WaterInside_cell filename: Distance_WaterInside_cell.tif layername: egv_097 English name: Distance to Waterbody Edge Inside Waterbody, average within the analysis cell (1 ha) Latvian name: Attālums līdz ūdenstilpes malai tās iekšienē, vidējais analīzes šūnā (1 ha) Procedure: Derived from the Landscape classification, with class 200 reclassified as 0 and all others as 1. Processed using the workflow egvtools::distance2egv(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Distance_WaterInside_cell.tif egv_97 ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) water_outside=ifel(simple_landscape==200,0,1) plot(water_outside) distegv=distance2egv(input = water_outside, template_egv = template100, values_as_one = 1, fill_gaps = TRUE, idw_weight = 2, outlocation = &quot;RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Distance_WaterInside_cell.tif&quot;, layername = &quot;egv_097&quot;) distegv plot(rast(&quot;RasterGrids_100m/2024/RAW/Distance_WaterInside_cell.tif&quot;)) rm(water_outside) rm(distegv) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Distance_WaterInside_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.98 Diversity_Farmland_r500 filename: Diversity_Farmland_r500.tif layername: egv_098 English name: Average farmland class α-diversity of 500 m grid cells within the 0.5 km landscape Latvian name: Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 0,5 km ainavā Procedure: Derived from the Landscape diversity, more precisely Farmland diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Farmland_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Farmland_r500.tif egv_98 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r500.tif&quot;) names(slanis)=&quot;egv_098&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Farmland_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.99 Diversity_Farmland_r1250 filename: Diversity_Farmland_r1250.tif layername: egv_099 English name: Average farmland class α-diversity of 500 m grid cells within the 1.25 km landscape Latvian name: Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 1,25 km ainavā Procedure: Derived from the Landscape diversity, more precisely Farmland diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Farmland_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Farmland_r1250.tif egv_99 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r1250.tif&quot;) names(slanis)=&quot;egv_099&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Farmland_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.100 Diversity_Farmland_r3000 filename: Diversity_Farmland_r3000.tif layername: egv_100 English name: Average farmland class α-diversity of 500 m grid cells within the 3 km landscape Latvian name: Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā Procedure: Derived from the Landscape diversity, more precisely Farmland diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Farmland_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Farmland_r3000.tif egv_100 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r3000.tif&quot;) names(slanis)=&quot;egv_100&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Farmland_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.101 Diversity_Farmland_r10000 filename: Diversity_Farmland_r10000.tif layername: egv_101 English name: Average farmland class α-diversity of 500 m grid cells within the 10 km landscape Latvian name: Vidējā lauku ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā Procedure: Derived from the Landscape diversity, more precisely Farmland diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Farmland_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Farmland_r10000.tif egv_101 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r10000.tif&quot;) names(slanis)=&quot;egv_101&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Farmland_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Farmland_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.102 Diversity_Forest_r500 filename: Diversity_Forest_r500.tif layername: egv_102 English name: Average forest class α-diversity of 500 m grid cells within the 0.5 km landscape Latvian name: Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 0,5 km ainavā Procedure: Derived from the Landscape diversity, more precisely Forest diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Forests_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Forest&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Forest_r500.tif egv_102 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r500.tif&quot;) names(slanis)=&quot;egv_102&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Forest_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.103 Diversity_Forest_r1250 filename: Diversity_Forest_r1250.tif layername: egv_103 English name: Average forest class α-diversity of 500 m grid cells within the 1.25 km landscape Latvian name: Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 1,25 km ainavā Procedure: Derived from the Landscape diversity, more precisely Forest diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Forests_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Forest&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Forest_r1250.tif egv_103 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r1250.tif&quot;) names(slanis)=&quot;egv_103&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Forest_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.104 Diversity_Forest_r3000 filename: Diversity_Forest_r3000.tif layername: egv_104 English name: Average forest class α-diversity of 500 m grid cells within the 3 km landscape Latvian name: Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā Procedure: Derived from the Landscape diversity, more precisely Forest diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Forests_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Forest&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Forest_r3000.tif egv_104 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r3000.tif&quot;) names(slanis)=&quot;egv_104&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Forest_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.105 Diversity_Forest_r10000 filename: Diversity_Forest_r10000.tif layername: egv_105 English name: Average forest class α-diversity of 500 m grid cells within the 10 km landscape Latvian name: Vidējā mežu ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā Procedure: Derived from the Landscape diversity, more precisely Forest diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_Forests_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Forest&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Forest_r10000.tif egv_105 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r10000.tif&quot;) names(slanis)=&quot;egv_105&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Forest_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Forest_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.106 Diversity_Total_r500 filename: Diversity_Total_r500.tif layername: egv_106 English name: Average combined landscape α-diversity of 500 m grid cells within the 0.5 km landscape Latvian name: Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 0,5 km ainavā Procedure: Derived from the Landscape diversity, more precisely Overall landscape diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Total&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Total_r500.tif egv_106 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r500.tif&quot;) names(slanis)=&quot;egv_106&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Total_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.107 Diversity_Total_r1250 filename: Diversity_Total_r1250.tif layername: egv_107 English name: Average combined landscape α-diversity of 500 m grid cells within the 1.25 km landscape Latvian name: Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 1,25 km ainavā Procedure: Derived from the Landscape diversity, more precisely Overall landscape diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Total&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Total_r1250.tif egv_107 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r1250.tif&quot;) names(slanis)=&quot;egv_107&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Total_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.108 Diversity_Total_r3000 filename: Diversity_Total_r3000.tif layername: egv_108 English name: Average combined landscape α-diversity of 500 m grid cells within the 3 km landscape Latvian name: Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 3 km ainavā Procedure: Derived from the Landscape diversity, more precisely Overall landscape diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Total&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Total_r3000.tif egv_108 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r3000.tif&quot;) names(slanis)=&quot;egv_108&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Total_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.109 Diversity_Total_r10000 filename: Diversity_Total_r10000.tif layername: egv_109 English name: Average combined landscape α-diversity of 500 m grid cells within the 10 km landscape Latvian name: Vidējā visu ainavas klašu 500 m šūnu α-daudzveidība 10 km ainavā Procedure: Derived from the Landscape diversity, more precisely Overall landscape diversity. The average value of 25 ha cells diversity index values is calculated using the workflow egvtools::radius_function(). To prevent possible data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. File is written twice, to ensure layername. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_500m/2024/Diversity_GeneralLandscape_500x.tif&quot;), layer_prefixes = c(&quot;Diversity_Total&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Diversity_Total_r10000.tif egv_109 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r10000.tif&quot;) names(slanis)=&quot;egv_109&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Diversity_Total_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Diversity_Total_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.110 Edges_Bogs-Trees_cell filename: Edges_Bogs-Trees_cell.tif layername: egv_110 English name: Edge pixels of Bogs, Mires bordering with Trees within the analysis cell (1 ha) Latvian name: Purvu malu ar kokiem garums analīzes šūnā (1 ha) Procedure: First, values from 620 to 700 from the Landscape classification are coded as 0, and all other values as NA. Then bog and transitional mire layers from the EDI are reclassified to presence-only (value 1) and combined. Then, bog-and-mire layer (1 = presence) is covered over tree layer (presence = 0) and written to file (matching the input). Then, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Bogs-Trees_input.tif ---- trees_from620=ifel(simple_landscape&gt;=620 &amp; simple_landscape&lt;700,0,NA) plot(trees_from620) bogs=rast(&quot;./RasterGrids_10m/2024/EDI_BogsYN.tif&quot;) bogs=subst(bogs,0,NA) plot(bogs) mires=rast(&quot;./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif&quot;) mires=subst(mires,0,NA) plot(mires) bogs_mires=cover(bogs,mires) plot(bogs_mires) bm_trees=cover(bogs_mires,trees_from620) plot(bm_trees) edge_bm_trees=project(bm_trees,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Bogs-Trees_input.tif&quot;, overwrite=TRUE) rm(edge_bm_trees) rm(bm_trees) # Edges_Bogs-Trees_cell.tif egv_110 landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Bogs-Trees_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Bogs-Trees_cell.tif&quot;, out_layername = &quot;egv_110&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Trees_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.111 Edges_Bogs-Trees_r500 filename: Edges_Bogs-Trees_r500.tif layername: egv_111 English name: Edge pixels of Bogs, Mires bordering with Trees within the 0.5 km landscape Latvian name: Purvu malu ar kokiem garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 4, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Trees_r500.tif egv_111 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r500.tif&quot;) names(slanis)=&quot;egv_111&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Trees_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.112 Edges_Bogs-Trees_r1250 filename: Edges_Bogs-Trees_r1250.tif layername: egv_112 English name: Edge pixels of Bogs, Mires bordering with Trees within the 1.25 km landscape Latvian name: Purvu malu ar kokiem garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 4, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Trees_r1250.tif egv_112 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r1250.tif&quot;) names(slanis)=&quot;egv_112&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Trees_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.113 Edges_Bogs-Trees_r3000 filename: Edges_Bogs-Trees_r3000.tif layername: egv_113 English name: Edge pixels of Bogs, Mires bordering with Trees within the 3 km landscape Latvian name: Purvu malu ar kokiem garums 3 km ainavā Procedure: Total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 4, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Trees_r3000.tif egv_113 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r3000.tif&quot;) names(slanis)=&quot;egv_113&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Trees_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.114 Edges_Bogs-Trees_r10000 filename: Edges_Bogs-Trees_r10000.tif layername: egv_114 English name: Edge pixels of Bogs, Mires bordering with Trees within the 10 km landscape Latvian name: Purvu malu ar kokiem garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 4, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Trees_r10000.tif egv_114 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r10000.tif&quot;) names(slanis)=&quot;egv_114&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Trees_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Trees_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.115 Edges_Bogs-Water_cell filename: Edges_Bogs-Water_cell.tif layername: egv_115 English name: Edge pixels of Bogs, Mires bordering with Water within the analysis cell (1 ha) Latvian name: Purvu malu ar ūdeni garums analīzes šūnā (1 ha) Procedure: First, values 200 from the Landscape classification are coded as 0, and all other values as NA. Then bog and transitional mire layers from EDI are reclassified to presence-only (value 1) and combined. Then, bog-and-mire layer (1 = presence) is covered over water layer (presence = 0) and written to file (matching the input). Then, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Bogs-Water_input.tif ---- bogs=rast(&quot;./RasterGrids_10m/2024/EDI_BogsYN.tif&quot;) bogs=subst(bogs,0,NA) plot(bogs) mires=rast(&quot;./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif&quot;) mires=subst(mires,0,NA) plot(mires) bogs_mires=cover(bogs,mires) plot(bogs_mires) water=ifel(simple_landscape==200,0,NA) plot(water) bm_water=cover(bogs_mires,water) plot(bm_water) edge_bm_water=project(bm_water,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Bogs-Water_input.tif&quot;, overwrite=TRUE) rm(edge_bm_water) rm(bm_water) # Edges_Bogs-Water_cell.tif egv_115 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Bogs-Water_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Bogs-Water_cell.tif&quot;, out_layername = &quot;egv_115&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Water_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.116 Edges_Bogs-Water_r500 filename: Edges_Bogs-Water_r500.tif layername: egv_116 English name: Edge pixels of Bogs, Mires bordering with Water within the 0.5 km landscape Latvian name: Purvu malu ar ūdeni garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Water_r500.tif egv_116 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r500.tif&quot;) names(slanis)=&quot;egv_116&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Water_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.117 Edges_Bogs-Water_r1250 filename: Edges_Bogs-Water_r1250.tif layername: egv_117 English name: Edge pixels of Bogs, Mires bordering with Water within the 1.25 km landscape Latvian name: Purvu malu ar ūdeni garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Water_r1250.tif egv_117 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r1250.tif&quot;) names(slanis)=&quot;egv_117&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Water_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.118 Edges_Bogs-Water_r3000 filename: Edges_Bogs-Water_r3000.tif layername: egv_118 English name: Edge pixels of Bogs, Mires bordering with Water within the 3 km landscape Latvian name: Purvu malu ar ūdeni garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Water_r3000.tif egv_118 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r3000.tif&quot;) names(slanis)=&quot;egv_118&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Water_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.119 Edges_Bogs-Water_r10000 filename: Edges_Bogs-Water_r10000.tif layername: egv_119 English name: Edge pixels of Bogs, Mires bordering with Water within the 10 km landscape Latvian name: Purvu malu ar ūdeni garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Bogs-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Bogs-Water_r10000.tif egv_119 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r10000.tif&quot;) names(slanis)=&quot;egv_119&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Bogs-Water_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Bogs-Water_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.120 Edges_Farmland-Builtup_cell filename: Edges_Farmland-Builtup_cell.tif layername: egv_120 English name: Edge pixels of Farmland bordering with Built-Up areas within the analysis cell (1 ha) Latvian name: Lauksaimniecības zemju malu ar apbūvi garums analīzes šūnā (1 ha) Procedure: First, values larger than 300 and smaller than 400 from Landscape classification are coded as 1, and all other values as NA. Then values 500 from the Landscape classification are coded as 0, and all other values as NA. Then, the first layer (1 = presence) is covered over the second layer (presence = 0) and written to file (matching the input). Next, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Farmland-Builtup_input.tif ---- farmland=ifel(simple_landscape&gt;300 &amp; simple_landscape&lt;400,1,NA) plot(farmland) builtup=ifel(simple_landscape==500,0,NA) plot(builtup) farmland_builtup=cover(farmland,builtup) plot(farmland_builtup) edge_farmland_builtup=project(farmland_builtup,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Farmland-Builtup_input.tif&quot;, overwrite=TRUE) rm(edge_farmland_builtup) rm(farmland_builtup) # Edges_Farmland-Builtup_cell.tif egv_120 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Farmland-Builtup_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Farmland-Builtup_cell.tif&quot;, out_layername = &quot;egv_120&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Farmland-Builtup_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.121 Edges_Farmland-Builtup_r500 filename: Edges_Farmland-Builtup_r500.tif layername: egv_121 English name: Edge pixels of Farmland bordering with Built-Up areas within the 0.5 km landscape Latvian name: Lauksaimniecības zemju malu ar apbūvi garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Farmland-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Farmland-Builtup_r500.tif egv_121 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r500.tif&quot;) names(slanis)=&quot;egv_121&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Farmland-Builtup_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.122 Edges_Farmland-Builtup_r1250 filename: Edges_Farmland-Builtup_r1250.tif layername: egv_122 English name: Edge pixels of Farmland bordering with Built-Up areas within the 1.25 km landscape Latvian name: Lauksaimniecības zemju malu ar apbūvi garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Farmland-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Farmland-Builtup_r1250.tif egv_122 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r1250.tif&quot;) names(slanis)=&quot;egv_122&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Farmland-Builtup_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.123 Edges_Farmland-Builtup_r3000 filename: Edges_Farmland-Builtup_r3000.tif layername: egv_123 English name: Edge pixels of Farmland bordering with Built-Up areas within the 3 km landscape Latvian name: Lauksaimniecības zemju malu ar apbūvi garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Farmland-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Farmland-Builtup_r3000.tif egv_123 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r3000.tif&quot;) names(slanis)=&quot;egv_123&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Farmland-Builtup_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.124 Edges_Farmland-Builtup_r10000 filename: Edges_Farmland-Builtup_r10000.tif layername: egv_124 English name: Edge pixels of Farmland bordering with Built-Up areas within the 10 km landscape Latvian name: Lauksaimniecības zemju malu ar apbūvi garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Farmland-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Farmland-Builtup_r10000.tif egv_124 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r10000.tif&quot;) names(slanis)=&quot;egv_124&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Farmland-Builtup_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Farmland-Builtup_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.125 Edges_Trees-Builtup_cell filename: Edges_Trees-Builtup_cell.tif layername: egv_125 English name: Edge pixels of Trees bordering with Built-Up areas within the analysis cell (1 ha) Latvian name: Koku malu ar apbūvi garums analīzes šūnā (1 ha) Procedure: First, values larger than 630 and smaller than 700 from Landscape classification are coded as 1, and other values as NA. Then values 500 from the Landscape classification are coded as 0, and other values as NA. Then, the first layer (1 = presence) is covered over the second layer (presence = 0) and written to file (matching the input). Next, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Trees-Builtup_input.tif ---- trees_from630=ifel(simple_landscape&gt;=630 &amp; simple_landscape&lt;700,1,NA) plot(trees_from630) builtup=ifel(simple_landscape==500,0,NA) plot(builtup) trees630_builtup=cover(trees_from630,builtup) plot(trees630_builtup) edge_trees630_builtup=project(trees630_builtup,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Trees-Builtup_input.tif&quot;, overwrite=TRUE) rm(edge_trees630_builtup) rm(trees630_builtup) # Edges_Trees-Builtup_cell.tif egv_125 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Trees-Builtup_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Trees-Builtup_cell.tif&quot;, out_layername = &quot;egv_125&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees-Builtup_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.126 Edges_Trees-Builtup_r500 filename: Edges_Trees-Builtup_r500.tif layername: egv_126 English name: Edge pixels of Trees bordering with Built-Up areas within the 0.5 km landscape Latvian name: Koku malu ar apbūvi garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees-Builtup_r500.tif egv_126 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r500.tif&quot;) names(slanis)=&quot;egv_126&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees-Builtup_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.127 Edges_Trees-Builtup_r1250 filename: Edges_Trees-Builtup_r1250.tif layername: egv_127 English name: Edge pixels of Trees bordering with Built-Up areas within the 1.25 km landscape Latvian name: Koku malu ar apbūvi garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees-Builtup_r1250.tif egv_127 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r1250.tif&quot;) names(slanis)=&quot;egv_127&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees-Builtup_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.128 Edges_Trees-Builtup_r3000 filename: Edges_Trees-Builtup_r3000.tif layername: egv_128 English name: Edge pixels of Trees bordering with Built-Up areas within the 3 km landscape Latvian name: Koku malu ar apbūvi garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees-Builtup_r3000.tif egv_128 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r3000.tif&quot;) names(slanis)=&quot;egv_128&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees-Builtup_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.129 Edges_Trees-Builtup_r10000 filename: Edges_Trees-Builtup_r10000.tif layername: egv_129 English name: Edge pixels of Trees bordering with Built-Up areas within the 10 km landscape Latvian name: Koku malu ar apbūvi garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees-Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees-Builtup_r10000.tif egv_129 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r10000.tif&quot;) names(slanis)=&quot;egv_129&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees-Builtup_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees-Builtup_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.130 Edges_CropsFallow_cell filename: Edges_CropsFallow_cell.tif layername: egv_130 English name: Edge pixels of Cropland, Fallow land within the analysis cell (1 ha) Latvian name: Aramzemju malu garums analīzes šūnā (1 ha) Procedure: First, values larger than or equal to 310 and smaller than 325 from the Landscape classification are coded as 1, and all other values as NA. Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Next, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_CropsFallow_input.tif ---- cropsfallow=ifel(simple_landscape&gt;=310 &amp; simple_landscape&lt;325,1,NA) plot(cropsfallow) cropsfallow=cover(cropsfallow,nulls10) plot(cropsfallow) edge_cropsfallow=project(cropsfallow,template10, filename=&quot;./RasterGrids_10m/2024/Edges_CropsFallow_input.tif&quot;, overwrite=TRUE) rm(edge_cropsfallow) # Edges_CropsFallow_cell.tif egv_130 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_CropsFallow_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_CropsFallow_cell.tif&quot;, out_layername = &quot;egv_130&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_CropsFallow_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.131 Edges_CropsFallow_r500 filename: Edges_CropsFallow_r500.tif layername: egv_131 English name: Edge pixels of Cropland, Fallow land within the 0.5 km landscape Latvian name: Aramzemju malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;Edges_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_CropsFallow_r500.tif egv_131 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r500.tif&quot;) names(slanis)=&quot;egv_131&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_CropsFallow_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.132 Edges_CropsFallow_r1250 filename: Edges_CropsFallow_r1250.tif layername: egv_132 English name: Edge pixels of Cropland, Fallow land within the 1.25 km landscape Latvian name: Aramzemju malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;Edges_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_CropsFallow_r1250.tif egv_132 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r1250.tif&quot;) names(slanis)=&quot;egv_132&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_CropsFallow_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.133 Edges_CropsFallow_r3000 filename: Edges_CropsFallow_r3000.tif layername: egv_133 English name: Edge pixels of Cropland, Fallow land within the 3 km landscape Latvian name: Aramzemju malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;Edges_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_CropsFallow_r3000.tif egv_133 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r3000.tif&quot;) names(slanis)=&quot;egv_133&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_CropsFallow_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.134 Edges_CropsFallow_r10000 filename: Edges_CropsFallow_r10000.tif layername: egv_134 English name: Edge pixels of Cropland, Fallow land within the 10 km landscape Latvian name: Aramzemju malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;Edges_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_CropsFallow_r10000.tif egv_134 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r10000.tif&quot;) names(slanis)=&quot;egv_134&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_CropsFallow_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_CropsFallow_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.135 Edges_FarmlandShrubs-Trees_cell filename: Edges_FarmlandShrubs-Trees_cell.tif layername: egv_135 English name: Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the analysis cell (1 ha) Latvian name: Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums analīzes šūnā (1 ha) Procedure: First, values between 300 and 400 and between 600 and 630 from Landscape classification are coded as 0, and all other values as NA. Then values larger than or equal to 630 but smaller than 700 from the Landscape classification are coded as 1, and all other values as NA. Then, the first layer (0 = presence) is covered over the second layer (presence = 1) and written to file (matching the input). Next, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_FarmlandShrubs-Trees_input.tif ---- farmshrub=ifel((simple_landscape&gt;300 &amp; simple_landscape&lt;400)| (simple_landscape&gt;600 &amp; simple_landscape&lt;630),0,NA) trees_from630=ifel(simple_landscape&gt;=630 &amp; simple_landscape&lt;700,1,NA) plot(trees_from630) farmshrub_trees630=cover(farmshrub,trees_from630) plot(farmshrub_trees630) edge_farmshrub_trees630=project(farmshrub_trees630,template10, filename=&quot;./RasterGrids_10m/2024/Edges_FarmlandShrubs-Trees_input.tif&quot;, overwrite=TRUE) rm(edge_farmshrub_trees630) rm(farmshrub_trees630) # Edges_FarmlandShrubs-Trees_cell.tif egv_135 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_FarmlandShrubs-Trees_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_FarmlandShrubs-Trees_cell.tif&quot;, out_layername = &quot;egv_135&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_FarmlandShrubs-Trees_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.136 Edges_FarmlandShrubs-Trees_r500 filename: Edges_FarmlandShrubs-Trees_r500.tif layername: egv_136 English name: Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 0.5 km landscape Latvian name: Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_FarmlandShrubs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_FarmlandShrubs-Trees_r500.tif egv_136 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r500.tif&quot;) names(slanis)=&quot;egv_136&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_FarmlandShrubs-Trees_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.137 Edges_FarmlandShrubs-Trees_r1250 filename: Edges_FarmlandShrubs-Trees_r1250.tif layername: egv_137 English name: Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 1.25 km landscape Latvian name: Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_FarmlandShrubs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_FarmlandShrubs-Trees_r1250.tif egv_137 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r1250.tif&quot;) names(slanis)=&quot;egv_137&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_FarmlandShrubs-Trees_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.138 Edges_FarmlandShrubs-Trees_r3000 filename: Edges_FarmlandShrubs-Trees_r3000.tif layername: egv_138 English name: Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 3 km landscape Latvian name: Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_FarmlandShrubs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_FarmlandShrubs-Trees_r3000.tif egv_138 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r3000.tif&quot;) names(slanis)=&quot;egv_138&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_FarmlandShrubs-Trees_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.139 Edges_FarmlandShrubs-Trees_r10000 filename: Edges_FarmlandShrubs-Trees_r10000.tif layername: egv_139 English name: Edge pixels of Farmland, Clear-Cuts, Shrubs bordering with Trees within the 10 km landscape Latvian name: Lauksaimniecības zemju, izcirtumu, krūmu malu ar kokiem garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_FarmlandShrubs-Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_FarmlandShrubs-Trees_r10000.tif egv_139 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r10000.tif&quot;) names(slanis)=&quot;egv_139&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_FarmlandShrubs-Trees_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_FarmlandShrubs-Trees_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.140 Edges_Grasslands_cell filename: Edges_Grasslands_cell.tif layername: egv_140 English name: Edge pixels of Grassland within the analysis cell (1 ha) Latvian name: Zālāju malu garums analīzes šūnā (1 ha) Procedure: First, values equal to 330 from the Landscape classification are coded as 1, and all other values as NA. Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Then, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Grasslands_input.tif ---- grassland=ifel(simple_landscape==330,1,NA) plot(grassland) grassland=cover(grassland,nulls10) plot(grassland) edge_grassland=project(grassland,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Grasslands_input.tif&quot;, overwrite=TRUE) rm(edge_grassland) # Edges_Grasslands_cell.tif egv_140 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Grasslands_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Grasslands_cell.tif&quot;, out_layername = &quot;egv_140&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Grasslands_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.141 Edges_Grasslands_r500 filename: Edges_Grasslands_r500.tif layername: egv_141 English name: Edge pixels of Grassland within the 0.5 km landscape Latvian name: Zālāju malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Grasslands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Grasslands_r500.tif egv_141 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r500.tif&quot;) names(slanis)=&quot;egv_141&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Grasslands_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.142 Edges_Grasslands_r1250 filename: Edges_Grasslands_r1250.tif layername: egv_142 English name: Edge pixels of Grassland within the 1.25 km landscape Latvian name: Zālāju malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Grasslands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Grasslands_r1250.tif egv_142 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r1250.tif&quot;) names(slanis)=&quot;egv_142&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Grasslands_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.143 Edges_Grasslands_r3000 filename: Edges_Grasslands_r3000.tif layername: egv_143 English name: Edge pixels of Grassland within the 3 km landscape Latvian name: Zālāju malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Grasslands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Grasslands_r3000.tif egv_143 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r3000.tif&quot;) names(slanis)=&quot;egv_143&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Grasslands_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.144 Edges_Grasslands_r10000 filename: Edges_Grasslands_r10000.tif layername: egv_144 English name: Edge pixels of Grassland within the 10 km landscape Latvian name: Zālāju malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Grasslands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Grasslands_r10000.tif egv_144 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r10000.tif&quot;) names(slanis)=&quot;egv_144&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Grasslands_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Grasslands_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.145 Edges_OldForests_cell filename: Edges_OldForests_cell.tif layername: egv_145 English name: Edge pixels of Forests Over Rotation Age within the analysis cell (1 ha) Latvian name: Pieaugušo un pāraugušo mežaudžu malu garums analīzes šūnā (1 ha) Procedure: First, the raster layer with forest stands from the MVR at age groups 4 and 5 is prepared (presence = 1, everything else = NA). Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Then, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_OldForests_input.tif ---- mvr=sfarrow::st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr2=mvr %&gt;% mutate(forest_age=ifelse(vgr==&quot;4&quot;|vgr==&quot;5&quot;,1,NA)) %&gt;% filter(!is.na(forest_age)) rast_old=fasterize(mvr2,raster(template10),field=&quot;forest_age&quot;) terra_old=rast(rast_old) plot(terra_old) terra_old=cover(terra_old,nulls10) plot(terra_old) edge_old=project(terra_old,template10, filename=&quot;./RasterGrids_10m/2024/Edges_OldForests_input.tif&quot;, overwrite=TRUE) rm(mvr) rm(mvr2) rm(rast_old) rm(terra_old) rm(edge_old) # Edges_OldForests_cell.tif egv_145 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_OldForests_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_OldForests_cell.tif&quot;, out_layername = &quot;egv_145&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_OldForests_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.146 Edges_OldForests_r500 filename: Edges_OldForests_r500.tif layername: egv_146 English name: Edge pixels of Forests Over Rotation Age within the 0.5 km landscape Latvian name: Pieaugušo un pāraugušo mežaudžu malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif&quot;), layer_prefixes = c(&quot;Edges_OldForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_OldForests_r500.tif egv_146 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r500.tif&quot;) names(slanis)=&quot;egv_146&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_OldForests_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.147 Edges_OldForests_r1250 filename: Edges_OldForests_r1250.tif layername: egv_147 English name: Edge pixels of Forests Over Rotation Age within the 1.25 km landscape Latvian name: Pieaugušo un pāraugušo mežaudžu malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif&quot;), layer_prefixes = c(&quot;Edges_OldForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_OldForests_r1250.tif egv_147 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r1250.tif&quot;) names(slanis)=&quot;egv_147&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_OldForests_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.148 Edges_OldForests_r3000 filename: Edges_OldForests_r3000.tif layername: egv_148 English name: Edge pixels of Forests Over Rotation Age within the 3 km landscape Latvian name: Pieaugušo un pāraugušo mežaudžu malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif&quot;), layer_prefixes = c(&quot;Edges_OldForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_OldForests_r3000.tif egv_148 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r3000.tif&quot;) names(slanis)=&quot;egv_148&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_OldForests_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.149 Edges_OldForests_r10000 filename: Edges_OldForests_r10000.tif layername: egv_149 English name: Edge pixels of Forests Over Rotation Age within the 10 km landscape Latvian name: Pieaugušo un pāraugušo mežaudžu malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_cell.tif&quot;), layer_prefixes = c(&quot;Edges_OldForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_OldForests_r10000.tif egv_149 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r10000.tif&quot;) names(slanis)=&quot;egv_149&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_OldForests_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_OldForests_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.150 Edges_Roads_cell filename: Edges_Roads_cell.tif layername: egv_150 English name: Edge pixels of Roads within the analysis cell (1 ha) Latvian name: Ceļu malu garums analīzes šūnā (1 ha) Procedure: First, values equal to 100 from the Landscape classification are coded as 1, and other values as NA. Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Next, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Roads_input.tif ---- roads=ifel(simple_landscape==100,1,NA) plot(roads) roads=cover(roads,nulls10) plot(roads) edge_roads=project(roads,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Roads_input.tif&quot;, overwrite=TRUE) rm(edge_roads) # Edges_Roads_cell.tif egv_150 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Roads_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Roads_cell.tif&quot;, out_layername = &quot;egv_150&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Roads_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.151 Edges_Roads_r500 filename: Edges_Roads_r500.tif layername: egv_151 English name: Edge pixels of Roads within the 0.5 km landscape Latvian name: Ceļu malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Roads&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Roads_r500.tif egv_151 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r500.tif&quot;) names(slanis)=&quot;egv_151&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Roads_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.152 Edges_Roads_r1250 filename: Edges_Roads_r1250.tif layername: egv_152 English name: Edge pixels of Roads within the 1.25 km landscape Latvian name: Ceļu malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Roads&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Roads_r1250.tif egv_152 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r1250.tif&quot;) names(slanis)=&quot;egv_152&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Roads_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.153 Edges_Roads_r3000 filename: Edges_Roads_r3000.tif layername: egv_153 English name: Edge pixels of Roads within the 3 km landscape Latvian name: Ceļu malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Roads&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Roads_r3000.tif egv_153 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r3000.tif&quot;) names(slanis)=&quot;egv_153&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Roads_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.154 Edges_Roads_r10000 filename: Edges_Roads_r10000.tif layername: egv_154 English name: Edge pixels of Roads within the 10 km landscape Latvian name: Ceļu malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Roads&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Roads_r10000.tif egv_154 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r10000.tif&quot;) names(slanis)=&quot;egv_154&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Roads_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Roads_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.155 Edges_Trees_cell filename: Edges_Trees_cell.tif layername: egv_155 English name: Edge pixels of Trees within the analysis cell (1 ha) Latvian name: Koku malu garums analīzes šūnā (1 ha) Procedure: First, values larger or equal to 630 and smaller than 700 from Landscape classification are coded as 1, and all other values as NA. Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Next, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Trees_input.tif ---- trees_from630=ifel(simple_landscape&gt;=630 &amp; simple_landscape&lt;700,1,NA) plot(trees_from630) trees_from630=cover(trees_from630,nulls10) plot(trees_from630) edge_trees_from630=project(trees_from630,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Trees_input.tif&quot;, overwrite=TRUE) rm(edge_trees_from630) # Edges_Trees_cell.tif egv_155 landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Trees_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Trees_cell.tif&quot;, out_layername = &quot;egv_155&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.156 Edges_Trees_r500 filename: Edges_Trees_r500.tif layername: egv_156 English name: Edge pixels of Trees within the 0.5 km landscape Latvian name: Koku malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees_r500.tif egv_156 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r500.tif&quot;) names(slanis)=&quot;egv_156&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.157 Edges_Trees_r1250 filename: Edges_Trees_r1250.tif layername: egv_157 English name: Edge pixels of Trees within the 1.25 km landscape Latvian name: Koku malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees_r1250.tif egv_157 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r1250.tif&quot;) names(slanis)=&quot;egv_157&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.158 Edges_Trees_r3000 filename: Edges_Trees_r3000.tif layername: egv_158 English name: Edge pixels of Trees within the 3 km landscape Latvian name: Koku malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees_r3000.tif egv_158 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r3000.tif&quot;) names(slanis)=&quot;egv_158&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.159 Edges_Trees_r10000 filename: Edges_Trees_r10000.tif layername: egv_159 English name: Edge pixels of Trees within the 10 km landscape Latvian name: Koku malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Trees_r10000.tif egv_159 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r10000.tif&quot;) names(slanis)=&quot;egv_159&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Trees_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Trees_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.160 Edges_Water_cell filename: Edges_Water_cell.tif layername: egv_160 English name: Edge pixels of Water within the analysis cell (1 ha) Latvian name: Ūdenstilpju malu garums analīzes šūnā (1 ha) Procedure: First, values equal to 200 from the Landscape classification are coded as 1 and everything else as NA. Then, the layer (1 = presence) is covered over the nulls layer (presence = 0) and written to file (matching the input). Next, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Water_input.tif ---- water=ifel(simple_landscape==200,1,0) plot(water) water=cover(water,nulls10) plot(water) edge_water=project(water,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Water_input.tif&quot;, overwrite=TRUE) # Edges_Water_cell.tif egv_160 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Water_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Water_cell.tif&quot;, out_layername = &quot;egv_160&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.161 Edges_Water_r500 filename: Edges_Water_r500.tif layername: egv_161 English name: Edge pixels of Water within the 0.5 km landscape Latvian name: Ūdenstilpju malu garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water_r500.tif egv_161 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_r500.tif&quot;) names(slanis)=&quot;egv_161&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.162 Edges_Water_r1250 filename: Edges_Water_r1250.tif layername: egv_162 English name: Edge pixels of Water within the 1.25 km landscape Latvian name: Ūdenstilpju malu garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water_r1250.tif egv_162 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_r1250.tif&quot;) names(slanis)=&quot;egv_162&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.163 Edges_Water_r3000 filename: Edges_Water_r3000.tif layername: egv_163 English name: Edge pixels of Water within the 3 km landscape Latvian name: Ūdenstilpju malu garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water_r3000.tif egv_163 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_r3000.tif&quot;) names(slanis)=&quot;egv_163&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.164 Edges_Water_r10000 filename: Edges_Water_r10000.tif layername: egv_164 English name: Edge pixels of Water within the 10 km landscape Latvian name: Ūdenstilpju malu garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water_r10000.tif egv_164 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water_r10000.tif&quot;) names(slanis)=&quot;egv_164&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.165 Edges_Water-Farmland_cell filename: Edges_Water-Farmland_cell.tif layername: egv_165 English name: Edge pixels of Water bordering with Farmland within the analysis cell (1 ha) Latvian name: Ūdenstilpju malu ar lauksaimniecības zemēm garums analīzes šūnā (1 ha) Procedure: First, values larger than 300 and smaller than 400 from Landscape classification are coded as 1, and all other values as NA. Then values equal to 200 from the Landscape classification are coded as 0, and all other values as NA. Then, the first layer (1 = presence) is covered over the second layer (presence = 0) and written to file (matching the input). Next, using the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Water-Farmland_input.tif ---- water=ifel(simple_landscape==200,0,NA) plot(water) farmland=ifel(simple_landscape&gt;300 &amp; simple_landscape&lt;400,1,NA) plot(farmland) water_farmland=cover(water,farmland) plot(water_farmland) edge_water_farmland=project(water_farmland,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Water-Farmland_input.tif&quot;, overwrite=TRUE) rm(edge_water_farmland) rm(water_farmland) # Edges_Water-Farmland_cell.tif egv_165 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Water-Farmland_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Water-Farmland_cell.tif&quot;, out_layername = &quot;egv_165&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Farmland_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.166 Edges_Water-Farmland_r500 filename: Edges_Water-Farmland_r500.tif layername: egv_166 English name: Edge pixels of Water bordering with Farmland within the 0.5 km landscape Latvian name: Ūdenstilpju malu ar lauksaimniecības zemēm garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Farmland_r500.tif egv_166 ----- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r500.tif&quot;) names(slanis)=&quot;egv_166&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Farmland_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.167 Edges_Water-Farmland_r1250 filename: Edges_Water-Farmland_r1250.tif layername: egv_167 English name: Edge pixels of Water bordering with Farmland within the 1.25 km landscape Latvian name: Ūdenstilpju malu ar lauksaimniecības zemēm garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Farmland_r1250.tif egv_167 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r1250.tif&quot;) names(slanis)=&quot;egv_167&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Farmland_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.168 Edges_Water-Farmland_r3000 filename: Edges_Water-Farmland_r3000.tif layername: egv_168 English name: Edge pixels of Water bordering with Farmland within the 3 km landscape Latvian name: Ūdenstilpju malu ar lauksaimniecības zemēm garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Farmland_r3000.tif egv_168 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r3000.tif&quot;) names(slanis)=&quot;egv_168&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Farmland_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.169 Edges_Water-Farmland_r10000 filename: Edges_Water-Farmland_r10000.tif layername: egv_169 English name: Edge pixels of Water bordering with Farmland within the 10 km landscape Latvian name: Ūdenstilpju malu ar lauksaimniecības zemēm garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Farmland_r10000.tif egv_169 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r10000.tif&quot;) names(slanis)=&quot;egv_169&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Farmland_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Farmland_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.170 Edges_Water-Grassland_cell filename: Edges_Water-Grassland_cell.tif layername: egv_170 English name: Edge pixels of Water bordering with Grassland within the analysis cell (1 ha) Latvian name: Ūdenstilpju malu ar zālājiem garums analīzes šūnā (1 ha) Procedure: First, values lequal to 330 from the Landscape classification are coded as 1, and all other values as NA. Then values equal to 200 from the Landscape classification are coded as 0, and all other values as NA. Then, the first layer (1 = presence) is covered over the second layer (presence = 0) and written to file (matching the input). Next, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_Water-Grassland_input.tif ---- water=ifel(simple_landscape==200,0,NA) plot(water) grassland=ifel(simple_landscape==330,1,NA) plot(grassland) water_grassland=cover(water,grassland) plot(water_grassland) edge_water_grassland=project(water_grassland,template10, filename=&quot;./RasterGrids_10m/2024/Edges_Water-Grassland_input.tif&quot;, overwrite=TRUE) rm(edge_water_grassland) rm(water_grassland) # Edges_Water-Grassland_cell.tif egv_170 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_Water-Grassland_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_Water-Grassland_cell.tif&quot;, out_layername = &quot;egv_170&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Grassland_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.171 Edges_Water-Grassland_r500 filename: Edges_Water-Grassland_r500.tif layername: egv_171 English name: Edge pixels of Water bordering with Grassland within the 0.5 km landscape Latvian name: Ūdenstilpju malu ar zālājiem garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Grassland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Grassland_r500.tif egv_171 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r500.tif&quot;) names(slanis)=&quot;egv_171&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Grassland_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.172 Edges_Water-Grassland_r1250 filename: Edges_Water-Grassland_r1250.tif layername: egv_172 English name: Edge pixels of Water bordering with Grassland within the 1.25 km landscape Latvian name: Ūdenstilpju malu ar zālājiem garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Grassland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Grassland_r1250.tif egv_172 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r1250.tif&quot;) names(slanis)=&quot;egv_172&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Grassland_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.173 Edges_Water-Grassland_r3000 filename: Edges_Water-Grassland_r3000.tif layername: egv_173 English name: Edge pixels of Water bordering with Grassland within the 3 km landscape Latvian name: Ūdenstilpju malu ar zālājiem garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Grassland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Grassland_r3000.tif egv_173 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r3000.tif&quot;) names(slanis)=&quot;egv_173&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Grassland_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.174 Edges_Water-Grassland_r10000 filename: Edges_Water-Grassland_r10000.tif layername: egv_174 English name: Edge pixels of Water bordering with Grassland within the 10 km landscape Latvian name: Ūdenstilpju malu ar zālājiem garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_cell.tif&quot;), layer_prefixes = c(&quot;Edges_Water-Grassland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_Water-Grassland_r10000.tif egv_174 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r10000.tif&quot;) names(slanis)=&quot;egv_174&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_Water-Grassland_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_Water-Grassland_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.175 Edges_ReedSedgeRushBeds-Water_cell filename: Edges_ReedSedgeRushBeds-Water_cell.tif layername: egv_175 English name: Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the analysis cell (1 ha) Latvian name: Niedrāju, grīslāju, meldrāju malu ar ūdeni garums analīzes šūnā (1 ha) Procedure: First, values equal to 720 from the Landscape classification are coded as 1, and all other values as NA. Then values equal to 200 from the Landscape classification are coded as 0, and all other values as NA. Then, the first layer (1 = presence) is covered over the second layer (presence = 0) and written to file (matching the input). Next, with the workflow egvtools::landscape_function() total edge between the two classes is calculated. During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} # Templates ----- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;./RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Edges_ReedSedgeRushBeds-Water_input.tif ---- water=ifel(simple_landscape==200,0,NA) plot(water) reedsedgerush=ifel(simple_landscape==720,1,NA) plot(reedsedgerush) reedsedgerush_water=cover(reedsedgerush,water) plot(reedsedgerush_water) edge_reedsedgerush_water=project(reedsedgerush_water,template10, filename=&quot;./RasterGrids_10m/2024/Edges_ReedSedgeRushBeds-Water_input.tif&quot;, overwrite=TRUE) rm(edge_reedsedgerush_water) rm(reedsedgerush_water) # Edges_ReedSedgeRushBeds-Water_cell.tif egv_175 ---- landscape_function( landscape = &quot;./RasterGrids_10m/2024/Edges_ReedSedgeRushBeds-Water_input.tif&quot;, zones = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, id_field = &quot;id&quot;, tile_field = &quot;tks50km&quot;, template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, out_dir = &quot;./RasterGrids_100m/2024/RAW&quot;, out_filename = &quot;Edges_ReedSedgeRushBeds-Water_cell.tif&quot;, out_layername = &quot;egv_175&quot;, what = &quot;lsm_l_te&quot;, lm_args = list(count_boundary = FALSE), rasterize_engine = &quot;fasterize&quot;, n_workers = 12, future_max_size = 20 * 1024^3, fill_gaps = TRUE, plot_gaps = FALSE, plot_result = FALSE ) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_ReedSedgeRushBeds-Water_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.176 Edges_ReedSedgeRushBeds-Water_r500 filename: Edges_ReedSedgeRushBeds-Water_r500.tif layername: egv_176 English name: Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 0.5 km landscape Latvian name: Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 0,5 km ainavā Procedure: The total edge within a 500 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_ReedSedgeRushBeds-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_ReedSedgeRushBeds-Water_r500.tif egv_176 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r500.tif&quot;) names(slanis)=&quot;egv_176&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_ReedSedgeRushBeds-Water_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.177 Edges_ReedSedgeRushBeds-Water_r1250 filename: Edges_ReedSedgeRushBeds-Water_r1250.tif layername: egv_177 English name: Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 1.25 km landscape Latvian name: Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 1,25 km ainavā Procedure: The total edge within a 1250 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_ReedSedgeRushBeds-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_ReedSedgeRushBeds-Water_r1250.tif egv_177 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r1250.tif&quot;) names(slanis)=&quot;egv_177&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_ReedSedgeRushBeds-Water_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.178 Edges_ReedSedgeRushBeds-Water_r3000 filename: Edges_ReedSedgeRushBeds-Water_r3000.tif layername: egv_178 English name: Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 3 km landscape Latvian name: Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 3 km ainavā Procedure: The total edge within a 3000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_ReedSedgeRushBeds-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_ReedSedgeRushBeds-Water_r3000.tif egv_178 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r3000.tif&quot;) names(slanis)=&quot;egv_178&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_ReedSedgeRushBeds-Water_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.179 Edges_ReedSedgeRushBeds-Water_r10000 filename: Edges_ReedSedgeRushBeds-Water_r10000.tif layername: egv_179 English name: Edge pixels of Reed-, Sedge-, Rush- Beds bordering with Water within the 10 km landscape Latvian name: Niedrāju, grīslāju, meldrāju malu ar ūdeni garums 10 km ainavā Procedure: The total edge within a 10000 m radius around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_cell.tif&quot;), layer_prefixes = c(&quot;Edges_ReedSedgeRushBeds-Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;sum&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Edges_ReedSedgeRushBeds-Water_r10000.tif egv_179 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r10000.tif&quot;) names(slanis)=&quot;egv_179&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Edges_ReedSedgeRushBeds-Water_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Edges_ReedSedgeRushBeds-Water_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.180 FarmlandCrops_CropsAll_cell filename: FarmlandCrops_CropsAll_cell.tif layername: egv_180 English name: Fractional cover of Crops (all types) within the analysis cell (1 ha) Latvian name: Aramzemju (dažādu lauksaimniecības kultūraugu) platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels with any type of crops are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed with the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_CropsAll_cell.tif egv_180 ---- aramzemes=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;aramz&quot;)) p2i_rez=egvtools::polygon2input(vector_data = aramzemes, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_CropsAll_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_CropsAll_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_CropsAll_cell.tif&quot;, layername = &quot;egv_180&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(aramzemes) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_CropsAll_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsAll_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.181 FarmlandCrops_CropsAll_r500 filename: FarmlandCrops_CropsAll_r500.tif layername: egv_181 English name: Fractional cover of Crops (all types) within the 0.5 km landscape Latvian name: Aramzemju (dažādu lauksaimniecības kultūraugu) platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsAll_r500.tif egv_181 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r500.tif&quot;) names(slanis)=&quot;egv_181&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsAll_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.182 FarmlandCrops_CropsAll_r1250 filename: FarmlandCrops_CropsAll_r1250.tif layername: egv_182 English name: Fractional cover of Crops (all types) within the 1.25 km landscape Latvian name: Aramzemju (dažādu lauksaimniecības kultūraugu) platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsAll_r1250.tif egv_182 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r1250.tif&quot;) names(slanis)=&quot;egv_182&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsAll_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.183 FarmlandCrops_CropsAll_r3000 filename: FarmlandCrops_CropsAll_r3000.tif layername: egv_183 English name: Fractional cover of Crops (all types) within the 3 km landscape Latvian name: Aramzemju (dažādu lauksaimniecības kultūraugu) platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsAll_r3000.tif egv_183 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r3000.tif&quot;) names(slanis)=&quot;egv_183&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsAll_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.184 FarmlandCrops_CropsAll_r10000 filename: FarmlandCrops_CropsAll_r10000.tif layername: egv_184 English name: Fractional cover of Crops (all types) within the 10 km landscape Latvian name: Aramzemju (dažādu lauksaimniecības kultūraugu) platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsAll_r10000.tif egv_184 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r10000.tif&quot;) names(slanis)=&quot;egv_184&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsAll_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsAll_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.185 FarmlandCrops_CropsHoed_cell filename: FarmlandCrops_CropsHoed_cell.tif layername: egv_185 English name: Fractional cover of Hoed Crops within the analysis cell (1 ha) Latvian name: Vagu un rušināmkultūru platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as hoed crops are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_CropsHoed_cell.tif egv_185 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;ruši&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_CropsHoed_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_CropsHoed_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_CropsHoed_cell.tif&quot;, layername = &quot;egv_185&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_CropsHoed_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsHoed_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.186 FarmlandCrops_CropsHoed_r500 filename: FarmlandCrops_CropsHoed_r500.tif layername: egv_186 English name: Fractional cover of Hoed Crops within the 0.5 km landscape Latvian name: Vagu un rušināmkultūru platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsHoed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsHoed_r500.tif egv_186 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r500.tif&quot;) names(slanis)=&quot;egv_186&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsHoed_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.187 FarmlandCrops_CropsHoed_r1250 filename: FarmlandCrops_CropsHoed_r1250.tif layername: egv_187 English name: Fractional cover of Hoed Crops within the 1.25 km landscape Latvian name: Vagu un rušināmkultūru platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsHoed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsHoed_r1250.tif egv_187 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r1250.tif&quot;) names(slanis)=&quot;egv_187&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsHoed_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.188 FarmlandCrops_CropsHoed_r3000 filename: FarmlandCrops_CropsHoed_r3000.tif layername: egv_188 English name: Fractional cover of Hoed Crops within the 3 km landscape Latvian name: Vagu un rušināmkultūru platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsHoed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsHoed_r3000.tif egv_188 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r3000.tif&quot;) names(slanis)=&quot;egv_188&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsHoed_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.189 FarmlandCrops_CropsHoed_r10000 filename: FarmlandCrops_CropsHoed_r10000.tif layername: egv_189 English name: Fractional cover of Hoed Crops within the 10 km landscape Latvian name: Vagu un rušināmkultūru platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsHoed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsHoed_r10000.tif egv_189 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r10000.tif&quot;) names(slanis)=&quot;egv_189&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsHoed_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsHoed_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.190 FarmlandCrops_CropsOther_cell filename: FarmlandCrops_CropsOther_cell.tif layername: egv_190 English name: Fractional cover of Other Crops within the analysis cell (1 ha) Latvian name: Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels with otherwise not differentiated crops are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_CropsOther_cell.tif egv_190 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;citur neie&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_CropsOther_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_CropsOther_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_CropsOther_cell.tif&quot;, layername = &quot;egv_190&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_CropsOther_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsOther_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.191 FarmlandCrops_CropsOther_r500 filename: FarmlandCrops_CropsOther_r500.tif layername: egv_191 English name: Fractional cover of Other Crops within the 0.5 km landscape Latvian name: Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsOther&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsOther_r500.tif egv_191 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r500.tif&quot;) names(slanis)=&quot;egv_191&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsOther_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.192 FarmlandCrops_CropsOther_r1250 filename: FarmlandCrops_CropsOther_r1250.tif layername: egv_192 English name: Fractional cover of Other Crops within the 1.25 km landscape Latvian name: Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsOther&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsOther_r1250.tif egv_192 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r1250.tif&quot;) names(slanis)=&quot;egv_192&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsOther_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.193 FarmlandCrops_CropsOther_r3000 filename: FarmlandCrops_CropsOther_r3000.tif layername: egv_193 English name: Fractional cover of Other Crops within the 3 km landscape Latvian name: Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsOther&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsOther_r3000.tif egv_193 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r3000.tif&quot;) names(slanis)=&quot;egv_193&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsOther_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.194 FarmlandCrops_CropsOther_r10000 filename: FarmlandCrops_CropsOther_r10000.tif layername: egv_194 English name: Fractional cover of Other Crops within the 10 km landscape Latvian name: Citu lauksaimniecības kultūraugu aramzemēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsOther&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsOther_r10000.tif egv_194 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r10000.tif&quot;) names(slanis)=&quot;egv_194&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsOther_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsOther_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.195 FarmlandCrops_CropsSpring_cell filename: FarmlandCrops_CropsSpring_cell.tif layername: egv_195 English name: Fractional cover of Spring Sown Crops within the analysis cell (1 ha) Latvian name: Vasarāju aramzemēs platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as spring sown crops are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_CropsSpring_cell.tif egv_195 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;labība-vasarāji&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_CropsSpring_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_CropsSpring_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_CropsSpring_cell.tif&quot;, layername = &quot;egv_195&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_CropsSpring_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsSpring_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.196 FarmlandCrops_CropsSpring_r500 filename: FarmlandCrops_CropsSpring_r500.tif layername: egv_196 English name: Fractional cover of Spring Sown Crops within the 0.5 km landscape Latvian name: Vasarāju aramzemēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsSpring_r500.tif egv_196 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r500.tif&quot;) names(slanis)=&quot;egv_196&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsSpring_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.197 FarmlandCrops_CropsSpring_r1250 filename: FarmlandCrops_CropsSpring_r1250.tif layername: egv_197 English name: Fractional cover of Spring Sown Crops within the 1.25 km landscape Latvian name: Vasarāju aramzemēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsSpring_r1250.tif egv_197 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r1250.tif&quot;) names(slanis)=&quot;egv_197&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsSpring_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.198 FarmlandCrops_CropsSpring_r3000 filename: FarmlandCrops_CropsSpring_r3000.tif layername: egv_198 English name: Fractional cover of Spring Sown Crops within the 3 km landscape Latvian name: Vasarāju aramzemēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsSpring_r3000.tif egv_198 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r3000.tif&quot;) names(slanis)=&quot;egv_198&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsSpring_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.199 FarmlandCrops_CropsSpring_r10000 filename: FarmlandCrops_CropsSpring_r10000.tif layername: egv_199 English name: Fractional cover of Spring Sown Crops within the 10 km landscape Latvian name: Vasarāju aramzemēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsSpring_r10000.tif egv_199 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r10000.tif&quot;) names(slanis)=&quot;egv_199&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsSpring_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsSpring_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.200 FarmlandCrops_CropsWinter_cell filename: FarmlandCrops_CropsWinter_cell.tif layername: egv_200 English name: Fractional cover of Winter Crops within the analysis cell (1 ha) Latvian name: Ziemāju aramzemēs platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as winter crops are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_CropsWinter_cell.tif egv_200 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;labība-ziemāji&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_CropsWinter_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_CropsWinter_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_CropsWinter_cell.tif&quot;, layername = &quot;egv_200&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_CropsWinter_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsWinter_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.201 FarmlandCrops_CropsWinter_r500 filename: FarmlandCrops_CropsWinter_r500.tif layername: egv_201 English name: Fractional cover of Winter Crops within the 0.5 km landscape Latvian name: Ziemāju aramzemēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsWinter_r500.tif egv_201 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r500.tif&quot;) names(slanis)=&quot;egv_201&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsWinter_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.202 FarmlandCrops_CropsWinter_r1250 filename: FarmlandCrops_CropsWinter_r1250.tif layername: egv_202 English name: Fractional cover of Winter Crops within the 1.25 km landscape Latvian name: Ziemāju aramzemēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsWinter_r1250.tif egv_202 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r1250.tif&quot;) names(slanis)=&quot;egv_202&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsWinter_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.203 FarmlandCrops_CropsWinter_r3000 filename: FarmlandCrops_CropsWinter_r3000.tif layername: egv_203 English name: Fractional cover of Winter Crops within the 3 km landscape Latvian name: Ziemāju aramzemēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsWinter_r3000.tif egv_203 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r3000.tif&quot;) names(slanis)=&quot;egv_203&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsWinter_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.204 FarmlandCrops_CropsWinter_r10000 filename: FarmlandCrops_CropsWinter_r10000.tif layername: egv_204 English name: Fractional cover of Winter Crops within the 10 km landscape Latvian name: Ziemāju aramzemēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_CropsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_CropsWinter_r10000.tif egv_204 ---- slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r10000.tif&quot;) names(slanis)=&quot;egv_204&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_CropsWinter_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_CropsWinter_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.205 FarmlandCrops_RapeseedsSpring_cell filename: FarmlandCrops_RapeseedsSpring_cell.tif layername: egv_205 English name: Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the analysis cell (1 ha) Latvian name: Vasaras rapša, ripša, kukurūzas platība analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as spring sown rapeseed, turnip or corn are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_RapeseedsSpring_cell.tif egv_205 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;vasaras rapsis&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_RapeseedsSpring_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_RapeseedsSpring_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_RapeseedsSpring_cell.tif&quot;, layername = &quot;egv_205&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_RapeseedsSpring_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsSpring_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.206 FarmlandCrops_RapeseedsSpring_r500 filename: FarmlandCrops_RapeseedsSpring_r500.tif layername: egv_206 English name: Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 0.5 km landscape Latvian name: Vasaras rapša, ripša, kukurūzas platība 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsSpring_r500.tif egv_206 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r500.tif&quot;) names(slanis)=&quot;egv_206&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsSpring_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.207 FarmlandCrops_RapeseedsSpring_r1250 filename: FarmlandCrops_RapeseedsSpring_r1250.tif layername: egv_207 English name: Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 1.25 km landscape Latvian name: Vasaras rapša, ripša, kukurūzas platība 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsSpring_r1250.tif egv_207 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r1250.tif&quot;) names(slanis)=&quot;egv_207&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsSpring_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.208 FarmlandCrops_RapeseedsSpring_r3000 filename: FarmlandCrops_RapeseedsSpring_r3000.tif layername: egv_208 English name: Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 3 km landscape Latvian name: Vasaras rapša, ripša, kukurūzas platība 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsSpring_r3000.tif egv_208 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r3000.tif&quot;) names(slanis)=&quot;egv_208&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsSpring_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.209 FarmlandCrops_RapeseedsSpring_r10000 filename: FarmlandCrops_RapeseedsSpring_r10000.tif layername: egv_209 English name: Fractional cover of Spring Sown Rapeseed, Turnip, Corn within the 10 km landscape Latvian name: Vasaras rapša, ripša, kukurūzas platība 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsSpring&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsSpring_r10000.tif egv_209 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r10000.tif&quot;) names(slanis)=&quot;egv_209&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsSpring_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsSpring_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.210 FarmlandCrops_RapeseedsWinter_cell filename: FarmlandCrops_RapeseedsWinter_cell.tif layername: egv_210 English name: Fractional cover of Winter Rapeseed, Turnip within the analysis cell (1 ha) Latvian name: Ziemas rapša, ripša platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as winter rapeseed or turnip are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandCrops_RapeseedsWinter_cell.tif egv_210 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;ziemas rapsis&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandCrops_RapeseedsWinter_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandCrops_RapeseedsWinter_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandCrops_RapeseedsWinter_cell.tif&quot;, layername = &quot;egv_210&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandCrops_RapeseedsWinter_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsWinter_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.211 FarmlandCrops_RapeseedsWinter_r500 filename: FarmlandCrops_RapeseedsWinter_r500.tif layername: egv_211 English name: Fractional cover of Winter Rapeseed, Turnip within the 0.5 km landscape Latvian name: Ziemas rapša, ripša platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsWinter_r500.tif egv_211 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r500.tif&quot;) names(slanis)=&quot;egv_211&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsWinter_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.212 FarmlandCrops_RapeseedsWinter_r1250 filename: FarmlandCrops_RapeseedsWinter_r1250.tif layername: egv_212 English name: Fractional cover of Winter Rapeseed, Turnip within the 1.25 km landscape Latvian name: Ziemas rapša, ripša platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsWinter_r1250.tif egv_212 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r1250.tif&quot;) names(slanis)=&quot;egv_212&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsWinter_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.213 FarmlandCrops_RapeseedsWinter_r3000 filename: FarmlandCrops_RapeseedsWinter_r3000.tif layername: egv_213 English name: Fractional cover of Winter Rapeseed, Turnip within the 3 km landscape Latvian name: Ziemas rapša, ripša platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsWinter_r3000.tif egv_213 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r3000.tif&quot;) names(slanis)=&quot;egv_213&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsWinter_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.214 FarmlandCrops_RapeseedsWinter_r10000 filename: FarmlandCrops_RapeseedsWinter_r10000.tif layername: egv_214 English name: Fractional cover of Winter Rapeseed, Turnip within the 10 km landscape Latvian name: Ziemas rapša, ripša platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandCrops_RapeseedsWinter&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandCrops_RapeseedsWinter_r10000.tif egv_214 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r10000.tif&quot;) names(slanis)=&quot;egv_214&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandCrops_RapeseedsWinter_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandCrops_RapeseedsWinter_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.215 FarmlandGrassland_GrasslandsAbandoned_cell filename: FarmlandGrassland_GrasslandsAbandoned_cell.tif layername: egv_215 English name: Fractional cover of Abandoned Grassland within the analysis cell (1 ha) Latvian name: Neapsaimniekotu zālāju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the grasslands from the Landscape classification are selected (value 330 reclassified as value 1, others as NA). Next, agricultural parcels declared as grasslands are selected from the Rural Support Service’s information on declared fields. Next, cells with grasslands in Landscape classification but not in the Rural Support Service’s information on declared fields are selected and matched to input layer. Once matched, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandGrassland_GrasslandsAbandoned_cell.tif egv_215 ---- landscape_grasslands=ifel(simple_landscape==330,1,0) dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;zālāji&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) lad_zalajiem=fasterize(dati,rastrs10,field=&quot;yes&quot;,fun=&quot;first&quot;) lad_zalaji=rast(lad_zalajiem) abandoned=ifel(landscape_grasslands==1&amp;is.na(lad_zalaji),1,0) plot(abandoned) i2e_rez=egvtools::input2egv(input=abandoned, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot;, layername = &quot;egv_215&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(i2e_rez) rm(dati) rm(lad_zalajiem) rm(lad_zalaji) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.216 FarmlandGrassland_GrasslandsAbandoned_r500 filename: FarmlandGrassland_GrasslandsAbandoned_r500.tif layername: egv_216 English name: Fractional cover of Abandoned Grassland within the 0.5 km landscape Latvian name: Neapsaimniekotu zālāju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAbandoned&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAbandoned_r500.tif egv_216 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r500.tif&quot;) names(slanis)=&quot;egv_216&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAbandoned_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.217 FarmlandGrassland_GrasslandsAbandoned_r1250 filename: FarmlandGrassland_GrasslandsAbandoned_r1250.tif layername: egv_217 English name: Fractional cover of Abandoned Grassland within the 1.25 km landscape Latvian name: Neapsaimniekotu zālāju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAbandoned&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAbandoned_r1250.tif egv_217 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r1250.tif&quot;) names(slanis)=&quot;egv_217&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAbandoned_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.218 FarmlandGrassland_GrasslandsAbandoned_r3000 filename: FarmlandGrassland_GrasslandsAbandoned_r3000.tif layername: egv_218 English name: Fractional cover of Abandoned Grassland within the 3 km landscape Latvian name: Neapsaimniekotu zālāju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAbandoned&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAbandoned_r3000.tif egv_218 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r3000.tif&quot;) names(slanis)=&quot;egv_218&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAbandoned_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.219 FarmlandGrassland_GrasslandsAbandoned_r10000 filename: FarmlandGrassland_GrasslandsAbandoned_r10000.tif layername: egv_219 English name: Fractional cover of Abandoned Grassland within the 10 km landscape Latvian name: Neapsaimniekotu zālāju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAbandoned&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAbandoned_r10000.tif egv_219 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r10000.tif&quot;) names(slanis)=&quot;egv_219&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAbandoned_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAbandoned_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.220 FarmlandGrassland_GrasslandsAll_cell filename: FarmlandGrassland_GrasslandsAll_cell.tif layername: egv_220 English name: Fractional cover of any Grassland within the analysis cell (1 ha) Latvian name: Zālāju (visu veidu) platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the grasslands from the Landscape classification are selected (value 330 reclassified to value 1, others as 0). Once selected, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandGrassland_GrasslandsAll_cell.tif egv_220 ---- landscape_grasslands=ifel(simple_landscape==330,1,0) i2e_rez=egvtools::input2egv(input=landscape_grasslands, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandGrassland_GrasslandsAll_cell.tif&quot;, layername = &quot;egv_220&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(i2e_rez) rm(landscape_grasslands) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAll_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.221 FarmlandGrassland_GrasslandsAll_r500 filename: FarmlandGrassland_GrasslandsAll_r500.tif layername: egv_221 English name: Fractional cover of any Grassland within the 0.5 km landscape Latvian name: Zālāju (visu veidu) platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAll_r500.tif egv_221 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r500.tif&quot;) names(slanis)=&quot;egv_221&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAll_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.222 FarmlandGrassland_GrasslandsAll_r1250 filename: FarmlandGrassland_GrasslandsAll_r1250.tif layername: egv_222 English name: Fractional cover of any Grassland within the 1.25 km landscape Latvian name: Zālāju (visu veidu) platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAll_r1250.tif egv_222 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r1250.tif&quot;) names(slanis)=&quot;egv_222&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAll_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.223 FarmlandGrassland_GrasslandsAll_r3000 filename: FarmlandGrassland_GrasslandsAll_r3000.tif layername: egv_223 English name: Fractional cover of any Grassland within the 3 km landscape Latvian name: Zālāju (visu veidu) platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAll_r3000.tif egv_223 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r3000.tif&quot;) names(slanis)=&quot;egv_223&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAll_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.224 FarmlandGrassland_GrasslandsAll_r10000 filename: FarmlandGrassland_GrasslandsAll_r10000.tif layername: egv_224 English name: Fractional cover of any Grassland within the 10 km landscape Latvian name: Zālāju (visu veidu) platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsAll&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsAll_r10000.tif egv_224 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r10000.tif&quot;) names(slanis)=&quot;egv_224&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsAll_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsAll_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.225 FarmlandGrassland_GrasslandsPermanent_cell filename: FarmlandGrassland_GrasslandsPermanent_cell.tif layername: egv_225 English name: Fractional cover of Permanent Grassland within the analysis cell (1 ha) Latvian name: Ilggadīgu zālāju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as permanent grasslands are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed with the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandGrassland_GrasslandsPermanent_cell.tif egv_225 ---- dati=lad %&gt;% filter(SDM_grupa_sakums==&quot;zālāji (ilggadīgie)&quot;) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandGrassland_GrasslandsPermanent_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandGrassland_GrasslandsPermanent_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandGrassland_GrasslandsPermanent_cell.tif&quot;, layername = &quot;egv_225&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandGrassland_GrasslandsPermanent_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsPermanent_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.226 FarmlandGrassland_GrasslandsPermanent_r500 filename: FarmlandGrassland_GrasslandsPermanent_r500.tif layername: egv_226 English name: Fractional cover of Permanent Grassland within the 0.5 km landscape Latvian name: Ilggadīgu zālāju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsPermanent&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsPermanent_r500.tif egv_226 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r500.tif&quot;) names(slanis)=&quot;egv_226&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsPermanent_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.227 FarmlandGrassland_GrasslandsPermanent_r1250 filename: FarmlandGrassland_GrasslandsPermanent_r1250.tif layername: egv_227 English name: Fractional cover of Permanent Grassland within the 1.25 km landscape Latvian name: Ilggadīgu zālāju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsPermanent&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsPermanent_r1250.tif egv_227 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r1250.tif&quot;) names(slanis)=&quot;egv_227&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsPermanent_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.228 FarmlandGrassland_GrasslandsPermanent_r3000 filename: FarmlandGrassland_GrasslandsPermanent_r3000.tif layername: egv_228 English name: Fractional cover of Permanent Grassland within the 3 km landscape Latvian name: Ilggadīgu zālāju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsPermanent&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsPermanent_r3000.tif egv_228 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r3000.tif&quot;) names(slanis)=&quot;egv_228&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsPermanent_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.229 FarmlandGrassland_GrasslandsPermanent_r10000 filename: FarmlandGrassland_GrasslandsPermanent_r10000.tif layername: egv_229 English name: Fractional cover of Permanent Grassland within the 10 km landscape Latvian name: Ilggadīgu zālāju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsPermanent&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsPermanent_r10000.tif egv_229 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r10000.tif&quot;) names(slanis)=&quot;egv_229&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsPermanent_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsPermanent_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.230 FarmlandGrassland_GrasslandsTemporary_cell filename: FarmlandGrassland_GrasslandsTemporary_cell.tif layername: egv_230 English name: Fractional cover of Temporary Grassland within the analysis cell (1 ha) Latvian name: Zālāju-aramzemē platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as grasslands in arable lands are selected from the Rural Support Service’s information on declared fields. These geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed with the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandGrassland_GrasslandsTemporary_cell.tif egv_230 ---- dati=lad %&gt;% filter(str_detect(SDM_grupa_sakums,&quot;kultivēt&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandGrassland_GrasslandsTemporary_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandGrassland_GrasslandsTemporary_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandGrassland_GrasslandsTemporary_cell.tif&quot;, layername = &quot;egv_230&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandGrassland_GrasslandsTemporary_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsTemporary_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.231 FarmlandGrassland_GrasslandsTemporary_r500 filename: FarmlandGrassland_GrasslandsTemporary_r500.tif layername: egv_231 English name: Fractional cover of Temporary Grassland within the 0.5 km landscape Latvian name: Zālāju-aramzemē platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsTemporary&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsTemporary_r500.tif egv_231 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r500.tif&quot;) names(slanis)=&quot;egv_231&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsTemporary_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.232 FarmlandGrassland_GrasslandsTemporary_r1250 filename: FarmlandGrassland_GrasslandsTemporary_r1250.tif layername: egv_232 English name: Fractional cover of Temporary Grassland within the 1.25 km landscape Latvian name: Zālāju-aramzemē platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsTemporary&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsTemporary_r1250.tif egv_232 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r1250.tif&quot;) names(slanis)=&quot;egv_232&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsTemporary_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.233 FarmlandGrassland_GrasslandsTemporary_r3000 filename: FarmlandGrassland_GrasslandsTemporary_r3000.tif layername: egv_233 English name: Fractional cover of Temporary Grassland within the 3 km landscape Latvian name: Zālāju-aramzemē platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsTemporary&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsTemporary_r3000.tif egv_233 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r3000.tif&quot;) names(slanis)=&quot;egv_233&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsTemporary_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.234 FarmlandGrassland_GrasslandsTemporary_r10000 filename: FarmlandGrassland_GrasslandsTemporary_r10000.tif layername: egv_234 English name: Fractional cover of Temporary Grassland within the 10 km landscape Latvian name: Zālāju-aramzemē platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandGrassland_GrasslandsTemporary&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandGrassland_GrasslandsTemporary_r10000.tif egv_234 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r10000.tif&quot;) names(slanis)=&quot;egv_234&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandGrassland_GrasslandsTemporary_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandGrassland_GrasslandsTemporary_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.235 FarmlandParcels_FieldsActive_cell filename: FarmlandParcels_FieldsActive_cell.tif layername: egv_235 English name: Fractional cover of Agricultural Land Parcels within the analysis cell (1 ha) Latvian name: Lauku bloku platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels from the Rural Support Service’s information on declared fields are rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed with the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandParcels_FieldsActive_cell.tif egv_235 ---- p2i_rez=egvtools::polygon2input(vector_data = lad, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandParcels_FieldsActive_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandParcels_FieldsActive_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandParcels_FieldsActive_cell.tif&quot;, layername = &quot;egv_235&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandParcels_FieldsActive_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandParcels_FieldsActive_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.236 FarmlandParcels_FieldsActive_r500 filename: FarmlandParcels_FieldsActive_r500.tif layername: egv_236 English name: Fractional cover of Agricultural Land Parcels within the 0.5 km landscape Latvian name: Lauku bloku platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandParcels_FieldsActive&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandParcels_FieldsActive_r500.tif egv_236 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r500.tif&quot;) names(slanis)=&quot;egv_236&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandParcels_FieldsActive_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.237 FarmlandParcels_FieldsActive_r1250 filename: FarmlandParcels_FieldsActive_r1250.tif layername: egv_237 English name: Fractional cover of Agricultural Land Parcels within the 1.25 km landscape Latvian name: Lauku bloku platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandParcels_FieldsActive&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandParcels_FieldsActive_r1250.tif egv_237 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r1250.tif&quot;) names(slanis)=&quot;egv_237&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandParcels_FieldsActive_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.238 FarmlandParcels_FieldsActive_r3000 filename: FarmlandParcels_FieldsActive_r3000.tif layername: egv_238 English name: Fractional cover of Agricultural Land Parcels within the 3 km landscape Latvian name: Lauku bloku platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandParcels_FieldsActive&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandParcels_FieldsActive_r3000.tif egv_238 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r3000.tif&quot;) names(slanis)=&quot;egv_238&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandParcels_FieldsActive_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.239 FarmlandParcels_FieldsActive_r10000 filename: FarmlandParcels_FieldsActive_r10000.tif layername: egv_239 English name: Fractional cover of Agricultural Land Parcels within the 10 km landscape Latvian name: Lauku bloku platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandParcels_FieldsActive&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandParcels_FieldsActive_r10000.tif egv_239 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r10000.tif&quot;) names(slanis)=&quot;egv_239&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandParcels_FieldsActive_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandParcels_FieldsActive_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.240 FarmlandPloughed_CropsFallow_cell filename: FarmlandPloughed_CropsFallow_cell.tif layername: egv_240 English name: Fractional cover of Crop-, Fallow- Land within the analysis cell (1 ha) Latvian name: Aramzemju, papuvju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as crops or fallow land are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandPloughed_CropsFallow_cell.tif egv_240 ---- dati=lad %&gt;% filter(SDM_grupa_sakums %in% c(&quot;aramzemes (citur neiekļautās)&quot;, &quot;aramzemes (labība-vasarāji)&quot;, &quot;aramzemes (labība-ziemāji)&quot;, &quot;aramzemes (vagu un rušināmkultūru)&quot;, &quot;aramzemes (vasaras rapsis un rispsis, kukurūzas, zirņi un pupas, soja, kaņepes)&quot;, &quot;aramzemes (ziemas rapsis un ripsis)&quot;, &quot;papuves&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandPloughed_CropsFallow_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandPloughed_CropsFallow_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandPloughed_CropsFallow_cell.tif&quot;, layername = &quot;egv_240&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandPloughed_CropsFallow_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallow_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.241 FarmlandPloughed_CropsFallow_r500 filename: FarmlandPloughed_CropsFallow_r500.tif layername: egv_241 English name: Fractional cover of Crop-, Fallow- Land within the 0.5 km landscape Latvian name: Aramzemju, papuvju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallow_r500.tif egv_241 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r500.tif&quot;) names(slanis)=&quot;egv_241&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallow_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.242 FarmlandPloughed_CropsFallow_r1250 filename: FarmlandPloughed_CropsFallow_r1250.tif layername: egv_242 English name: Fractional cover of Crop-, Fallow- Land within the 1.25 km landscape Latvian name: Aramzemju, papuvju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallow_r1250.tif egv_242 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r1250.tif&quot;) names(slanis)=&quot;egv_242&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallow_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.243 FarmlandPloughed_CropsFallow_r3000 filename: FarmlandPloughed_CropsFallow_r3000.tif layername: egv_243 English name: Fractional cover of Crop-, Fallow- Land within the 3 km landscape Latvian name: Aramzemju, papuvju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallow_r3000.tif egv_243 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r3000.tif&quot;) names(slanis)=&quot;egv_243&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallow_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.244 FarmlandPloughed_CropsFallow_r10000 filename: FarmlandPloughed_CropsFallow_r10000.tif layername: egv_244 English name: Fractional cover of Crop-, Fallow- Land within the 10 km landscape Latvian name: Aramzemju, papuvju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallow_r10000.tif egv_244 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r10000.tif&quot;) names(slanis)=&quot;egv_244&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallow_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallow_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.245 FarmlandPloughed_CropsFallowTempGrass_cell filename: FarmlandPloughed_CropsFallowTempGrass_cell.tif layername: egv_245 English name: Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the analysis cell (1 ha) Latvian name: Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as crops, fallow land or grasslands in arable land are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandPloughed_CropsFallowTempGrass_cell.tif egv_245 ---- dati=lad %&gt;% filter(SDM_grupa_sakums %in% c(&quot;aramzemes (citur neiekļautās)&quot;, &quot;aramzemes (labība-vasarāji)&quot;, &quot;aramzemes (labība-ziemāji)&quot;, &quot;aramzemes (vagu un rušināmkultūru)&quot;, &quot;aramzemes (vasaras rapsis un rispsis, kukurūzas, zirņi un pupas, soja, kaņepes)&quot;, &quot;aramzemes (ziemas rapsis un ripsis)&quot;, &quot;papuves&quot;, &quot;zālāji (kultivētie)&quot;)) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandPloughed_CropsFallowTempGrass_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandPloughed_CropsFallowTempGrass_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot;, layername = &quot;egv_245&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandPloughed_CropsFallowTempGrass_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.246 FarmlandPloughed_CropsFallowTempGrass_r500 filename: FarmlandPloughed_CropsFallowTempGrass_r500.tif layername: egv_246 English name: Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 0.5 km landscape Latvian name: Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallowTempGrass&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallowTempGrass_r500.tif egv_246 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r500.tif&quot;) names(slanis)=&quot;egv_246&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallowTempGrass_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.247 FarmlandPloughed_CropsFallowTempGrass_r1250 filename: FarmlandPloughed_CropsFallowTempGrass_r1250.tif layername: egv_247 English name: Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 1.25 km landscape Latvian name: Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallowTempGrass&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallowTempGrass_r1250.tif egv_247 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r1250.tif&quot;) names(slanis)=&quot;egv_247&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallowTempGrass_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.248 FarmlandPloughed_CropsFallowTempGrass_r3000 filename: FarmlandPloughed_CropsFallowTempGrass_r3000.tif layername: egv_248 English name: Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 3 km landscape Latvian name: Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallowTempGrass&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallowTempGrass_r3000.tif egv_248 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r3000.tif&quot;) names(slanis)=&quot;egv_248&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallowTempGrass_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.249 FarmlandPloughed_CropsFallowTempGrass_r10000 filename: FarmlandPloughed_CropsFallowTempGrass_r10000.tif layername: egv_249 English name: Fractional cover of Crop-, Fallow-, Temporary Grass- Lands within the 10 km landscape Latvian name: Aramzemju, papuvju, zālāju-aramzemē platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_CropsFallowTempGrass&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_CropsFallowTempGrass_r10000.tif egv_249 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r10000.tif&quot;) names(slanis)=&quot;egv_249&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_CropsFallowTempGrass_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_CropsFallowTempGrass_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.250 FarmlandPloughed_Fallow_cell filename: FarmlandPloughed_Fallow_cell.tif layername: egv_250 English name: Fractional cover of Fallow Land within the analysis cell (1 ha) Latvian name: Papuvju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as fallow land are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandPloughed_Fallow_cell.tif egv_250 ---- dati=lad %&gt;% filter(SDM_grupa_sakums == &quot;papuves&quot;) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandPloughed_Fallow_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandPloughed_Fallow_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandPloughed_Fallow_cell.tif&quot;, layername = &quot;egv_250&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandPloughed_Fallow_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_Fallow_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.251 FarmlandPloughed_Fallow_r500 filename: FarmlandPloughed_Fallow_r500.tif layername: egv_251 English name: Fractional cover of Fallow Land within the 0.5 km landscape Latvian name: Papuvju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_Fallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_Fallow_r500.tif egv_251 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r500.tif&quot;) names(slanis)=&quot;egv_251&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_Fallow_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.252 FarmlandPloughed_Fallow_r1250 filename: FarmlandPloughed_Fallow_r1250.tif layername: egv_252 English name: Fractional cover of Fallow Land within the 1.25 km landscape Latvian name: Papuvju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_Fallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_Fallow_r1250.tif egv_252 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r1250.tif&quot;) names(slanis)=&quot;egv_252&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_Fallow_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.253 FarmlandPloughed_Fallow_r3000 filename: FarmlandPloughed_Fallow_r3000.tif layername: egv_253 English name: Fractional cover of Fallow Land within the 3 km landscape Latvian name: Papuvju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_Fallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_Fallow_r3000.tif egv_253 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r3000.tif&quot;) names(slanis)=&quot;egv_253&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_Fallow_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.254 FarmlandPloughed_Fallow_r10000 filename: FarmlandPloughed_Fallow_r10000.tif layername: egv_254 English name: Fractional cover of Fallow Land within the 10 km landscape Latvian name: Papuvju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandPloughed_Fallow&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandPloughed_Fallow_r10000.tif egv_254 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r10000.tif&quot;) names(slanis)=&quot;egv_254&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandPloughed_Fallow_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandPloughed_Fallow_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.255 FarmlandSubsidies_BiologicalSubsidies_cell filename: FarmlandSubsidies_BiologicalSubsidies_cell.tif layername: egv_255 English name: Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the analysis cell (1 ha) Latvian name: Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as receiving subsidies for biological agriculture are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandSubsidies_BiologicalSubsidies_cell.tif egv_255 ---- dati=lad %&gt;% filter(str_detect(AID_FORMS,&quot;BLA&quot;)) table(dati$AID_FORMS,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandSubsidies_BiologicalSubsidies_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandSubsidies_BiologicalSubsidies_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot;, layername = &quot;egv_255&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandSubsidies_BiologicalSubsidies_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.256 FarmlandSubsidies_BiologicalSubsidies_r500 filename: FarmlandSubsidies_BiologicalSubsidies_r500.tif layername: egv_256 English name: Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 0.5 km landscape Latvian name: Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandSubsidies_BiologicalSubsidies&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandSubsidies_BiologicalSubsidies_r500.tif egv_256 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r500.tif&quot;) names(slanis)=&quot;egv_256&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandSubsidies_BiologicalSubsidies_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.257 FarmlandSubsidies_BiologicalSubsidies_r1250 filename: FarmlandSubsidies_BiologicalSubsidies_r1250.tif layername: egv_257 English name: Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 1.25 km landscape Latvian name: Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandSubsidies_BiologicalSubsidies&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandSubsidies_BiologicalSubsidies_r1250.tif egv_257 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r1250.tif&quot;) names(slanis)=&quot;egv_257&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandSubsidies_BiologicalSubsidies_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.258 FarmlandSubsidies_BiologicalSubsidies_r3000 filename: FarmlandSubsidies_BiologicalSubsidies_r3000.tif layername: egv_258 English name: Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 3 km landscape Latvian name: Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandSubsidies_BiologicalSubsidies&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandSubsidies_BiologicalSubsidies_r3000.tif egv_258 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r3000.tif&quot;) names(slanis)=&quot;egv_258&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandSubsidies_BiologicalSubsidies_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.259 FarmlandSubsidies_BiologicalSubsidies_r10000 filename: FarmlandSubsidies_BiologicalSubsidies_r10000.tif layername: egv_259 English name: Fractional cover of Farmland receiving Subsidies for Biological Agriculture within the 10 km landscape Latvian name: Bioloģiskās lauksaimniecības atbalstam pieteikto lauksaimniecības platību īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandSubsidies_BiologicalSubsidies&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandSubsidies_BiologicalSubsidies_r10000.tif egv_259 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r10000.tif&quot;) names(slanis)=&quot;egv_259&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandSubsidies_BiologicalSubsidies_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandSubsidies_BiologicalSubsidies_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.260 FarmlandTrees_PermanentCrops_cell filename: FarmlandTrees_PermanentCrops_cell.tif layername: egv_260 English name: Fractional cover of Permanent Crops within the analysis cell (1 ha) Latvian name: Augļudārzu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as permanent crops are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandTrees_PermanentCrops_cell.tif egv_260 ---- dati=lad %&gt;% filter(SDM_grupa_sakums == &quot;augļudārzi&quot;) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) dati=dati %&gt;% dplyr::select(yes) topo=sfarrow::st_read_parquet(&quot;./Geodata/2024/TopographicMap/LandusA_COMB.parquet&quot;) dati_topo= topo %&gt;% filter(FNAME %in% c(&quot;poligons_Augludarzs&quot;,&quot;poligons_Augļudārzs&quot;, &quot;poligons_Ogulājs&quot;,&quot;poligons_Ogulajs&quot;)) %&gt;% mutate(yes=1) %&gt;% dplyr::select(yes) abidati=rbind(dati,dati_topo) p2i_rez=egvtools::polygon2input(vector_data = abidati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandTrees_PermanentCrops_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandTrees_PermanentCrops_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandTrees_PermanentCrops_cell.tif&quot;, layername = &quot;egv_260&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) rm(topo) rm(dati_topo) rm(abidati) unlink(&quot;./RasterGrids_10m/2024/FarmlandTrees_PermanentCrops_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_PermanentCrops_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.261 FarmlandTrees_PermanentCrops_r500 filename: FarmlandTrees_PermanentCrops_r500.tif layername: egv_261 English name: Fractional cover of Permanent Crops within the 0.5 km landscape Latvian name: Augļudārzu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_PermanentCrops&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_PermanentCrops_r500.tif egv_261 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r500.tif&quot;) names(slanis)=&quot;egv_261&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_PermanentCrops_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.262 FarmlandTrees_PermanentCrops_r1250 filename: FarmlandTrees_PermanentCrops_r1250.tif layername: egv_262 English name: Fractional cover of Permanent Crops within the 1.25 km landscape Latvian name: Augļudārzu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_PermanentCrops&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_PermanentCrops_r1250.tif egv_262 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r1250.tif&quot;) names(slanis)=&quot;egv_262&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_PermanentCrops_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.263 FarmlandTrees_PermanentCrops_r3000 filename: FarmlandTrees_PermanentCrops_r3000.tif layername: egv_263 English name: Fractional cover of Permanent Crops within the 3 km landscape Latvian name: Augļudārzu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_PermanentCrops&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_PermanentCrops_r3000.tif egv_263 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r3000.tif&quot;) names(slanis)=&quot;egv_263&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_PermanentCrops_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.264 FarmlandTrees_PermanentCrops_r10000 filename: FarmlandTrees_PermanentCrops_r10000.tif layername: egv_264 English name: Fractional cover of Permanent Crops within the 10 km landscape Latvian name: Augļudārzu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_PermanentCrops&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_PermanentCrops_r10000.tif egv_264 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r10000.tif&quot;) names(slanis)=&quot;egv_264&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_PermanentCrops_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_PermanentCrops_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.265 FarmlandTrees_ShortRotationCoppice_cell filename: FarmlandTrees_ShortRotationCoppice_cell.tif layername: egv_265 English name: Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the analysis cell (1 ha) Latvian name: Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as short rotation coppice are selected from the Rural Support Service’s information on declared fields. Geometries are then rasterised to input resolution, ensuring value 1 at the polygon locations and value 0 elsewhere. Rasterisation is performed using the workflow egvtools::polygon2input(). Once rasterised, the layer is aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean and thus results in a cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # FarmlandTrees_ShortRotationCoppice_cell.tif egv_265 ---- dati=lad %&gt;% filter(SDM_grupa_sakums == &quot;krūmveida ilggadīgie stādījumi&quot;) table(dati$SDM_grupa_sakums,useNA=&quot;always&quot;) p2i_rez=egvtools::polygon2input(vector_data = dati, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;FarmlandTrees_ShortRotationCoppice_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;FarmlandTrees_ShortRotationCoppice_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;FarmlandTrees_ShortRotationCoppice_cell.tif&quot;, layername = &quot;egv_265&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(p2i_rez) rm(i2e_rez) rm(dati) unlink(&quot;./RasterGrids_10m/2024/FarmlandTrees_ShortRotationCoppice_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_ShortRotationCoppice_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.266 FarmlandTrees_ShortRotationCoppice_r500 filename: FarmlandTrees_ShortRotationCoppice_r500.tif layername: egv_266 English name: Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 0.5 km landscape Latvian name: Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_ShortRotationCoppice&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_ShortRotationCoppice_r500.tif egv_266 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r500.tif&quot;) names(slanis)=&quot;egv_266&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_ShortRotationCoppice_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.267 FarmlandTrees_ShortRotationCoppice_r1250 filename: FarmlandTrees_ShortRotationCoppice_r1250.tif layername: egv_267 English name: Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 1.25 km landscape Latvian name: Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_ShortRotationCoppice&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_ShortRotationCoppice_r1250.tif egv_267 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r1250.tif&quot;) names(slanis)=&quot;egv_267&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_ShortRotationCoppice_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.268 FarmlandTrees_ShortRotationCoppice_r3000 filename: FarmlandTrees_ShortRotationCoppice_r3000.tif layername: egv_268 English name: Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 3 km landscape Latvian name: Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_ShortRotationCoppice&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_ShortRotationCoppice_r3000.tif egv_268 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r3000.tif&quot;) names(slanis)=&quot;egv_268&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_ShortRotationCoppice_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.269 FarmlandTrees_ShortRotationCoppice_r10000 filename: FarmlandTrees_ShortRotationCoppice_r10000.tif layername: egv_269 English name: Fractional cover of Short-rotation Coppice and Other Woody Energy Crops within the 10 km landscape Latvian name: Īscirtmeta atvasāju un enerģijai audzētu kokaugu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_cell.tif&quot;), layer_prefixes = c(&quot;FarmlandTrees_ShortRotationCoppice&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # FarmlandTrees_ShortRotationCoppice_r10000.tif egv_269 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r10000.tif&quot;) names(slanis)=&quot;egv_269&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/FarmlandTrees_ShortRotationCoppice_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;FarmlandTrees_ShortRotationCoppice_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.270 ForestsAge_ClearcutsLowStands_cell filename: ForestsAge_ClearcutsLowStands_cell.tif layername: egv_270 English name: Fractional cover of Clearcuts and Stands lower than 5 m within the analysis cell (1 ha) Latvian name: Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, stands in land category 10 with a height of less than 5 m are selected from the State Forest Service’s State Forest Registry and rasterised. After rasterisation, this layer is covered by a clear cut mask. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsAge_ClearcutsLowStands_cell.tif egv_270 ---- zemas_audzes=mvr %&gt;% filter(zkat==&quot;10&quot;) %&gt;% filter(h10&lt;5) %&gt;% dplyr::select(yes) r_zemasaudzes=fasterize(zemas_audzes,rastrs10,field=&quot;yes&quot;) t_zemasaudzes=rast(r_zemasaudzes) plot(t_zemasaudzes) cleacuts_low=cover(t_zemasaudzes,clearcut_mask) plot(cleacuts_low) i2e_rez=egvtools::input2egv(input=cleacuts_low, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsAge_ClearcutsLowStands_cell.tif&quot;, layername = &quot;egv_270&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(i2e_rez) rm(zemas_audzes) rm(r_zemasaudzes) rm(t_zemasaudzes) rm(cleacuts_low) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_ClearcutsLowStands_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.271 ForestsAge_ClearcutsLowStands_r500 filename: ForestsAge_ClearcutsLowStands_r500.tif layername: egv_271 English name: Fractional cover of Clearcuts and Stands lower than 5 m within the 0.5 km landscape Latvian name: Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_ClearcutsLowStands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_ClearcutsLowStands_r500.tif egv_271 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r500.tif&quot;) names(slanis)=&quot;egv_271&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_ClearcutsLowStands_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.272 ForestsAge_ClearcutsLowStands_r1250 filename: ForestsAge_ClearcutsLowStands_r1250.tif layername: egv_272 English name: Fractional cover of Clearcuts and Stands lower than 5 m within the 1.25 km landscape Latvian name: Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_ClearcutsLowStands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_ClearcutsLowStands_r1250.tif egv_272 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r1250.tif&quot;) names(slanis)=&quot;egv_272&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_ClearcutsLowStands_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.273 ForestsAge_ClearcutsLowStands_r3000 filename: ForestsAge_ClearcutsLowStands_r3000.tif layername: egv_273 English name: Fractional cover of Clearcuts and Stands lower than 5 m within the 3 km landscape Latvian name: Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_ClearcutsLowStands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_ClearcutsLowStands_r3000.tif egv_273 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r3000.tif&quot;) names(slanis)=&quot;egv_273&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_ClearcutsLowStands_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.274 ForestsAge_ClearcutsLowStands_r10000 filename: ForestsAge_ClearcutsLowStands_r10000.tif layername: egv_274 English name: Fractional cover of Clearcuts and Stands lower than 5 m within the 10 km landscape Latvian name: Izcirtumu un mežaudžu līdz 5 m augstumam platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_ClearcutsLowStands&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_ClearcutsLowStands_r10000.tif egv_274 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r10000.tif&quot;) names(slanis)=&quot;egv_274&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_ClearcutsLowStands_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_ClearcutsLowStands_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.275 ForestsAge_Middle_cell filename: ForestsAge_Middle_cell.tif layername: egv_275 English name: Fractional cover of Middle-Aged Forests within the analysis cell (1 ha) Latvian name: Vidēja vecuma un briestaudžu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands in land category 10 and age groups two and three are selected from State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() (presence = 1, absence = 0) restricting presence locations only outside the clear cut mask. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsAge_Middle_cell.tif egv_275 ---- videjas_audzes=mvr %&gt;% filter(zkat==&quot;10&quot;) %&gt;% #filter(h10&gt;=5) %&gt;% filter(vgr %in% c(&quot;2&quot;,&quot;3&quot;)) %&gt;% dplyr::select(yes) p2i_rez=egvtools::polygon2input(vector_data = videjas_audzes, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsAge_Middle_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsAge_Middle_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsAge_Middle_cell.tif&quot;, layername = &quot;egv_275&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(videjas_audzes) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsAge_Middle_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Middle_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.276 ForestsAge_Middle_r500 filename: ForestsAge_Middle_r500.tif layername: egv_276 English name: Fractional cover of Middle-Aged Forests within the 0.5 km landscape Latvian name: Vidēja vecuma un briestaudžu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Middle&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Middle_r500.tif egv_276 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r500.tif&quot;) names(slanis)=&quot;egv_276&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Middle_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.277 ForestsAge_Middle_r1250 filename: ForestsAge_Middle_r1250.tif layername: egv_277 English name: Fractional cover of Middle-Aged Forests within the 1.25 km landscape Latvian name: Vidēja vecuma un briestaudžu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Middle&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Middle_r1250.tif egv_277 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r1250.tif&quot;) names(slanis)=&quot;egv_277&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Middle_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.278 ForestsAge_Middle_r3000 filename: ForestsAge_Middle_r3000.tif layername: egv_278 English name: Fractional cover of Middle-Aged Forests within the 3 km landscape Latvian name: Vidēja vecuma un briestaudžu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Middle&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Middle_r3000.tif egv_278 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r3000.tif&quot;) names(slanis)=&quot;egv_278&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Middle_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.279 ForestsAge_Middle_r10000 filename: ForestsAge_Middle_r10000.tif layername: egv_279 English name: Fractional cover of Middle-Aged Forests within the 10 km landscape Latvian name: Vidēja vecuma un briestaudžu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Middle&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Middle_r10000.tif egv_279 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r10000.tif&quot;) names(slanis)=&quot;egv_279&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Middle_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Middle_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.280 ForestsAge_Old_cell filename: ForestsAge_Old_cell.tif layername: egv_280 English name: Fractional cover of Old (over rotation age) Forests within the analysis cell (1 ha) Latvian name: Vecu (kopš cirtmeta) mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands in land category 10 and age groups four and five are selected from State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() (presence = 1, absence = 0) restricting presence locations only outside the clear cut mask. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsAge_Old_cell.tif egv_280 ---- vecas=mvr %&gt;% filter(zkat==&quot;10&quot;) %&gt;% #filter(h10&gt;=5) %&gt;% filter(vgr %in% c(&quot;4&quot;,&quot;5&quot;)) %&gt;% dplyr::select(yes) p2i_rez=egvtools::polygon2input(vector_data = vecas, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsAge_Old_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsAge_Old_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsAge_Old_cell.tif&quot;, layername = &quot;egv_280&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(vecas) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsAge_Old_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Old_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.281 ForestsAge_Old_r500 filename: ForestsAge_Old_r500.tif layername: egv_281 English name: Fractional cover of Old (over rotation age) Forests within the 0.5 km landscape Latvian name: Vecu (kopš cirtmeta) mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Old&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Old_r500.tif egv_281 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r500.tif&quot;) names(slanis)=&quot;egv_281&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Old_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.282 ForestsAge_Old_r1250 filename: ForestsAge_Old_r1250.tif layername: egv_282 English name: Fractional cover of Old (over rotation age) Forests within the 1.25 km landscape Latvian name: Vecu (kopš cirtmeta) mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Old&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Old_r1250.tif egv_282 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r1250.tif&quot;) names(slanis)=&quot;egv_282&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Old_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.283 ForestsAge_Old_r3000 filename: ForestsAge_Old_r3000.tif layername: egv_283 English name: Fractional cover of Old (over rotation age) Forests within the 3 km landscape Latvian name: Vecu (kopš cirtmeta) mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Old&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Old_r3000.tif egv_283 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r3000.tif&quot;) names(slanis)=&quot;egv_283&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Old_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.284 ForestsAge_Old_r10000 filename: ForestsAge_Old_r10000.tif layername: egv_284 English name: Fractional cover of Old (over rotation age) Forests within the 10 km landscape Latvian name: Vecu (kopš cirtmeta) mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_Old&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_Old_r10000.tif egv_284 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r10000.tif&quot;) names(slanis)=&quot;egv_284&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_Old_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_Old_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.285 ForestsAge_YoungTallStandsShrubs_cell filename: ForestsAge_YoungTallStandsShrubs_cell.tif layername: egv_285 English name: Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the analysis cell (1 ha) Latvian name: Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands in land category 10 and age group 1 with height above 5 m are selected from the State Forest Service’s State Forest Registry and rasterised (presence = 1, NA otherwise). This layer is then combined with the category 620 from the Landscape classification (presence = 1, 0 otherwise). Values in pixels matching the clearcut mask are set to 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsAge_YoungTallStandsShrubs_cell.tif egv_285 ---- jaunasaugstas=mvr %&gt;% filter(zkat==&quot;10&quot;) %&gt;% filter(h10&gt;=5) %&gt;% filter(vgr %in% c(&quot;1&quot;)) %&gt;% dplyr::select(yes) r_jaunasaugstas=fasterize(jaunasaugstas,rastrs10,field=&quot;yes&quot;) t_jaunasaugstas=rast(r_jaunasaugstas) plot(t_jaunasaugstas) shrubs=ifel(simple_landscape==620,1,0) younshrubs=cover(t_jaunasaugstas,shrubs) plot(younshrubs) younshrubs2=ifel(younshrubs==1&amp;clearcut_mask==0,1,0) plot(younshrubs2) i2e_rez=egvtools::input2egv(input=younshrubs2, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsAge_YoungTallStandsShrubs_cell.tif&quot;, layername = &quot;egv_285&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(jaunasaugstas) rm(r_jaunasaugstas) rm(t_jaunasaugstas) rm(shrubs) rm(younshrubs) rm(younshrubs2) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_YoungTallStandsShrubs_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.286 ForestsAge_YoungTallStandsShrubs_r500 filename: ForestsAge_YoungTallStandsShrubs_r500.tif layername: egv_286 English name: Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 0.5 km landscape Latvian name: Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_YoungTallStandsShrubs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_YoungTallStandsShrubs_r500.tif egv_286 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r500.tif&quot;) names(slanis)=&quot;egv_286&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_YoungTallStandsShrubs_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.287 ForestsAge_YoungTallStandsShrubs_r1250 filename: ForestsAge_YoungTallStandsShrubs_r1250.tif layername: egv_287 English name: Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 1.25 km landscape Latvian name: Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_YoungTallStandsShrubs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_YoungTallStandsShrubs_r1250.tif egv_287 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r1250.tif&quot;) names(slanis)=&quot;egv_287&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_YoungTallStandsShrubs_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.288 ForestsAge_YoungTallStandsShrubs_r3000 filename: ForestsAge_YoungTallStandsShrubs_r3000.tif layername: egv_288 English name: Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 3 km landscape Latvian name: Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_YoungTallStandsShrubs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_YoungTallStandsShrubs_r3000.tif egv_288 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r3000.tif&quot;) names(slanis)=&quot;egv_288&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_YoungTallStandsShrubs_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.289 ForestsAge_YoungTallStandsShrubs_r10000 filename: ForestsAge_YoungTallStandsShrubs_r10000.tif layername: egv_289 English name: Fractional cover of Shrubs, Young Stands (at least 5 m tall) within the 10 km landscape Latvian name: Krūmāju un jaunaudžu (no 5 m augstuma) platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_cell.tif&quot;), layer_prefixes = c(&quot;ForestsAge_YoungTallStandsShrubs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsAge_YoungTallStandsShrubs_r10000.tif egv_289 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r10000.tif&quot;) names(slanis)=&quot;egv_289&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsAge_YoungTallStandsShrubs_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsAge_YoungTallStandsShrubs_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.290 ForestsQuant_AgeProp-average_cell filename: ForestsQuant_AgeProp-average_cell.tif layername: egv_290 English name: Average stand age relative to rotation age within the analysis cell (1 ha) Latvian name: Mežaudzes vecuma attiecība pret cirtmetu, vidējais analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, every forest stand had assigned legal rotation age, based on dominant tree species and bonity class as registered in the State Forest Service’s State Forest Registry. We assumed 35 years for grey alder. The registered age of dominant tree group is then divided by the stand specific legal rotation age. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating arithmetic mean. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_AgeProp-average_cell.tif egv_290 ---- #Forest law https://likumi.lv/ta/id/2825#p9 ozoli=c(&quot;10&quot;,&quot;61&quot;) priedes_lapegles=c(&quot;1&quot;,&quot;13&quot;,&quot;14&quot;,&quot;22&quot;) eolgvk=c(&quot;3&quot;,&quot;15&quot;,&quot;23&quot;,&quot;11&quot;,&quot;64&quot;,&quot;12&quot;,&quot;62&quot;,&quot;16&quot;,&quot;65&quot;,&quot;24&quot;,&quot;63&quot;) berzi=c(&quot;4&quot;) melnalksni=c(&quot;6&quot;) apses=c(&quot;8&quot;,&quot;19&quot;,&quot;68&quot;) bonA=c(&quot;0&quot;,&quot;1&quot;) bonB=c(&quot;2&quot;,&quot;3&quot;) bonC=c(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;) bonAB=c(&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) nogabali=mvr %&gt;% mutate(cirtmets=ifelse((s10 %in% ozoli)&amp;(bon %in% bonA),101, ifelse((s10 %in% ozoli),121,NA))) %&gt;% mutate(cirtmets=ifelse((s10 %in% priedes_lapegles)&amp;(bon %in% bonAB),101, ifelse((s10 %in% priedes_lapegles),121,cirtmets))) %&gt;% mutate(cirtmets=ifelse((s10 %in% eolgvk),81,cirtmets)) %&gt;% mutate(cirtmets=ifelse((s10 %in% berzi)&amp;(bon %in% bonAB),71, ifelse((s10 %in% berzi),51,cirtmets))) %&gt;% mutate(cirtmets=ifelse((s10 %in% melnalksni),71,cirtmets)) %&gt;% mutate(cirtmets=ifelse((s10 %in% apses),41,cirtmets)) %&gt;% mutate(cirtmets=ifelse(is.na(cirtmets)&amp;zkat==&quot;10&quot;,35,cirtmets)) %&gt;% mutate(nogvec=a10/cirtmets) %&gt;% mutate(nogvec2=ifelse(nogvec&gt;3,3,nogvec)) %&gt;% filter(!is.na(nogvec2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$nogvec,main=&quot;Original&quot;,xlab=&quot;Relative age&quot;) hist(nogabali$nogvec2,main=&quot;Limited&quot;,xlab=&quot;Relative age&quot;) par(mfrow=c(1,1)) options(scipen=0) # 700*400 p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestQuant_AgeProp.tif&quot;, value_field = &quot;nogvec2&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestQuant_AgeProp.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_AgeProp-average_cell.tif&quot;, layername = &quot;egv_290&quot;, plot_final=TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestQuant_AgeProp.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_AgeProp-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.291 ForestsQuant_DominantDiameter-max_cell filename: ForestsQuant_DominantDiameter-max_cell.tif layername: egv_291 English name: Dominant tree trunk diameter, maximum within the analysis cell (1 ha) Latvian name: Koku stumbra diametrs, valdaudzes maksimālais analīzes šūnā (1 ha) Procedure: Most of forests describing EGVs are spatially restricted outside clearcuts and dead stands. Mask for this is created from the State Forest Service’s State Forest Registry land category 12 and 14 combined with The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of dominant tree species per inventoried forest stand - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating maximum value. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_DominantDiameter-max_cell.tif egv_291 ---- nogabali=mvr %&gt;% mutate(valddiam=ifelse(d10&gt;70,70,d10)) %&gt;% filter(!is.na(valddiam)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$d10,main=&quot;Original&quot;,xlab=&quot;Dominant diameter&quot;) hist(nogabali$valddiam,main=&quot;Limited&quot;,xlab=&quot;Dominant diameter&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestQuant_DominantDiameter.tif&quot;, value_field = &quot;valddiam&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestQuant_DominantDiameter.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;max&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_DominantDiameter-max_cell.tif&quot;, layername = &quot;egv_291&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestQuant_DominantDiameter.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_DominantDiameter-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.292 ForestsQuant_LargestDiameter-max_cell filename: ForestsQuant_LargestDiameter-max_cell.tif layername: egv_292 English name: Largest tree trunk diameter within the analysis cell (1 ha) Latvian name: Lielākais koka stumbra diametrs analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of the largest tree diameter per inventoried forest stand - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating maximum value. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_LargestDiameter-max_cell.tif egv_292 ---- nogabali=mvr %&gt;% rowwise() %&gt;% mutate(maxDiam=max(c(d10,d11,d12,d13,d14,d22,d23,d24),na.rm=TRUE)) %&gt;% ungroup() %&gt;% mutate(maxDiam2=ifelse(maxDiam&gt;100,100,maxDiam)) %&gt;% filter(!is.na(maxDiam2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$maxDiam,main=&quot;Original&quot;,xlab=&quot;Largest diameter&quot;) hist(nogabali$maxDiam2,main=&quot;Limited&quot;,xlab=&quot;Largest diameter&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_LargestDiameter.tif&quot;, value_field = &quot;maxDiam2&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_LargestDiameter.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;max&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_LargestDiameter-max_cell.tif&quot;, layername = &quot;egv_292&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_LargestDiameter.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_LargestDiameter-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.293 ForestsQuant_TimeSinceDisturbance-average_cell filename: ForestsQuant_TimeSinceDisturbance-average_cell.tif layername: egv_293 English name: Time since last disturbance affecting tree growing within the analysis cell (1 ha) Latvian name: Laiks kopš pēdējā ar koku augšanu saistītā traucējuma analīzes šūnā (1 ha) Procedure: This EGV is prepared primarily based on the information of the forestry related disturbances as registered per inventoried forest stand - State Forest Service’s State Forest Registry. The register however includes obvious errors - values later than 2024 and earlier than 1500 that are set to NA. Remaining values are subtracted from 2024. In stands with no disturbance registered, the age of dominant tree group is used to calculate minimum difference (age of time since disturbance) from the year 2024. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised (presence only). This raster layer is then overlaid with reclassified year of tree cover loss (reclassified to difference from the year 2024) and per pixel minimum value is retained. As not all the forests or tree covered areas are inventoried, classes from the Landscape classification are used to impute assumption of time since tree growing disturbance - for class 620 we assume five years, whereas for classes 630 and 640 - 50 years and 0 otherwise. Per pixel minimum layer is then overlaid the assumed time since disturbance layer. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating arithmetic mean value. After the aggregation, inverse distance weighted (power = 2) gap filling is applied to avoid possible gaps at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_TimeSinceDisturbance-average_cell.tif egv_293 ---- nogabali=mvr %&gt;% mutate(new_PDG=ifelse(p_darbg&gt;2024,NA, ifelse(p_darbv %in% c(&quot;1&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;10&quot;,&quot;11&quot;),p_darbg,NA)), new_PDG2=ifelse(new_PDG&lt;1500,NA,new_PDG), new_PCG=ifelse(p_cirg&gt;2024,NA,p_cirg), new_PCG2=ifelse(new_PCG&lt;1500,NA,new_PCG), vecumam=ifelse(a10==0,NA,a10), new_PCG3=2024-new_PCG2, new_PDG3=2024-new_PDG2) %&gt;% rowwise() %&gt;% mutate(Laikam=min(c(vecumam,new_PDG3,new_PCG3),na.rm=TRUE)) %&gt;% ungroup() %&gt;% mutate(KopsTraucejuma=ifelse(is.infinite(Laikam),NA,Laikam)) %&gt;% mutate(KopsTraucejuma2=ifelse(KopsTraucejuma&gt;200,200,KopsTraucejuma)) %&gt;% filter(!is.na(KopsTraucejuma2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$KopsTraucejuma,main=&quot;Original&quot;,xlab=&quot;Time since disturbance&quot;) hist(nogabali$KopsTraucejuma2,main=&quot;Limited&quot;,xlab=&quot;Time since disturbance&quot;) par(mfrow=c(1,1)) options(scipen=0) mvr_trauclaiks=fasterize::fasterize(nogabali,rastrs10,field=&quot;KopsTraucejuma2&quot;,fun = &quot;min&quot;) t_MVRtrauclaiks=rast(mvr_trauclaiks) plot(t_MVRtrauclaiks) gfw=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) plot(gfw) gfw2=ifel(gfw&gt;=0,24-gfw,NA) plot(gfw2) # No ainavas: ## Mežaudzes un koki = 50 ## Krūmāji un parki = 5 ## pārējais = 0 aizpildisanai=ifel(simple_landscape==630|simple_landscape==640,50, ifel(simple_landscape==620,5,0)) freq(aizpildisanai) trauclaiks1=terra::app(c(gfw2,t_MVRtrauclaiks),fun=&quot;min&quot;,na.rm=TRUE) plot(trauclaiks1) trauclaiks2=cover(trauclaiks1,aizpildisanai) plot(trauclaiks2) i2e_rez=input2egv(input=trauclaiks2, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_TimeSinceDisturbance-average_cell.tif&quot;, layername = &quot;egv_293&quot;, plot_final=TRUE) i2e_rez rm(nogabali) rm(mvr_trauclaiks) rm(t_MVRtrauclaiks) rm(gfw) rm(gfw2) rm(aizpildisanai) rm(trauclaiks1) rm(trauclaiks2) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_TimeSinceDisturbance-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.294 ForestsQuant_VolumeAspen-sum_cell filename: ForestsQuant_VolumeAspen-sum_cell.tif layername: egv_294 English name: Timber volume of Aspens, Poplars within the analysis cell (1 ha) Latvian name: Apšu, papeļu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of aspen (species codes: 8, 19, 68; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeAspen-sum_cell.tif egv_294 ---- apses=c(&quot;8&quot;,&quot;19&quot;,&quot;68&quot;) nogabali=mvr %&gt;% mutate(ApsuKraja=ifelse(s10 %in% apses, v10, 0)+ifelse(s11 %in% apses,v11,0)+ ifelse(s12 %in% apses, v12,0)+ifelse(s13 %in% apses,v13,0)+ ifelse(s14 %in% apses, v14,0)) %&gt;% mutate(ApsuKraja2=ApsuKraja/10000*10*10) %&gt;% mutate(ApsuKraja3=ifelse(ApsuKraja2&gt;5,5,ApsuKraja2)) %&gt;% filter(!is.na(ApsuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$ApsuKraja2,main=&quot;Original&quot;,xlab=&quot;Aspen volume&quot;) hist(nogabali$ApsuKraja3,main=&quot;Limited&quot;,xlab=&quot;Aspen volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeAspen.tif&quot;, value_field = &quot;ApsuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeAspen.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeAspen-sum_cell.tif&quot;, layername = &quot;egv_294&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(apses) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeAspen.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeAspen-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.295 ForestsQuant_VolumeBirch-sum_cell filename: ForestsQuant_VolumeBirch-sum_cell.tif layername: egv_295 English name: Timber volume of Birches within the analysis cell (1 ha) Latvian name: Bērzu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of birch (species code: 4; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeBirch-sum_cell.tif egv_295 ---- berzi=c(&quot;4&quot;) nogabali=mvr %&gt;% mutate(BerzuKraja=ifelse(s10 %in% berzi, v10, 0)+ifelse(s11 %in% berzi,v11,0)+ ifelse(s12 %in% berzi, v12,0)+ifelse(s13 %in% berzi,v13,0)+ ifelse(s14 %in% berzi, v14,0)) %&gt;% mutate(BerzuKraja2=BerzuKraja/10000*10*10) %&gt;% mutate(BerzuKraja3=ifelse(BerzuKraja2&gt;5,5,BerzuKraja2)) %&gt;% filter(!is.na(BerzuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$BerzuKraja2,main=&quot;Original&quot;,xlab=&quot;Birch volume&quot;) hist(nogabali$BerzuKraja3,main=&quot;Limited&quot;,xlab=&quot;Birch volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeBirch.tif&quot;, value_field = &quot;BerzuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBirch.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeBirch-sum_cell.tif&quot;, layername = &quot;egv_295&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(berzi) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBirch.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeBirch-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.296 ForestsQuant_VolumeBlackAlder-sum_cell filename: ForestsQuant_VolumeBlackAlder-sum_cell.tif layername: egv_296 English name: Timber volume of Black Alder within the analysis cell (1 ha) Latvian name: Melnalkšņu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of black alder (species code: 6; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeBlackAlder-sum_cell.tif egv_296 ---- melnalksni=c(&quot;6&quot;) nogabali=mvr %&gt;% mutate(MeKraja=ifelse(s10 %in% melnalksni, v10, 0)+ifelse(s11 %in% melnalksni,v11,0)+ ifelse(s12 %in% melnalksni, v12,0)+ifelse(s13 %in% melnalksni,v13,0)+ ifelse(s14 %in% melnalksni, v14,0)) %&gt;% mutate(MeKraja2=MeKraja/10000*10*10) %&gt;% mutate(MeKraja3=ifelse(MeKraja2&gt;4,4,MeKraja2)) %&gt;% filter(!is.na(MeKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$MeKraja2,main=&quot;Original&quot;,xlab=&quot;Black alder volume&quot;) hist(nogabali$MeKraja3,main=&quot;Limited&quot;,xlab=&quot;Black alder volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeBlackAlder.tif&quot;, value_field = &quot;MeKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBlackAlder.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeBlackAlder-sum_cell.tif&quot;, layername = &quot;egv_296&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(melnalksni) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBlackAlder.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeBlackAlder-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.297 ForestsQuant_VolumeBorealDeciduousOther-sum_cell filename: ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif layername: egv_297 English name: Timber volume of Other Boreal Deciduous trees within the analysis cell (1 ha) Latvian name: Citu šaurlapju krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of Boreal deciduous tree species not separately described with own EGVs (species codes: 9, 20, 21, 32, 35; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif egv_297 ---- sl_citi=c(&quot;9&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;) nogabali=mvr %&gt;% mutate(SaurlapjuCKraja=ifelse(s10 %in% sl_citi, v10, 0)+ifelse(s11 %in% sl_citi,v11,0)+ ifelse(s12 %in% sl_citi, v12,0)+ifelse(s13 %in% sl_citi,v13,0)+ ifelse(s14 %in% sl_citi, v14,0)) %&gt;% mutate(SaurlapjuCKraja2=SaurlapjuCKraja/10000*10*10) %&gt;% mutate(SaurlapjuCKraja3=ifelse(SaurlapjuCKraja2&gt;3,3,SaurlapjuCKraja2)) %&gt;% filter(!is.na(SaurlapjuCKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$SaurlapjuCKraja2,main=&quot;Original&quot;,xlab=&quot;Other Boreal deciduous volume&quot;) hist(nogabali$SaurlapjuCKraja3,main=&quot;Limited&quot;,xlab=&quot;Other Boreal deciduous volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeBorealDeciduousOther.tif&quot;, value_field = &quot;SaurlapjuCKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousOther.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif&quot;, layername = &quot;egv_297&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(sl_citi) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousOther.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeBorealDeciduousOther-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.298 ForestsQuant_VolumeBorealDeciduousTotal-sum_cell filename: ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif layername: egv_298 English name: Timber volume of Boreal Deciduous trees within the analysis cell (1 ha) Latvian name: Šaurlapju krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of Boreal deciduous tree species (species codes: 4, 6, 8, 9, 19, 20, 21, 32, 35, 68; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif egv_298 ---- sl_visi=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) nogabali=mvr %&gt;% mutate(SaurlapjuVKraja=ifelse(s10 %in% sl_visi, v10, 0)+ifelse(s11 %in% sl_visi,v11,0)+ ifelse(s12 %in% sl_visi, v12,0)+ifelse(s13 %in% sl_visi,v13,0)+ ifelse(s14 %in% sl_visi, v14,0)) %&gt;% mutate(SaurlapjuVKraja2=SaurlapjuVKraja/10000*10*10) %&gt;% mutate(SaurlapjuVKraja3=ifelse(SaurlapjuVKraja2&gt;6,6,SaurlapjuVKraja2)) %&gt;% filter(!is.na(SaurlapjuVKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$SaurlapjuVKraja2,main=&quot;Original&quot;,xlab=&quot;All Boreal deciduous volume&quot;) hist(nogabali$SaurlapjuVKraja3,main=&quot;Limited&quot;,xlab=&quot;All Boreal deciduous volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeBorealDeciduousTotal.tif&quot;, value_field = &quot;SaurlapjuVKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousTotal.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif&quot;, layername = &quot;egv_298&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(sl_visi) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeBorealDeciduousTotal.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeBorealDeciduousTotal-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.299 ForestsQuant_VolumeConiferous-sum_cell filename: ForestsQuant_VolumeConiferous-sum_cell.tif layername: egv_299 English name: Timber volume of Coniferous trees within the analysis cell (1 ha) Latvian name: Skujkoku krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of coniferous tree species (species codes: 1, 14, 22, 3, 13, 15, 23, 28; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeConiferous-sum_cell.tif egv_299 ---- skujkoki=c(&quot;1&quot;,&quot;14&quot;,&quot;22&quot;,&quot;3&quot;,&quot;13&quot;,&quot;15&quot;,&quot;23&quot;,&quot;28&quot;) nogabali=mvr %&gt;% mutate(SkujkokuKraja=ifelse(s10 %in% skujkoki, v10, 0)+ifelse(s11 %in% skujkoki,v11,0)+ ifelse(s12 %in% skujkoki, v12,0)+ifelse(s13 %in% skujkoki,v13,0)+ ifelse(s14 %in% skujkoki, v14,0)) %&gt;% mutate(SkujkokuKraja2=SkujkokuKraja/10000*10*10) %&gt;% mutate(SkujkokuKraja3=ifelse(SkujkokuKraja2&gt;7,7,SkujkokuKraja2)) %&gt;% filter(!is.na(SkujkokuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$SkujkokuKraja2,main=&quot;Original&quot;,xlab=&quot;Coniferous volume&quot;) hist(nogabali$SkujkokuKraja3,main=&quot;Limited&quot;,xlab=&quot;Coniferous volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeConiferous.tif&quot;, value_field = &quot;SkujkokuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeConiferous.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeConiferous-sum_cell.tif&quot;, layername = &quot;egv_299&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(skujkoki) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeConiferous.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeConiferous-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.300 ForestsQuant_VolumeOak-sum_cell filename: ForestsQuant_VolumeOak-sum_cell.tif layername: egv_300 English name: Timber volume of Oaks within the analysis cell (1 ha) Latvian name: Ozolu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of oaks (species codes: 10, 61; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeOak-sum_cell.tif egv_300 ---- ozoli=c(&quot;10&quot;,&quot;61&quot;) nogabali=mvr %&gt;% mutate(OzoluKraja=ifelse(s10 %in% ozoli, v10, 0)+ifelse(s11 %in% ozoli,v11,0)+ ifelse(s12 %in% ozoli, v12,0)+ifelse(s13 %in% ozoli,v13,0)+ ifelse(s14 %in% ozoli, v14,0)) %&gt;% mutate(OzoluKraja2=OzoluKraja/10000*10*10) %&gt;% mutate(OzoluKraja3=ifelse(OzoluKraja2&gt;2,2,OzoluKraja2)) %&gt;% filter(!is.na(OzoluKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$OzoluKraja2,main=&quot;Original&quot;,xlab=&quot;Oak volume&quot;) hist(nogabali$OzoluKraja3,main=&quot;Limited&quot;,xlab=&quot;Oak volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeOak.tif&quot;, value_field = &quot;OzoluKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeOak.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeOak-sum_cell.tif&quot;, layername = &quot;egv_300&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(ozoli) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeOak.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeOak-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.301 ForestsQuant_VolumeOakMaple-sum_cell filename: ForestsQuant_VolumeOakMaple-sum_cell.tif layername: egv_301 English name: Timber volume of Oaks, Maples within the analysis cell (1 ha) Latvian name: Ozolu, kļavu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of oaks and maples (species codes: 10, 61, 24, 63; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeOakMaple-sum_cell.tif egv_301 ---- ozolklavas=c(&quot;10&quot;,&quot;61&quot;,&quot;24&quot;,&quot;63&quot;) nogabali=mvr %&gt;% mutate(OzolKlavuKraja=ifelse(s10 %in% ozolklavas, v10, 0)+ifelse(s11 %in% ozolklavas,v11,0)+ ifelse(s12 %in% ozolklavas, v12,0)+ifelse(s13 %in% ozolklavas,v13,0)+ ifelse(s14 %in% ozolklavas, v14,0)) %&gt;% mutate(OzolKlavuKraja2=OzolKlavuKraja/10000*10*10) %&gt;% mutate(OzolKlavuKraja3=ifelse(OzolKlavuKraja2&gt;3,3,OzolKlavuKraja2)) %&gt;% filter(!is.na(OzolKlavuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$OzolKlavuKraja2,main=&quot;Original&quot;,xlab=&quot;Oak and maple volume&quot;) hist(nogabali$OzolKlavuKraja3,main=&quot;Limited&quot;,xlab=&quot;Oak and maple volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeOakMaple.tif&quot;, value_field = &quot;OzolKlavuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeOakMaple.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeOakMaple-sum_cell.tif&quot;, layername = &quot;egv_301&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(ozolklavas) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeOakMaple.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeOakMaple-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.302 ForestsQuant_VolumePine-sum_cell filename: ForestsQuant_VolumePine-sum_cell.tif layername: egv_302 English name: Timber volume of Pines within the analysis cell (1 ha) Latvian name: Priežu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of pines (species codes: 1, 14, 22; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumePine-sum_cell.tif egv_302 ---- priedes=c(&quot;1&quot;,&quot;14&quot;,&quot;22&quot;) nogabali=mvr %&gt;% mutate(PriezuKraja=ifelse(s10 %in% priedes, v10, 0)+ifelse(s11 %in% priedes,v11,0)+ ifelse(s12 %in% priedes, v12,0)+ifelse(s13 %in% priedes,v13,0)+ ifelse(s14 %in% priedes, v14,0)) %&gt;% mutate(PriezuKraja2=PriezuKraja/10000*10*10) %&gt;% mutate(PriezuKraja3=ifelse(PriezuKraja2&gt;6,6,PriezuKraja2)) %&gt;% filter(!is.na(PriezuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$PriezuKraja2,main=&quot;Original&quot;,xlab=&quot;Pine volume&quot;) hist(nogabali$PriezuKraja3,main=&quot;Limited&quot;,xlab=&quot;Pine volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumePine.tif&quot;, value_field = &quot;PriezuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumePine.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumePine-sum_cell.tif&quot;, layername = &quot;egv_302&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(priedes) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumePine.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumePine-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.303 ForestsQuant_VolumeSpruce-sum_cell filename: ForestsQuant_VolumeSpruce-sum_cell.tif layername: egv_303 English name: Timber volume of Spruces within the analysis cell (1 ha) Latvian name: Egļu krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of spruces (species codes: 3, 13, 15, 23, 28; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeSpruce-sum_cell.tif egv_303 ---- egles=c(&quot;3&quot;,&quot;13&quot;,&quot;15&quot;,&quot;23&quot;,&quot;28&quot;) nogabali=mvr %&gt;% mutate(EgluKraja=ifelse(s10 %in% egles, v10, 0)+ifelse(s11 %in% egles,v11,0)+ ifelse(s12 %in% egles, v12,0)+ifelse(s13 %in% egles,v13,0)+ ifelse(s14 %in% egles, v14,0)) %&gt;% mutate(EgluKraja2=EgluKraja/10000*10*10) %&gt;% mutate(EgluKraja3=ifelse(EgluKraja2&gt;5,5,EgluKraja2)) %&gt;% filter(!is.na(EgluKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$EgluKraja2,main=&quot;Original&quot;,xlab=&quot;Spruce volume&quot;) hist(nogabali$EgluKraja3,main=&quot;Limited&quot;,xlab=&quot;Spruce volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeSpruce.tif&quot;, value_field = &quot;EgluKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeSpruce.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeSpruce-sum_cell.tif&quot;, layername = &quot;egv_303&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(egles) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeSpruce.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeSpruce-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.304 ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell filename: ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif layername: egv_304 English name: Timber volume of Temperate Deciduous trees within the analysis cell (1 ha) Latvian name: Platlapju krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of temperate deciduous tree species (species codes: 10, 11, 12, 16, 17, 18, 24, 25, 26, 27, 29, 50, 61, 62, 63, 64, 65, 66, 67, 69; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif egv_304 ---- platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) nogabali=mvr %&gt;% mutate(PlatKraja=ifelse(s10 %in% platlapji, v10, 0)+ifelse(s11 %in% platlapji,v11,0)+ ifelse(s12 %in% platlapji, v12,0)+ifelse(s13 %in% platlapji,v13,0)+ ifelse(s14 %in% platlapji, v14,0)) %&gt;% mutate(PlatKraja2=PlatKraja/10000*10*10) %&gt;% mutate(PlatKraja3=ifelse(PlatKraja2&gt;4,4,PlatKraja2)) %&gt;% filter(!is.na(PlatKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$PlatKraja2,main=&quot;Original&quot;,xlab=&quot;Total volume\\ntemperate deciduous&quot;) hist(nogabali$PlatKraja3,main=&quot;Limited&quot;,xlab=&quot;Total volume\\ntemperate deciduous&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeTemperateDeciduousTotal.tif&quot;, value_field = &quot;PlatKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateDeciduousTotal.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif&quot;, layername = &quot;egv_304&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(platlapji) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateDeciduousTotal.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeTemperateDeciduousTotal-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.305 ForestsQuant_VolumeTemperateWithoutOak-sum_cell filename: ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif layername: egv_305 English name: Timber volume of Temperate Deciduous trees (without oaks) within the analysis cell (1 ha) Latvian name: Platlapju (bez ozoliem) krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of temperate deciduous tree species except oaks (species codes: 11, 12, 16, 17, 18, 24, 25, 26, 27, 29, 50, 62, 63, 64, 65, 66, 67, 69; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif egv_305 ---- neozoli=c(&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;29&quot;,&quot;50&quot;, &quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) nogabali=mvr %&gt;% mutate(BezOzoluKraja=ifelse(s10 %in% neozoli, v10, 0)+ifelse(s11 %in% neozoli,v11,0)+ ifelse(s12 %in% neozoli, v12,0)+ifelse(s13 %in% neozoli,v13,0)+ ifelse(s14 %in% neozoli, v14,0)) %&gt;% mutate(BezOzoluKraja2=BezOzoluKraja/10000*10*10) %&gt;% mutate(BezOzoluKraja3=ifelse(BezOzoluKraja2&gt;3,3,BezOzoluKraja2)) %&gt;% filter(!is.na(BezOzoluKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$BezOzoluKraja2,main=&quot;Original&quot;,xlab=&quot;Temperate deciduous volume\\n without oak&quot;) hist(nogabali$BezOzoluKraja3,main=&quot;Limited&quot;,xlab=&quot;Temperate deciduous volume\\nwithout oak&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeTemperateWithoutOak.tif&quot;, value_field = &quot;BezOzoluKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOak.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif&quot;, layername = &quot;egv_305&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(neozoli) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOak.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeTemperateWithoutOak-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.306 ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell filename: ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif layername: egv_306 English name: Timber volume of Temperate Deciduous trees (without oaks, maples) within the analysis cell (1 ha) Latvian name: Platlapju (bez ozoliem, kļavām) krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume of teperate deciduous trees except oaks and maples (species codes: 11, 12, 16, 17, 18, 25, 26, 27, 29, 50, 62, 64, 65, 66, 67, 69; see tree species codes in Terminology and acronyms) in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif egv_306 ---- neozolklavas=c(&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;29&quot;,&quot;50&quot;, &quot;62&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) nogabali=mvr %&gt;% mutate(BezOzolKlavuKraja=ifelse(s10 %in% neozolklavas, v10, 0)+ifelse(s11 %in% neozolklavas,v11,0)+ ifelse(s12 %in% neozolklavas, v12,0)+ifelse(s13 %in% neozolklavas,v13,0)+ ifelse(s14 %in% neozolklavas, v14,0)) %&gt;% mutate(BezOzolKlavuKraja2=BezOzolKlavuKraja/10000*10*10) %&gt;% mutate(BezOzolKlavuKraja3=ifelse(BezOzolKlavuKraja2&gt;3,3,BezOzolKlavuKraja2)) %&gt;% filter(!is.na(BezOzolKlavuKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$BezOzolKlavuKraja2,main=&quot;Original&quot;,xlab=&quot;Temperate deciduous volume\\n without oak and maple&quot;) hist(nogabali$BezOzolKlavuKraja3,main=&quot;Limited&quot;,xlab=&quot;Temperate deciduous volume\\nwithout oak and maple&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeTemperateWithoutOakMaple.tif&quot;, value_field = &quot;BezOzolKlavuKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOakMaple.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif&quot;, layername = &quot;egv_306&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(neozolklavas) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTemperateWithoutOakMaple.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeTemperateWithoutOakMaple-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.307 ForestsQuant_VolumeTotal-sum_cell filename: ForestsQuant_VolumeTotal-sum_cell.tif layername: egv_307 English name: Timber volume within the analysis cell (1 ha) Latvian name: Kopējā krāja analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). This EGV is prepared based on the information of timber volume in the inventoried forest stands - State Forest Service’s State Forest Registry. This attribute has some extreme values. We chose to limit them to the nearest integer showing only minimal accumulation in histogram. Resulting values at polygon geometries are rasterised with the workflow egvtools::polygon2input(), restricting to pixels outside the clearcut mask. No background values are assigned during rasterisation. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv() by calculating sum of pixel values. After the aggregation, cells with no forest information are filled with value 0. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsQuant_VolumeTotal-sum_cell.tif egv_307 ---- nogabali=mvr %&gt;% mutate(KopejaKraja=v10+v11+v12+v13+v14) %&gt;% mutate(KopejaKraja2=KopejaKraja/10000*10*10) %&gt;% mutate(KopejaKraja3=ifelse(KopejaKraja2&gt;8,8,KopejaKraja2)) %&gt;% filter(!is.na(KopejaKraja2)) par(mfrow=c(1,2)) options(scipen=999) hist(nogabali$KopejaKraja2,main=&quot;Original&quot;,xlab=&quot;Timber volume&quot;) hist(nogabali$KopejaKraja3,main=&quot;Limited&quot;,xlab=&quot;Timber volume&quot;) par(mfrow=c(1,1)) options(scipen=0) p2i_rez=polygon2input(vector_data=nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsQuant_VolumeTotal.tif&quot;, value_field = &quot;KopejaKraja3&quot;, fun=&quot;max&quot;, prepare=FALSE, restrict_to = clearcut_mask, restrict_values = 0, plot_result=TRUE, overwrite=TRUE) p2i_rez i2e_rez=input2egv(input=&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTotal.tif&quot;, egv_template = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;sum&quot;, missing_job = &quot;CoverOutput&quot;, output_bg = &quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsQuant_VolumeTotal-sum_cell.tif&quot;, layername = &quot;egv_307&quot;, plot_final=TRUE) i2e_rez rm(p2i_rez) rm(nogabali) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsQuant_VolumeTotal.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsQuant_VolumeTotal-sum_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.308 ForestsSoil_EutrophicDrained_cell filename: ForestsSoil_EutrophicDrained_cell.tif layername: egv_308 English name: Fractional cover of Drained Eutrophic Forests within the analysis cell (1 ha) Latvian name: Susinātu eitrofu mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “19”, “21”, “24” or “25” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_EutrophicDrained_cell.tif egv_308 ---- EutrophicDrained=mvr %&gt;% filter(mt %in% c(&quot;19&quot;,&quot;21&quot;,&quot;24&quot;,&quot;25&quot;)) p2i_rez=egvtools::polygon2input(vector_data = EutrophicDrained, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_EutrophicDrained_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_EutrophicDrained_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_EutrophicDrained_cell.tif&quot;, layername = &quot;egv_308&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(EutrophicDrained) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_EutrophicDrained_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicDrained_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.309 ForestsSoil_EutrophicDrained_r500 filename: ForestsSoil_EutrophicDrained_r500.tif layername: egv_309 English name: Fractional cover of Drained Eutrophic Forests within the 0.5 km landscape Latvian name: Susinātu eitrofu mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicDrained_r500.tif egv_309 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r500.tif&quot;) names(slanis)=&quot;egv_309&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicDrained_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.310 ForestsSoil_EutrophicDrained_r1250 filename: ForestsSoil_EutrophicDrained_r1250.tif layername: egv_310 English name: Fractional cover of Drained Eutrophic Forests within the 1.25 km landscape Latvian name: Susinātu eitrofu mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicDrained_r1250.tif egv_310 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r1250.tif&quot;) names(slanis)=&quot;egv_310&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicDrained_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.311 ForestsSoil_EutrophicDrained_r3000 filename: ForestsSoil_EutrophicDrained_r3000.tif layername: egv_311 English name: Fractional cover of Drained Eutrophic Forests within the 3 km landscape Latvian name: Susinātu eitrofu mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicDrained_r3000.tif egv_311 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r3000.tif&quot;) names(slanis)=&quot;egv_311&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicDrained_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.312 ForestsSoil_EutrophicDrained_r10000 filename: ForestsSoil_EutrophicDrained_r10000.tif layername: egv_312 English name: Fractional cover of Drained Eutrophic Forests within the 10 km landscape Latvian name: Susinātu eitrofu mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicDrained_r10000.tif egv_312 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r10000.tif&quot;) names(slanis)=&quot;egv_312&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicDrained_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicDrained_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.313 ForestsSoil_EutrophicMineral_cell filename: ForestsSoil_EutrophicMineral_cell.tif layername: egv_313 English name: Fractional cover of Eutrophic Forests on undrained Mineral Soils within the analysis cell (1 ha) Latvian name: Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “5” “6” “10” or “11” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_EutrophicMineral_cell.tif egv_313 ---- EutrophicMineral=mvr %&gt;% filter(mt %in% c(&quot;5&quot;,&quot;6&quot;,&quot;10&quot;,&quot;11&quot;)) p2i_rez=egvtools::polygon2input(vector_data = EutrophicMineral, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_EutrophicMineral_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_EutrophicMineral_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_EutrophicMineral_cell.tif&quot;, layername = &quot;egv_313&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(EutrophicMineral) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_EutrophicMineral_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicMineral_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.314 ForestsSoil_EutrophicMineral_r500 filename: ForestsSoil_EutrophicMineral_r500.tif layername: egv_314 English name: Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 0.5 km landscape Latvian name: Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicMineral_r500.tif egv_314 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r500.tif&quot;) names(slanis)=&quot;egv_314&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicMineral_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.315 ForestsSoil_EutrophicMineral_r1250 filename: ForestsSoil_EutrophicMineral_r1250.tif layername: egv_315 English name: Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 1.25 km landscape Latvian name: Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicMineral_r1250.tif egv_315 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r1250.tif&quot;) names(slanis)=&quot;egv_315&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicMineral_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.316 ForestsSoil_EutrophicMineral_r3000 filename: ForestsSoil_EutrophicMineral_r3000.tif layername: egv_316 English name: Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 3 km landscape Latvian name: Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicMineral_r3000.tif egv_316 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r3000.tif&quot;) names(slanis)=&quot;egv_316&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicMineral_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.317 ForestsSoil_EutrophicMineral_r10000 filename: ForestsSoil_EutrophicMineral_r10000.tif layername: egv_317 English name: Fractional cover of Eutrophic Forests on undrained Mineral Soils within the 10 km landscape Latvian name: Eitrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicMineral_r10000.tif egv_317 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r10000.tif&quot;) names(slanis)=&quot;egv_317&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicMineral_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicMineral_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.318 ForestsSoil_EutrophicOrganic_cell filename: ForestsSoil_EutrophicOrganic_cell.tif layername: egv_318 English name: Fractional cover of Eutrophic Forests on undrained Organic Soils within the analysis cell (1 ha) Latvian name: Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “15” or “16” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_EutrophicOrganic_cell.tif egv_318 ---- EutrophicOrganic=mvr %&gt;% filter(mt %in% c(&quot;15&quot;,&quot;16&quot;)) p2i_rez=egvtools::polygon2input(vector_data = EutrophicOrganic, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_EutrophicOrganic_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_EutrophicOrganic_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_EutrophicOrganic_cell.tif&quot;, layername = &quot;egv_318&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(EutrophicOrganic) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_EutrophicOrganic_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicOrganic_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.319 ForestsSoil_EutrophicOrganic_r500 filename: ForestsSoil_EutrophicOrganic_r500.tif layername: egv_319 English name: Fractional cover of Eutrophic Forests on undrained Organic Soils within the 0.5 km landscape Latvian name: Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicOrganic_r500.tif egv_319 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r500.tif&quot;) names(slanis)=&quot;egv_319&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicOrganic_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.320 ForestsSoil_EutrophicOrganic_r1250 filename: ForestsSoil_EutrophicOrganic_r1250.tif layername: egv_320 English name: Fractional cover of Eutrophic Forests on undrained Organic Soils within the 1.25 km landscape Latvian name: Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicOrganic_r1250.tif egv_320 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r1250.tif&quot;) names(slanis)=&quot;egv_320&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicOrganic_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.321 ForestsSoil_EutrophicOrganic_r3000 filename: ForestsSoil_EutrophicOrganic_r3000.tif layername: egv_321 English name: Fractional cover of Eutrophic Forests on undrained Organic Soils within the 3 km landscape Latvian name: Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicOrganic_r3000.tif egv_321 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r3000.tif&quot;) names(slanis)=&quot;egv_321&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicOrganic_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.322 ForestsSoil_EutrophicOrganic_r10000 filename: ForestsSoil_EutrophicOrganic_r10000.tif layername: egv_322 English name: Fractional cover of Eutrophic Forests on undrained Organic Soils within the 10 km landscape Latvian name: Eitrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_EutrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_EutrophicOrganic_r10000.tif egv_322 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r10000.tif&quot;) names(slanis)=&quot;egv_322&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_EutrophicOrganic_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_EutrophicOrganic_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.323 ForestsSoil_MesotrophicMineral_cell filename: ForestsSoil_MesotrophicMineral_cell.tif layername: egv_323 English name: Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the analysis cell (1 ha) Latvian name: Mezotrofu mežu minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “4” or “9” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_MesotrophicMineral_cell.tif egv_323 ---- MesotrophicMineral=mvr %&gt;% filter(mt %in% c(&quot;4&quot;,&quot;9&quot;)) p2i_rez=egvtools::polygon2input(vector_data = MesotrophicMineral, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_MesotrophicMineral_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_MesotrophicMineral_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_MesotrophicMineral_cell.tif&quot;, layername = &quot;egv_323&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(MesotrophicMineral) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_MesotrophicMineral_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_MesotrophicMineral_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.324 ForestsSoil_MesotrophicMineral_r500 filename: ForestsSoil_MesotrophicMineral_r500.tif layername: egv_324 English name: Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 0.5 km landscape Latvian name: Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_MesotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_MesotrophicMineral_r500.tif egv_324 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r500.tif&quot;) names(slanis)=&quot;egv_324&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_MesotrophicMineral_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.325 ForestsSoil_MesotrophicMineral_r1250 filename: ForestsSoil_MesotrophicMineral_r1250.tif layername: egv_325 English name: Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 1.25 km landscape Latvian name: Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_MesotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_MesotrophicMineral_r1250.tif egv_325 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r1250.tif&quot;) names(slanis)=&quot;egv_325&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_MesotrophicMineral_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.326 ForestsSoil_MesotrophicMineral_r3000 filename: ForestsSoil_MesotrophicMineral_r3000.tif layername: egv_326 English name: Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 3 km landscape Latvian name: Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_MesotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_MesotrophicMineral_r3000.tif egv_326 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r3000.tif&quot;) names(slanis)=&quot;egv_326&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_MesotrophicMineral_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.327 ForestsSoil_MesotrophicMineral_r10000 filename: ForestsSoil_MesotrophicMineral_r10000.tif layername: egv_327 English name: Fractional cover of Mesotrophic Forests on undrained Mineral Soils within the 10 km landscape Latvian name: Mezotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_MesotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_MesotrophicMineral_r10000.tif egv_327 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r10000.tif&quot;) names(slanis)=&quot;egv_327&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_MesotrophicMineral_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_MesotrophicMineral_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.328 ForestsSoil_OligotrophicDrained_cell filename: ForestsSoil_OligotrophicDrained_cell.tif layername: egv_328 English name: Fractional cover of Drained Oligotrophic Forests within the analysis cell (1 ha) Latvian name: Susinātu oligotrofu mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “17”, “18”, “22” or “23” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_OligotrophicDrained_cell.tif egv_328 ---- OligotrophicDrained=mvr %&gt;% filter(mt %in% c(&quot;17&quot;,&quot;18&quot;,&quot;22&quot;,&quot;23&quot;)) p2i_rez=egvtools::polygon2input(vector_data = OligotrophicDrained, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_OligotrophicDrained_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_OligotrophicDrained_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_OligotrophicDrained_cell.tif&quot;, layername = &quot;egv_328&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(OligotrophicDrained) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_OligotrophicDrained_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicDrained_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.329 ForestsSoil_OligotrophicDrained_r500 filename: ForestsSoil_OligotrophicDrained_r500.tif layername: egv_329 English name: Fractional cover of Drained Oligotrophic Forests within the 0.5 km landscape Latvian name: Susinātu oligotrofu mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicDrained_r500.tif egv_329 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r500.tif&quot;) names(slanis)=&quot;egv_329&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicDrained_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.330 ForestsSoil_OligotrophicDrained_r1250 filename: ForestsSoil_OligotrophicDrained_r1250.tif layername: egv_330 English name: Fractional cover of Drained Oligotrophic Forests within the 1.25 km landscape Latvian name: Susinātu oligotrofu mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicDrained_r1250.tif egv_330 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r1250.tif&quot;) names(slanis)=&quot;egv_330&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicDrained_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.331 ForestsSoil_OligotrophicDrained_r3000 filename: ForestsSoil_OligotrophicDrained_r3000.tif layername: egv_331 English name: Fractional cover of Drained Oligotrophic Forests within the 3 km landscape Latvian name: Susinātu oligotrofu mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicDrained_r3000.tif egv_331 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r3000.tif&quot;) names(slanis)=&quot;egv_331&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicDrained_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.332 ForestsSoil_OligotrophicDrained_r10000 filename: ForestsSoil_OligotrophicDrained_r10000.tif layername: egv_332 English name: Fractional cover of Drained Oligotrophic Forests within the 10 km landscape Latvian name: Susinātu oligotrofu mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicDrained&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicDrained_r10000.tif egv_332 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r10000.tif&quot;) names(slanis)=&quot;egv_332&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicDrained_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicDrained_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.333 ForestsSoil_OligotrophicMineral_cell filename: ForestsSoil_OligotrophicMineral_cell.tif layername: egv_333 English name: Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the analysis cell (1 ha) Latvian name: Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “1”, “2”, “3”, “7” or “8” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_OligotrophicMineral_cell.tif egv_333 ---- OligotrophicMineral=mvr %&gt;% filter(mt %in% c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;7&quot;,&quot;8&quot;)) p2i_rez=egvtools::polygon2input(vector_data = OligotrophicMineral, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_OligotrophicMineral_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_OligotrophicMineral_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_OligotrophicMineral_cell.tif&quot;, layername = &quot;egv_333&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(OligotrophicMineral) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_OligotrophicMineral_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.334 ForestsSoil_OligotrophicMineral_r500 filename: ForestsSoil_OligotrophicMineral_r500.tif layername: egv_334 English name: Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 0.5 km landscape Latvian name: Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicMineral_r500.tif egv_334 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r500.tif&quot;) names(slanis)=&quot;egv_334&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.335 ForestsSoil_OligotrophicMineral_r1250 filename: ForestsSoil_OligotrophicMineral_r1250.tif layername: egv_335 English name: Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 1.25 km landscape Latvian name: Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicMineral_r1250.tif egv_335 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r1250.tif&quot;) names(slanis)=&quot;egv_335&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.336 ForestsSoil_OligotrophicMineral_r3000 filename: ForestsSoil_OligotrophicMineral_r3000.tif layername: egv_336 English name: Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 3 km landscape Latvian name: Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicMineral_r3000.tif egv_336 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r3000.tif&quot;) names(slanis)=&quot;egv_336&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.337 ForestsSoil_OligotrophicMineral_r10000 filename: ForestsSoil_OligotrophicMineral_r10000.tif layername: egv_337 English name: Fractional cover of Oligotrophic Forests on undrained Mineral Soils within the 10 km landscape Latvian name: Oligotrofu mežu nesusinātās minerālaugsnēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicMineral&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicMineral_r10000.tif egv_337 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r10000.tif&quot;) names(slanis)=&quot;egv_337&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicMineral_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.338 ForestsSoil_OligotrophicOrganic_cell filename: ForestsSoil_OligotrophicOrganic_cell.tif layername: egv_338 English name: Fractional cover of Oligotrophic Forests on undrained Organic Soils within the analysis cell (1 ha) Latvian name: Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars analīzes šūnā (1 ha) Procedure: To prepare this EGV, forest stands with forest type equal to “12” or “14” are selected from the State Forest Service’s State Forest Registry and rasterised. Rasterisation is performed using the workflow egvtools::polygon2input() with background covering (value 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # ForestsSoil_OligotrophicOrganic_cell.tif egv_338 ---- OligotrophicOrganic=mvr %&gt;% filter(mt %in% c(&quot;12&quot;,&quot;14&quot;)) p2i_rez=egvtools::polygon2input(vector_data = OligotrophicOrganic, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsSoil_OligotrophicOrganic_input.tif&quot;, value_field = &quot;yes&quot;, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsSoil_OligotrophicOrganic_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsSoil_OligotrophicOrganic_cell.tif&quot;, layername = &quot;egv_338&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(OligotrophicOrganic) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsSoil_OligotrophicOrganic_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicMineral_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.339 ForestsSoil_OligotrophicOrganic_r500 filename: ForestsSoil_OligotrophicOrganic_r500.tif layername: egv_339 English name: Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 0.5 km landscape Latvian name: Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicOrganic_r500.tif egv_339 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r500.tif&quot;) names(slanis)=&quot;egv_339&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicOrganic_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.340 ForestsSoil_OligotrophicOrganic_r1250 filename: ForestsSoil_OligotrophicOrganic_r1250.tif layername: egv_340 English name: Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 1.25 km landscape Latvian name: Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicOrganic_r1250.tif egv_340 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r1250.tif&quot;) names(slanis)=&quot;egv_340&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicOrganic_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.341 ForestsSoil_OligotrophicOrganic_r3000 filename: ForestsSoil_OligotrophicOrganic_r3000.tif layername: egv_341 English name: Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 3 km landscape Latvian name: Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicOrganic_r3000.tif egv_341 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r3000.tif&quot;) names(slanis)=&quot;egv_341&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicOrganic_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.342 ForestsSoil_OligotrophicOrganic_r10000 filename: ForestsSoil_OligotrophicOrganic_r10000.tif layername: egv_342 English name: Fractional cover of Oligotrophic Forests on undrained Organic Soils within the 10 km landscape Latvian name: Oligotrofu mežu nesusinātās organiskajās augsnēs platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_cell.tif&quot;), layer_prefixes = c(&quot;ForestsSoil_OligotrophicOrganic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsSoil_OligotrophicOrganic_r10000.tif egv_342 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r10000.tif&quot;) names(slanis)=&quot;egv_342&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsSoil_OligotrophicOrganic_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsSoil_OligotrophicOrganic_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.343 ForestsTreesAge_BorealDeciduousOld_cell filename: ForestsTreesAge_BorealDeciduousOld_cell.tif layername: egv_343 English name: Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the analysis cell (1 ha) Latvian name: Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then Boreal deciduous stands exceeding the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_BorealDeciduousOld_cell.tif egv_343 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;saurlapju&quot;&amp;(vgr==&quot;4&quot;|vgr==&quot;5&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_BorealDeciduousOld_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_BorealDeciduousOld_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_BorealDeciduousOld_cell.tif&quot;, layername = &quot;egv_343&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_BorealDeciduousOld_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousOld_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.344 ForestsTreesAge_BorealDeciduousOld_r500 filename: ForestsTreesAge_BorealDeciduousOld_r500.tif layername: egv_344 English name: Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 0.5 km landscape Latvian name: Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousOld_r500.tif egv_344 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r500.tif&quot;) names(slanis)=&quot;egv_344&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousOld_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.345 ForestsTreesAge_BorealDeciduousOld_r1250 filename: ForestsTreesAge_BorealDeciduousOld_r1250.tif layername: egv_345 English name: Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 1.25 km landscape Latvian name: Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousOld_r1250.tif egv_345 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r1250.tif&quot;) names(slanis)=&quot;egv_345&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousOld_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.346 ForestsTreesAge_BorealDeciduousOld_r3000 filename: ForestsTreesAge_BorealDeciduousOld_r3000.tif layername: egv_346 English name: Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 3 km landscape Latvian name: Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousOld_r3000.tif egv_346 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r3000.tif&quot;) names(slanis)=&quot;egv_346&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousOld_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.347 ForestsTreesAge_BorealDeciduousOld_r10000 filename: ForestsTreesAge_BorealDeciduousOld_r10000.tif layername: egv_347 English name: Fractional cover of Old (over rotation age) Boreal Deciduous Forests within the 10 km landscape Latvian name: Vecu (kopš cirtmeta) šaurlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousOld_r10000.tif egv_347 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r10000.tif&quot;) names(slanis)=&quot;egv_347&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousOld_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousOld_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.348 ForestsTreesAge_BorealDeciduousYoung_cell filename: ForestsTreesAge_BorealDeciduousYoung_cell.tif layername: egv_348 English name: Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the analysis cell (1 ha) Latvian name: Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then Boreal deciduous stands younger than the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_BorealDeciduousYoung_cell.tif egv_348 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;saurlapju&quot;&amp;(vgr==&quot;1&quot;|vgr==&quot;2&quot;|vgr==&quot;3&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_BorealDeciduousYoung_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_BorealDeciduousYoung_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot;, layername = &quot;egv_348&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_BorealDeciduousYoung_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.349 ForestsTreesAge_BorealDeciduousYoung_r500 filename: ForestsTreesAge_BorealDeciduousYoung_r500.tif layername: egv_349 English name: Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 0.5 km landscape Latvian name: Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousYoung_r500.tif egv_349 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r500.tif&quot;) names(slanis)=&quot;egv_349&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousYoung_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.350 ForestsTreesAge_BorealDeciduousYoung_r1250 filename: ForestsTreesAge_BorealDeciduousYoung_r1250.tif layername: egv_350 English name: Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 1.25 km landscape Latvian name: Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousYoung_r1250.tif egv_350 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r1250.tif&quot;) names(slanis)=&quot;egv_350&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousYoung_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.351 ForestsTreesAge_BorealDeciduousYoung_r3000 filename: ForestsTreesAge_BorealDeciduousYoung_r3000.tif layername: egv_351 English name: Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 3 km landscape Latvian name: Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousYoung_r3000.tif egv_351 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r3000.tif&quot;) names(slanis)=&quot;egv_351&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousYoung_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.352 ForestsTreesAge_BorealDeciduousYoung_r10000 filename: ForestsTreesAge_BorealDeciduousYoung_r10000.tif layername: egv_352 English name: Fractional cover of Young (pre-rotation age) Boreal Deciduous Forests within the 10 km landscape Latvian name: Jaunu (pirms cirtmeta) šaurlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_BorealDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_BorealDeciduousYoung_r10000.tif egv_352 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r10000.tif&quot;) names(slanis)=&quot;egv_352&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_BorealDeciduousYoung_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_BorealDeciduousYoung_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.353 ForestsTreesAge_ConiferousOld_cell filename: ForestsTreesAge_ConiferousOld_cell.tif layername: egv_353 English name: Fractional cover of Old (over rotation age) Coniferous Forests within the analysis cell (1 ha) Latvian name: Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then coniferous stands exceeding the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_ConiferousOld_cell.tif egv_353 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;skujkoku&quot;&amp;(vgr==&quot;4&quot;|vgr==&quot;5&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_ConiferousOld_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_ConiferousOld_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_ConiferousOld_cell.tif&quot;, layername = &quot;egv_353&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_ConiferousOld_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousOld_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.354 ForestsTreesAge_ConiferousOld_r500 filename: ForestsTreesAge_ConiferousOld_r500.tif layername: egv_354 English name: Fractional cover of Old (over rotation age) Coniferous Forests within the 0.5 km landscape Latvian name: Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousOld_r500.tif egv_354 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r500.tif&quot;) names(slanis)=&quot;egv_354&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousOld_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.355 ForestsTreesAge_ConiferousOld_r1250 filename: ForestsTreesAge_ConiferousOld_r1250.tif layername: egv_355 English name: Fractional cover of Old (over rotation age) Coniferous Forests within the 1.25 km landscape Latvian name: Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousOld_r1250.tif egv_355 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r1250.tif&quot;) names(slanis)=&quot;egv_355&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousOld_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.356 ForestsTreesAge_ConiferousOld_r3000 filename: ForestsTreesAge_ConiferousOld_r3000.tif layername: egv_356 English name: Fractional cover of Old (over rotation age) Coniferous Forests within the 3 km landscape Latvian name: Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousOld_r3000.tif egv_356 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r3000.tif&quot;) names(slanis)=&quot;egv_356&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousOld_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.357 ForestsTreesAge_ConiferousOld_r10000 filename: ForestsTreesAge_ConiferousOld_r10000.tif layername: egv_357 English name: Fractional cover of Old (over rotation age) Coniferous Forests within the 10 km landscape Latvian name: Vecu (kopš cirtmeta) skujkoku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousOld_r10000.tif egv_357 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r10000.tif&quot;) names(slanis)=&quot;egv_357&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousOld_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousOld_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.358 ForestsTreesAge_ConiferousYoung_cell filename: ForestsTreesAge_ConiferousYoung_cell.tif layername: egv_358 English name: Fractional cover of Young (pre-rotation age) Coniferous Forests within the analysis cell (1 ha) Latvian name: Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then coniferous stands younger than the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_ConiferousYoung_cell.tif egv_358 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;skujkoku&quot;&amp;(vgr==&quot;1&quot;|vgr==&quot;2&quot;|vgr==&quot;3&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_ConiferousYoung_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_ConiferousYoung_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_ConiferousYoung_cell.tif&quot;, layername = &quot;egv_358&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_ConiferousYoung_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousYoung_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.359 ForestsTreesAge_ConiferousYoung_r500 filename: ForestsTreesAge_ConiferousYoung_r500.tif layername: egv_359 English name: Fractional cover of Young (pre-rotation age) Coniferous Forests within the 0.5 km landscape Latvian name: Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousYoung_r500.tif egv_359 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r500.tif&quot;) names(slanis)=&quot;egv_359&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousYoung_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.360 ForestsTreesAge_ConiferousYoung_r1250 filename: ForestsTreesAge_ConiferousYoung_r1250.tif layername: egv_360 English name: Fractional cover of Young (pre-rotation age) Coniferous Forests within the 1.25 km landscape Latvian name: Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousYoung_r1250.tif egv_360 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r1250.tif&quot;) names(slanis)=&quot;egv_360&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousYoung_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.361 ForestsTreesAge_ConiferousYoung_r3000 filename: ForestsTreesAge_ConiferousYoung_r3000.tif layername: egv_361 English name: Fractional cover of Young (pre-rotation age) Coniferous Forests within the 3 km landscape Latvian name: Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousYoung_r3000.tif egv_361 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r3000.tif&quot;) names(slanis)=&quot;egv_361&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousYoung_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.362 ForestsTreesAge_ConiferousYoung_r10000 filename: ForestsTreesAge_ConiferousYoung_r10000.tif layername: egv_362 English name: Fractional cover of Young (pre-rotation age) Coniferous Forests within the 10 km landscape Latvian name: Jaunu (pirms cirtmeta) skujkoku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_ConiferousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_ConiferousYoung_r10000.tif egv_362 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r10000.tif&quot;) names(slanis)=&quot;egv_362&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_ConiferousYoung_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_ConiferousYoung_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.363 ForestsTreesAge_MixedOld_cell filename: ForestsTreesAge_MixedOld_cell.tif layername: egv_363 English name: Fractional cover of Old (over rotation age) Mixed Forests within the analysis cell (1 ha) Latvian name: Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then mixed stands exceeding the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_MixedOld_cell.tif egv_363 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;jauktu koku&quot;&amp;(vgr==&quot;4&quot;|vgr==&quot;5&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_MixedOld_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_MixedOld_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_MixedOld_cell.tif&quot;, layername = &quot;egv_363&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_MixedOld_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedOld_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.364 ForestsTreesAge_MixedOld_r500 filename: ForestsTreesAge_MixedOld_r500.tif layername: egv_364 English name: Fractional cover of Old (over rotation age) Mixed Forests within the 0.5 km landscape Latvian name: Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedOld_r500.tif egv_364 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r500.tif&quot;) names(slanis)=&quot;egv_364&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedOld_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.365 ForestsTreesAge_MixedOld_r1250 filename: ForestsTreesAge_MixedOld_r1250.tif layername: egv_365 English name: Fractional cover of Old (over rotation age) Mixed Forests within the 1.25 km landscape Latvian name: Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedOld_r1250.tif egv_365 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r1250.tif&quot;) names(slanis)=&quot;egv_365&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedOld_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.366 ForestsTreesAge_MixedOld_r3000 filename: ForestsTreesAge_MixedOld_r3000.tif layername: egv_366 English name: Fractional cover of Old (over rotation age) Mixed Forests within the 3 km landscape Latvian name: Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedOld_r3000.tif egv_366 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r3000.tif&quot;) names(slanis)=&quot;egv_366&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedOld_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.367 ForestsTreesAge_MixedOld_r10000 filename: ForestsTreesAge_MixedOld_r10000.tif layername: egv_367 English name: Fractional cover of Old (over rotation age) Mixed Forests within the 10 km landscape Latvian name: Vecu (kopš cirtmeta) jauktu koku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedOld_r10000.tif egv_367 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r10000.tif&quot;) names(slanis)=&quot;egv_367&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedOld_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedOld_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.368 ForestsTreesAge_MixedYoung_cell filename: ForestsTreesAge_MixedYoung_cell.tif layername: egv_368 English name: Fractional cover of Young (pre-rotation age) Mixed Forests within the analysis cell (1 ha) Latvian name: Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then mixed stands younger than the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_MixedYoung_cell.tif egv_368 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;jauktu koku&quot;&amp;(vgr==&quot;1&quot;|vgr==&quot;2&quot;|vgr==&quot;3&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_MixedYoung_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_MixedYoung_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_MixedYoung_cell.tif&quot;, layername = &quot;egv_368&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_MixedYoung_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedYoung_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.369 ForestsTreesAge_MixedYoung_r500 filename: ForestsTreesAge_MixedYoung_r500.tif layername: egv_369 English name: Fractional cover of Young (pre-rotation age) Mixed Forests within the 0.5 km landscape Latvian name: Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedYoung_r500.tif egv_369 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r500.tif&quot;) names(slanis)=&quot;egv_369&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedYoung_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.370 ForestsTreesAge_MixedYoung_r1250 filename: ForestsTreesAge_MixedYoung_r1250.tif layername: egv_370 English name: Fractional cover of Young (pre-rotation age) Mixed Forests within the 1.25 km landscape Latvian name: Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedYoung_r1250.tif egv_370 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r1250.tif&quot;) names(slanis)=&quot;egv_370&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedYoung_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.371 ForestsTreesAge_MixedYoung_r3000 filename: ForestsTreesAge_MixedYoung_r3000.tif layername: egv_371 English name: Fractional cover of Young (pre-rotation age) Mixed Forests within the 3 km landscape Latvian name: Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedYoung_r3000.tif egv_371 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r3000.tif&quot;) names(slanis)=&quot;egv_371&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedYoung_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.372 ForestsTreesAge_MixedYoung_r10000 filename: ForestsTreesAge_MixedYoung_r10000.tif layername: egv_372 English name: Fractional cover of Young (pre-rotation age) Mixed Forests within the 10 km landscape Latvian name: Jaunu (pirms cirtmeta) jauktu koku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_MixedYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_MixedYoung_r10000.tif egv_372 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r10000.tif&quot;) names(slanis)=&quot;egv_372&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_MixedYoung_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_MixedYoung_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.373 ForestsTreesAge_TemperateDeciduousOld_cell filename: ForestsTreesAge_TemperateDeciduousOld_cell.tif layername: egv_373 English name: Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the analysis cell (1 ha) Latvian name: Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then temperate deciduous stands exceeding the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_TemperateDeciduousOld_cell.tif egv_373 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;platlapju&quot;&amp;(vgr==&quot;4&quot;|vgr==&quot;5&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_TemperateDeciduousOld_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_TemperateDeciduousOld_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot;, layername = &quot;egv_373&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_TemperateDeciduousOld_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.374 ForestsTreesAge_TemperateDeciduousOld_r500 filename: ForestsTreesAge_TemperateDeciduousOld_r500.tif layername: egv_374 English name: Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 0.5 km landscape Latvian name: Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousOld_r500.tif egv_374 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r500.tif&quot;) names(slanis)=&quot;egv_374&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousOld_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.375 ForestsTreesAge_TemperateDeciduousOld_r1250 filename: ForestsTreesAge_TemperateDeciduousOld_r1250.tif layername: egv_375 English name: Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 1.25 km landscape Latvian name: Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousOld_r1250.tif egv_375 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r1250.tif&quot;) names(slanis)=&quot;egv_375&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousOld_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.376 ForestsTreesAge_TemperateDeciduousOld_r3000 filename: ForestsTreesAge_TemperateDeciduousOld_r3000.tif layername: egv_376 English name: Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 3 km landscape Latvian name: Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousOld_r3000.tif egv_376 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r3000.tif&quot;) names(slanis)=&quot;egv_376&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousOld_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.377 ForestsTreesAge_TemperateDeciduousOld_r10000 filename: ForestsTreesAge_TemperateDeciduousOld_r10000.tif layername: egv_377 English name: Fractional cover of Old (over rotation age) Temperate Deciduous Forests within the 10 km landscape Latvian name: Vecu (kopš cirtmeta) platlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousOld&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousOld_r10000.tif egv_377 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r10000.tif&quot;) names(slanis)=&quot;egv_377&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousOld_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousOld_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.378 ForestsTreesAge_TemperateDeciduousYoung_cell filename: ForestsTreesAge_TemperateDeciduousYoung_cell.tif layername: egv_378 English name: Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the analysis cell (1 ha) Latvian name: Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then temperate deciduous stands younger than the legal rotation age are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTreesAge_TemperateDeciduousYoung_cell.tif egv_378 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;platlapju&quot;&amp;(vgr==&quot;1&quot;|vgr==&quot;2&quot;|vgr==&quot;3&quot;)) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTreesAge_TemperateDeciduousYoung_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTreesAge_TemperateDeciduousYoung_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot;, layername = &quot;egv_378&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTreesAge_TemperateDeciduousYoung_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.379 ForestsTreesAge_TemperateDeciduousYoung_r500 filename: ForestsTreesAge_TemperateDeciduousYoung_r500.tif layername: egv_379 English name: Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 0.5 km landscape Latvian name: Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousYoung_r500.tif egv_379 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r500.tif&quot;) names(slanis)=&quot;egv_379&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousYoung_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.380 ForestsTreesAge_TemperateDeciduousYoung_r1250 filename: ForestsTreesAge_TemperateDeciduousYoung_r1250.tif layername: egv_380 English name: Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 1.25 km landscape Latvian name: Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousYoung_r1250.tif egv_380 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r1250.tif&quot;) names(slanis)=&quot;egv_380&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousYoung_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.381 ForestsTreesAge_TemperateDeciduousYoung_r3000 filename: ForestsTreesAge_TemperateDeciduousYoung_r3000.tif layername: egv_381 English name: Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 3 km landscape Latvian name: Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousYoung_r3000.tif egv_381 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r3000.tif&quot;) names(slanis)=&quot;egv_381&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousYoung_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.382 ForestsTreesAge_TemperateDeciduousYoung_r10000 filename: ForestsTreesAge_TemperateDeciduousYoung_r10000.tif layername: egv_382 English name: Fractional cover of Young (pre-rotation age) Temperate Deciduous Forests within the 10 km landscape Latvian name: Jaunu (pirms cirtmeta) platlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTreesAge_TemperateDeciduousYoung&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTreesAge_TemperateDeciduousYoung_r10000.tif egv_382 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r10000.tif&quot;) names(slanis)=&quot;egv_382&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTreesAge_TemperateDeciduousYoung_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTreesAge_TemperateDeciduousYoung_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.383 ForestsTrees_BorealDeciduous_cell filename: ForestsTrees_BorealDeciduous_cell.tif layername: egv_383 English name: Fractional cover of Boreal Deciduous Forests within the analysis cell (1 ha) Latvian name: Šaurlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then Boreal deciduous stands are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTrees_BorealDeciduous_cell.tif egv_383 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;saurlapju&quot;) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTrees_BorealDeciduous_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTrees_BorealDeciduous_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTrees_BorealDeciduous_cell.tif&quot;, layername = &quot;egv_383&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTrees_BorealDeciduous_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_BorealDeciduous_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.384 ForestsTrees_BorealDeciduous_r500 filename: ForestsTrees_BorealDeciduous_r500.tif layername: egv_384 English name: Fractional cover of Boreal Deciduous Forests within the 0.5 km landscape Latvian name: Šaurlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_BorealDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_BorealDeciduous_r500.tif egv_384 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r500.tif&quot;) names(slanis)=&quot;egv_384&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_BorealDeciduous_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.385 ForestsTrees_BorealDeciduous_r1250 filename: ForestsTrees_BorealDeciduous_r1250.tif layername: egv_385 English name: Fractional cover of Boreal Deciduous Forests within the 1.25 km landscape Latvian name: Šaurlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_BorealDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_BorealDeciduous_r1250.tif egv_385 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r1250.tif&quot;) names(slanis)=&quot;egv_385&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_BorealDeciduous_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.386 ForestsTrees_BorealDeciduous_r3000 filename: ForestsTrees_BorealDeciduous_r3000.tif layername: egv_386 English name: Fractional cover of Boreal Deciduous Forests within the 3 km landscape Latvian name: Šaurlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_BorealDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_BorealDeciduous_r3000.tif egv_386 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r3000.tif&quot;) names(slanis)=&quot;egv_386&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_BorealDeciduous_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.387 ForestsTrees_BorealDeciduous_r10000 filename: ForestsTrees_BorealDeciduous_r10000.tif layername: egv_387 English name: Fractional cover of Boreal Deciduous Forests within the 10 km landscape Latvian name: Šaurlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_BorealDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_BorealDeciduous_r10000.tif egv_387 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r10000.tif&quot;) names(slanis)=&quot;egv_387&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_BorealDeciduous_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_BorealDeciduous_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.388 ForestsTrees_Coniferous_cell filename: ForestsTrees_Coniferous_cell.tif layername: egv_388 English name: Fractional cover of Coniferous Forests within the analysis cell (1 ha) Latvian name: Skujkoku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then coniferous stands are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTrees_Coniferous_cell.tif egv_388 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;skujkoku&quot;) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTrees_Coniferous_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTrees_Coniferous_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTrees_Coniferous_cell.tif&quot;, layername = &quot;egv_388&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTrees_Coniferous_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Coniferous_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.389 ForestsTrees_Coniferous_r500 filename: ForestsTrees_Coniferous_r500.tif layername: egv_389 English name: Fractional cover of Coniferous Forests within the 0.5 km landscape Latvian name: Skujkoku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Coniferous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Coniferous_r500.tif egv_389 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r500.tif&quot;) names(slanis)=&quot;egv_389&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Coniferous_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.390 ForestsTrees_Coniferous_r1250 filename: ForestsTrees_Coniferous_r1250.tif layername: egv_390 English name: Fractional cover of Coniferous Forests within the 1.25 km landscape Latvian name: Skujkoku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Coniferous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Coniferous_r1250.tif egv_390 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r1250.tif&quot;) names(slanis)=&quot;egv_390&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Coniferous_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.391 ForestsTrees_Coniferous_r3000 filename: ForestsTrees_Coniferous_r3000.tif layername: egv_391 English name: Fractional cover of Coniferous Forests within the 3 km landscape Latvian name: Skujkoku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Coniferous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Coniferous_r3000.tif egv_391 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r3000.tif&quot;) names(slanis)=&quot;egv_391&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Coniferous_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.392 ForestsTrees_Coniferous_r10000 filename: ForestsTrees_Coniferous_r10000.tif layername: egv_392 English name: Fractional cover of Coniferous Forests within the 10 km landscape Latvian name: Skujkoku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Coniferous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Coniferous_r10000.tif egv_392 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r10000.tif&quot;) names(slanis)=&quot;egv_392&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Coniferous_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Coniferous_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.393 ForestsTrees_Mixed_cell filename: ForestsTrees_Mixed_cell.tif layername: egv_393 English name: Fractional cover of Mixed Forests within the analysis cell (1 ha) Latvian name: Jauktu koku mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then mixed stands are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTrees_Mixed_cell.tif egv_393 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;jauktu koku&quot;) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTrees_Mixed_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTrees_Mixed_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTrees_Mixed_cell.tif&quot;, layername = &quot;egv_393&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTrees_Mixed_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Mixed_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.394 ForestsTrees_Mixed_r500 filename: ForestsTrees_Mixed_r500.tif layername: egv_394 English name: Fractional cover of Mixed Forests within the 0.5 km landscape Latvian name: Jauktu koku mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Mixed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Mixed_r500.tif egv_394 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r500.tif&quot;) names(slanis)=&quot;egv_394&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Mixed_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.395 ForestsTrees_Mixed_r1250 filename: ForestsTrees_Mixed_r1250.tif layername: egv_395 English name: Fractional cover of Mixed Forests within the 1.25 km landscape Latvian name: Jauktu koku mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Mixed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Mixed_r1250.tif egv_395 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r1250.tif&quot;) names(slanis)=&quot;egv_395&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Mixed_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.396 ForestsTrees_Mixed_r3000 filename: ForestsTrees_Mixed_r3000.tif layername: egv_396 English name: Fractional cover of Mixed Forests within the 3 km landscape Latvian name: Jauktu koku mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Mixed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Mixed_r3000.tif egv_396 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r3000.tif&quot;) names(slanis)=&quot;egv_396&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Mixed_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.397 ForestsTrees_Mixed_r10000 filename: ForestsTrees_Mixed_r10000.tif layername: egv_397 English name: Fractional cover of Mixed Forests within the 10 km landscape Latvian name: Jauktu koku mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_Mixed&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_Mixed_r10000.tif egv_397 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r10000.tif&quot;) names(slanis)=&quot;egv_397&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_Mixed_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_Mixed_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.398 ForestsTrees_TemperateDeciduous_cell filename: ForestsTrees_TemperateDeciduous_cell.tif layername: egv_398 English name: Fractional cover of Temperate Deciduous Forests within the analysis cell (1 ha) Latvian name: Platlapju mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: Most EGVs describing forests are spatially restricted to areas outside of clearcuts and dead stands. This mask is created using a combination of the State Forest Service’s State Forest Registry land category 12 and 14, and The Global Forest Watch pixels classified as lost tree canopy cover since 2020 (raster layer matching input, presence = 1, absence = 0). To prepare this EGV, stands from the State Forest Service’s State Forest Registry are classified into (in order): coniferous (see Terminology and acronyms for species codes) if timber volume of those species exceeded 75%; Boreal deciduous if timber volume of those species exceeded 75%; temperate deciduous if timber volume of those species exceeded 50%; mixed otherwise; then temperate deciduous stands are selected and geometries are rasterised (presence = 1, NA otherwise). Rasterisation is performed using the workflow egvtools::polygon2input() restricting to pixels outside clearcut mask and covering background with value 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # mvr ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) mvr$yes=1 # clear cut mask ---- izcirtumi=mvr %&gt;% filter(zkat %in% c(&quot;12&quot;,&quot;14&quot;)) %&gt;% dplyr::select(yes) r_izcirtumi_mvr=fasterize(izcirtumi,rastrs10,field=&quot;yes&quot;) t_izcirtumi_mvr=rast(r_izcirtumi_mvr) plot(t_izcirtumi_mvr) tcl=rast(&quot;./Geodata/2024/Trees/GFW/TreeCoverLoss_v1_12.tif&quot;) tcl2=ifel(tcl&lt;20,0,1) tclX=cover(tcl2,nulls10) plot(tclX) clearcut_mask=cover(t_izcirtumi_mvr,tclX, filename=&quot;./RasterGrids_10m/2024/Mask_clearcuts.tif&quot;, overwrite=TRUE) plot(clearcut_mask) rm(izcirtumi) rm(r_izcirtumi_mvr) rm(t_izcirtumi_mvr) rm(tcl) rm(tcl2) rm(tclX) # ForestsTrees_TemperateDeciduous_cell.tif egv_398 ---- skujkoki=c(&quot;1&quot;,&quot;3&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;22&quot;,&quot;23&quot;,&quot;28&quot;) # 8 saurlapji=c(&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;32&quot;,&quot;35&quot;,&quot;68&quot;) # 10 platlapji=c(&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;50&quot;, &quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;69&quot;) # 21 mvr=mvr %&gt;% mutate(kraja_skujkoku=ifelse(s10 %in% skujkoki,v10,0)+ ifelse(s11 %in% skujkoki,v11,0)+ifelse(s12 %in% skujkoki,v12,0)+ ifelse(s13 %in% skujkoki,v13,0)+ifelse(s14 %in% skujkoki,v14,0), kraja_saurlapju=ifelse(s10 %in% saurlapji,v10,0)+ ifelse(s11 %in% saurlapji,v11,0)+ifelse(s12 %in% saurlapji,v12,0)+ ifelse(s13 %in% saurlapji,v13,0)+ifelse(s14 %in% saurlapji,v14,0), kraja_platlapju=ifelse(s10 %in% platlapji,v10,0)+ ifelse(s11 %in% platlapji,v11,0)+ifelse(s12 %in% platlapji,v12,0)+ ifelse(s13 %in% platlapji,v13,0)+ifelse(s14 %in% platlapji,v14,0)) %&gt;% mutate(kopeja_kraja=kraja_skujkoku+kraja_platlapju+kraja_saurlapju) %&gt;% mutate(tips=ifelse(kraja_skujkoku/kopeja_kraja&gt;=0.75,&quot;skujkoku&quot;, ifelse(kraja_saurlapju/kopeja_kraja&gt;=0.75,&quot;saurlapju&quot;, ifelse(kraja_platlapju/kopeja_kraja&gt;0.5,&quot;platlapju&quot;, &quot;jauktu koku&quot;)))) nogabali=mvr %&gt;% filter(zkat==&quot;10&quot;&amp;tips==&quot;platlapju&quot;) p2i_rez=egvtools::polygon2input(vector_data = nogabali, template_path = &quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;, out_path = &quot;./RasterGrids_10m/2024/&quot;, file_name = &quot;ForestsTrees_TemperateDeciduous_input.tif&quot;, value_field = &quot;yes&quot;, restrict_to = clearcut_mask, restrict_values = 0, prepare=FALSE, background_raster = &quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;, plot_result = TRUE) p2i_rez i2e_rez=egvtools::input2egv(input=paste0(&quot;./RasterGrids_10m/2024/&quot;, &quot;ForestsTrees_TemperateDeciduous_input.tif&quot;), egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;ForestsTrees_TemperateDeciduous_cell.tif&quot;, layername = &quot;egv_398&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(nogabali) rm(p2i_rez) rm(i2e_rez) unlink(&quot;./RasterGrids_10m/2024/ForestsTrees_TemperateDeciduous_input.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_TemperateDeciduous_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.399 ForestsTrees_TemperateDeciduous_r500 filename: ForestsTrees_TemperateDeciduous_r500.tif layername: egv_399 English name: Fractional cover of Temperate Deciduous Forests within the 0.5 km landscape Latvian name: Platlapju mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_TemperateDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_TemperateDeciduous_r500.tif egv_399 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r500.tif&quot;) names(slanis)=&quot;egv_399&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_TemperateDeciduous_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.400 ForestsTrees_TemperateDeciduous_r1250 filename: ForestsTrees_TemperateDeciduous_r1250.tif layername: egv_400 English name: Fractional cover of Temperate Deciduous Forests within the 1.25 km landscape Latvian name: Platlapju mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_TemperateDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_TemperateDeciduous_r1250.tif egv_400 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r1250.tif&quot;) names(slanis)=&quot;egv_400&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_TemperateDeciduous_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.401 ForestsTrees_TemperateDeciduous_r3000 filename: ForestsTrees_TemperateDeciduous_r3000.tif layername: egv_401 English name: Fractional cover of Temperate Deciduous Forests within the 3 km landscape Latvian name: Platlapju mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_TemperateDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_TemperateDeciduous_r3000.tif egv_401 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r3000.tif&quot;) names(slanis)=&quot;egv_401&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_TemperateDeciduous_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.402 ForestsTrees_TemperateDeciduous_r10000 filename: ForestsTrees_TemperateDeciduous_r10000.tif layername: egv_402 English name: Fractional cover of Temperate Deciduous Forests within the 10 km landscape Latvian name: Platlapju mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_cell.tif&quot;), layer_prefixes = c(&quot;ForestsTrees_TemperateDeciduous&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # ForestsTrees_TemperateDeciduous_r10000.tif egv_402 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r10000.tif&quot;) names(slanis)=&quot;egv_402&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/ForestsTrees_TemperateDeciduous_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;ForestsTrees_TemperateDeciduous_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.403 General_AllotmentGardens_cell filename: General_AllotmentGardens_cell.tif layername: egv_403 English name: Fractional cover of Allotment gardens within the analysis cell (1 ha) Latvian name: Vasarnīcu kompleksu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the allotment gardens and farmsteads from the Landscape classification are selected (value 410 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_AllotmentGardens_cell.tif egv_403 ---- allotmentgardens=ifel(simple_landscape==410,1,0) i2e_rez=egvtools::input2egv(input=allotmentgardens, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_AllotmentGardens_cell.tif&quot;, layername = &quot;egv_403&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(allotmentgardens) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_AllotmentGardens_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.404 General_AllotmentGardens_r500 filename: General_AllotmentGardens_r500.tif layername: egv_404 English name: Fractional cover of Allotment gardens within the 0.5 km landscape Latvian name: Vasarnīcu kompleksu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_AllotmentGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_AllotmentGardens_r500.tif egv_404 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r500.tif&quot;) names(slanis)=&quot;egv_404&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_AllotmentGardens_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.405 General_AllotmentGardens_r1250 filename: General_AllotmentGardens_r1250.tif layername: egv_405 English name: Fractional cover of Allotment gardens within the 1.25 km landscape Latvian name: Vasarnīcu kompleksu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_AllotmentGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_AllotmentGardens_r1250.tif egv_405 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r1250.tif&quot;) names(slanis)=&quot;egv_405&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_AllotmentGardens_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.406 General_AllotmentGardens_r3000 filename: General_AllotmentGardens_r3000.tif layername: egv_406 English name: Fractional cover of Allotment gardens within the 3 km landscape Latvian name: Vasarnīcu kompleksu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_AllotmentGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_AllotmentGardens_r3000.tif egv_406 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r3000.tif&quot;) names(slanis)=&quot;egv_406&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_AllotmentGardens_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.407 General_AllotmentGardens_r10000 filename: General_AllotmentGardens_r10000.tif layername: egv_407 English name: Fractional cover of Allotment gardens within the 10 km landscape Latvian name: Vasarnīcu kompleksu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_AllotmentGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_AllotmentGardens_r10000.tif egv_407 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r10000.tif&quot;) names(slanis)=&quot;egv_407&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_AllotmentGardens_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_AllotmentGardens_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.408 General_BareSoilQuarry_cell filename: General_BareSoilQuarry_cell.tif layername: egv_408 English name: Fractional cover of areas with Bare Soil, Quarries within the analysis cell (1 ha) Latvian name: Atklātas augsnes un karjeru platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the bare soil and quarry areas from the Landscape classification are selected (value 800 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_BareSoilQuarry_cell.tif egv_408 ---- baresoilquerry=ifel(simple_landscape==800,1,0) i2e_rez=egvtools::input2egv(input=baresoilquerry, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_BareSoilQuarry_cell.tif&quot;, layername = &quot;egv_408&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(baresoilquerry) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_BareSoilQuarry_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.409 General_BareSoilQuarry_r500 filename: General_BareSoilQuarry_r500.tif layername: egv_409 English name: Fractional cover of areas with Bare Soil, Quarries within the 0.5 km landscape Latvian name: Atklātas augsnes un karjeru platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif&quot;), layer_prefixes = c(&quot;General_BareSoilQuarry&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_BareSoilQuarry_r500.tif egv_409 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r500.tif&quot;) names(slanis)=&quot;egv_409&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_BareSoilQuarry_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.410 General_BareSoilQuarry_r1250 filename: General_BareSoilQuarry_r1250.tif layername: egv_410 English name: Fractional cover of areas with Bare Soil, Quarries within the 1.25 km landscape Latvian name: Atklātas augsnes un karjeru platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif&quot;), layer_prefixes = c(&quot;General_BareSoilQuarry&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_BareSoilQuarry_r1250.tif egv_410 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r1250.tif&quot;) names(slanis)=&quot;egv_410&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_BareSoilQuarry_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.411 General_BareSoilQuarry_r3000 filename: General_BareSoilQuarry_r3000.tif layername: egv_411 English name: Fractional cover of areas with Bare Soil, Quarries within the 3 km landscape Latvian name: Atklātas augsnes un karjeru platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif&quot;), layer_prefixes = c(&quot;General_BareSoilQuarry&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_BareSoilQuarry_r3000.tif egv_411 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r3000.tif&quot;) names(slanis)=&quot;egv_411&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_BareSoilQuarry_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.412 General_BareSoilQuarry_r10000 filename: General_BareSoilQuarry_r10000.tif layername: egv_412 English name: Fractional cover of areas with Bare Soil, Quarries within the 10 km landscape Latvian name: Atklātas augsnes un karjeru platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_cell.tif&quot;), layer_prefixes = c(&quot;General_BareSoilQuarry&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_BareSoilQuarry_r10000.tif egv_412 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r10000.tif&quot;) names(slanis)=&quot;egv_412&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_BareSoilQuarry_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_BareSoilQuarry_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.413 General_Builtup_cell filename: General_Builtup_cell.tif layername: egv_413 English name: Fractional cover of Built-Up areas within the analysis cell (1 ha) Latvian name: Apbūves platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the built-up areas from the Landscape classification are selected (value 500 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_Builtup_cell.tif egv_413 ---- builtup=ifel(simple_landscape==500,1,0) i2e_rez=egvtools::input2egv(input=builtup, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_Builtup_cell.tif&quot;, layername = &quot;egv_413&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(builtup) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Builtup_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.414 General_Builtup_r500 filename: General_Builtup_r500.tif layername: egv_414 English name: Fractional cover of Built-Up areas within the 0.5 km landscape Latvian name: Apbūves platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif&quot;), layer_prefixes = c(&quot;General_Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Builtup_r500.tif egv_414 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_r500.tif&quot;) names(slanis)=&quot;egv_414&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Builtup_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Builtup_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.415 General_Builtup_r1250 filename: General_Builtup_r1250.tif layername: egv_415 English name: Fractional cover of Built-Up areas within the 1.25 km landscape Latvian name: Apbūves platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif&quot;), layer_prefixes = c(&quot;General_Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Builtup_r1250.tif egv_415 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_r1250.tif&quot;) names(slanis)=&quot;egv_415&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Builtup_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Builtup_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.416 General_Builtup_r3000 filename: General_Builtup_r3000.tif layername: egv_416 English name: Fractional cover of Built-Up areas within the 3 km landscape Latvian name: Apbūves platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif&quot;), layer_prefixes = c(&quot;General_Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Builtup_r3000.tif egv_416 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_r3000.tif&quot;) names(slanis)=&quot;egv_416&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Builtup_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Builtup_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.417 General_Builtup_r10000 filename: General_Builtup_r10000.tif layername: egv_417 English name: Fractional cover of Built-Up areas within the 10 km landscape Latvian name: Apbūves platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_cell.tif&quot;), layer_prefixes = c(&quot;General_Builtup&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Builtup_r10000.tif egv_417 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Builtup_r10000.tif&quot;) names(slanis)=&quot;egv_417&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Builtup_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Builtup_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.418 General_Farmland_cell filename: General_Farmland_cell.tif layername: egv_418 English name: Fractional cover of Farmland within the analysis cell (1 ha) Latvian name: Lauksaimniecībā izmantojamo zemju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the farmlands from the Landscape classification are selected (values between 300 and 400 are reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_Farmland_cell.tif egv_418 ---- farmland=ifel(simple_landscape&gt;=300&amp;simple_landscape&lt;400,1,0) i2e_rez=egvtools::input2egv(input=farmland, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_Farmland_cell.tif&quot;, layername = &quot;egv_418&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(farmland) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Farmland_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.419 General_Farmland_r500 filename: General_Farmland_r500.tif layername: egv_419 English name: Fractional cover of Farmland within the 0.5 km landscape Latvian name: Lauksaimniecībā izmantojamo zemju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif&quot;), layer_prefixes = c(&quot;General_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Farmland_r500.tif egv_419 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_r500.tif&quot;) names(slanis)=&quot;egv_419&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Farmland_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Farmland_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.420 General_Farmland_r1250 filename: General_Farmland_r1250.tif layername: egv_420 English name: Fractional cover of Farmland within the 1.25 km landscape Latvian name: Lauksaimniecībā izmantojamo zemju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif&quot;), layer_prefixes = c(&quot;General_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Farmland_r1250.tif egv_420 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_r1250.tif&quot;) names(slanis)=&quot;egv_420&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Farmland_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Farmland_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.421 General_Farmland_r3000 filename: General_Farmland_r3000.tif layername: egv_421 English name: Fractional cover of Farmland within the 3 km landscape Latvian name: Lauksaimniecībā izmantojamo zemju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif&quot;), layer_prefixes = c(&quot;General_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Farmland_r3000.tif egv_421 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_r3000.tif&quot;) names(slanis)=&quot;egv_421&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Farmland_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Farmland_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.422 General_Farmland_r10000 filename: General_Farmland_r10000.tif layername: egv_422 English name: Fractional cover of Farmland within the 10 km landscape Latvian name: Lauksaimniecībā izmantojamo zemju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_cell.tif&quot;), layer_prefixes = c(&quot;General_Farmland&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Farmland_r10000.tif egv_422 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Farmland_r10000.tif&quot;) names(slanis)=&quot;egv_422&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Farmland_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Farmland_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.423 General_ForestsWithoutInventory_cell filename: General_ForestsWithoutInventory_cell.tif layername: egv_423 English name: Fractional cover of Forests Without Inventory within the analysis cell (1 ha) Latvian name: Netaksēto mežu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, clearcuts and forest stands from the State Forest Service’s State Forest Registry are rasterised to match inputs (value 1 and NA elsewhere). Then, from the Landscape classification class 630 is reclassified to value 1, others to 0). These layers are then combined so that values 1 from the second layer, where spatially matching NA values in the first layer as classified as 1 and 0 otherwise. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_ForestsWithoutInventory_cell.tif egv_423 ---- mvr=st_read_parquet(&quot;./Geodata/2024/MVR/nogabali_2024janv.parquet&quot;) tksetie=mvr %&gt;% mutate(yes=1) %&gt;% filter(zkat %in% c(&quot;10&quot;,&quot;12&quot;,&quot;14&quot;,&quot;16&quot;)) taksetie_r=fasterize(tksetie,rastrs10,field=&quot;yes&quot;,fun=&quot;first&quot;) taksetie_t=rast(taksetie_r) visi_mezi=ifel(simple_landscape==630,1,0) netaksetie=ifel(is.na(taksetie_t)&amp;visi_mezi==1,1,0) plot(netaksetie) i2e_rez=egvtools::input2egv(input=netaksetie, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_ForestsWithoutInventory_cell.tif&quot;, layername = &quot;egv_423&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(netaksetie) rm(i2e_rez) rm(mvr) rm(tksetie) rm(taksetie_r) rm(taksetie_t) rm(visi_mezi) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ForestsWithoutInventory_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.424 General_ForestsWithoutInventory_r500 filename: General_ForestsWithoutInventory_r500.tif layername: egv_424 English name: Fractional cover of Forests Without Inventory within the 0.5 km landscape Latvian name: Netaksēto mežu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif&quot;), layer_prefixes = c(&quot;General_ForestsWithoutInventory&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ForestsWithoutInventory_r500.tif egv_424 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r500.tif&quot;) names(slanis)=&quot;egv_424&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ForestsWithoutInventory_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.425 General_ForestsWithoutInventory_r1250 filename: General_ForestsWithoutInventory_r1250.tif layername: egv_425 English name: Fractional cover of Forests Without Inventory within the 1.25 km landscape Latvian name: Netaksēto mežu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif&quot;), layer_prefixes = c(&quot;General_ForestsWithoutInventory&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ForestsWithoutInventory_r1250.tif egv_425 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r1250.tif&quot;) names(slanis)=&quot;egv_425&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ForestsWithoutInventory_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.426 General_ForestsWithoutInventory_r3000 filename: General_ForestsWithoutInventory_r3000.tif layername: egv_426 English name: Fractional cover of Forests Without Inventory within the 3 km landscape Latvian name: Netaksēto mežu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif&quot;), layer_prefixes = c(&quot;General_ForestsWithoutInventory&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ForestsWithoutInventory_r3000.tif egv_426 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r3000.tif&quot;) names(slanis)=&quot;egv_426&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ForestsWithoutInventory_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.427 General_ForestsWithoutInventory_r10000 filename: General_ForestsWithoutInventory_r10000.tif layername: egv_427 English name: Fractional cover of Forests Without Inventory within the 10 km landscape Latvian name: Netaksēto mežu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_cell.tif&quot;), layer_prefixes = c(&quot;General_ForestsWithoutInventory&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ForestsWithoutInventory_r10000.tif egv_427 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r10000.tif&quot;) names(slanis)=&quot;egv_427&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ForestsWithoutInventory_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ForestsWithoutInventory_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.428 General_GardensOrchards_cell filename: General_GardensOrchards_cell.tif layername: egv_428 English name: Fractional cover of Allotment gardens, Orchards within the analysis cell (1 ha) Latvian name: Vasarnīcu kompleksu un augļudārzu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the allotment gardens and orchards from the Landscape classification are selected (values between 400 and 500 are reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_GardensOrchards_cell.tif egv_428 ---- parejie=ifel(simple_landscape&gt;=400&amp;simple_landscape&lt;500,1,0) i2e_rez=egvtools::input2egv(input=parejie, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_GardensOrchards_cell.tif&quot;, layername = &quot;egv_428&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(parejie) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_GardensOrchards_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.429 General_GardensOrchards_r500 filename: General_GardensOrchards_r500.tif layername: egv_429 English name: Fractional cover of Allotment gardens, Orchards within the 0.5 km landscape Latvian name: Vasarnīcu kompleksu un augļudārzu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_GardensOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_GardensOrchards_r500.tif egv_429 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r500.tif&quot;) names(slanis)=&quot;egv_429&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_GardensOrchards_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.430 General_GardensOrchards_r1250 filename: General_GardensOrchards_r1250.tif layername: egv_430 English name: Fractional cover of Allotment gardens, Orchards within the 1.25 km landscape Latvian name: Vasarnīcu kompleksu un augļudārzu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_GardensOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_GardensOrchards_r1250.tif egv_430 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r1250.tif&quot;) names(slanis)=&quot;egv_430&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_GardensOrchards_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.431 General_GardensOrchards_r3000 filename: General_GardensOrchards_r3000.tif layername: egv_431 English name: Fractional cover of Allotment gardens, Orchards within the 3 km landscape Latvian name: Vasarnīcu kompleksu un augļudārzu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_GardensOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_GardensOrchards_r3000.tif egv_431 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r3000.tif&quot;) names(slanis)=&quot;egv_431&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_GardensOrchards_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.432 General_GardensOrchards_r10000 filename: General_GardensOrchards_r10000.tif layername: egv_432 English name: Fractional cover of Allotment gardens, Orchards within the 10 km landscape Latvian name: Vasarnīcu kompleksu un augļudārzu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_GardensOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_GardensOrchards_r10000.tif egv_432 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r10000.tif&quot;) names(slanis)=&quot;egv_432&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_GardensOrchards_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_GardensOrchards_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.433 General_Roads_cell filename: General_Roads_cell.tif layername: egv_433 English name: Fractional cover of Roads within the analysis cell (1 ha) Latvian name: Ceļu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the roads from the Landscape classification are selected (value 100 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_Roads_cell.tif egv_433 ---- celi=ifel(simple_landscape==100,1,0) i2e_rez=egvtools::input2egv(input=celi, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_Roads_cell.tif&quot;, layername = &quot;egv_433&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(celi) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Roads_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.434 General_ShrubsOrchards_cell filename: General_ShrubsOrchards_cell.tif layername: egv_434 English name: Fractional cover of Shrubs, Young stands, Orchards within the analysis cell (1 ha) Latvian name: Krūmāju, jaunaudžu un augļudārzu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as short term coppice are selected from the Rural Support Service’s information on declared fields and rasterised to match inputs. Then orchards and shrubs-low forest stands from Landscape classification are selected (values equal to 420 or 620 are reclassified to value 1, others as 0). The first layer is then covered over the second. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_ShrubsOrchards_cell.tif egv_434 ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) table(kodi$SDM_grupa_sakums,useNA=&quot;always&quot;) lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) ilggadigiekrumveida=lad %&gt;% filter(SDM_grupa_sakums == &quot;krūmveida ilggadīgie stādījumi&quot;) krumveida_r=fasterize(ilggadigiekrumveida,rastrs10,field=&quot;yes&quot;,fun=&quot;first&quot;) krumveida_t=rast(krumveida_r) augludarzi=ifel(simple_landscape==420|simple_landscape==620,1,0) apvienoti=cover(krumveida_t,augludarzi) plot(apvienoti) i2e_rez=egvtools::input2egv(input=apvienoti, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_ShrubsOrchards_cell.tif&quot;, layername = &quot;egv_434&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(apvienoti) rm(i2e_rez) rm(ilggadigiekrumveida) rm(krumveida_r) rm(krumveida_t) rm(augludarzi) rm(kodi) rm(lad) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchards_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.435 General_ShrubsOrchards_r500 filename: General_ShrubsOrchards_r500.tif layername: egv_435 English name: Fractional cover of Shrubs, Young stands, Orchards within the 0.5 km landscape Latvian name: Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchards_r500.tif egv_435 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r500.tif&quot;) names(slanis)=&quot;egv_435&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchards_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.436 General_ShrubsOrchards_r1250 filename: General_ShrubsOrchards_r1250.tif layername: egv_436 English name: Fractional cover of Shrubs, Young stands, Orchards within the 1.25 km landscape Latvian name: Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchards_r1250.tif egv_436 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r1250.tif&quot;) names(slanis)=&quot;egv_436&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchards_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.437 General_ShrubsOrchards_r3000 filename: General_ShrubsOrchards_r3000.tif layername: egv_437 English name: Fractional cover of Shrubs, Young stands, Orchards within the 3 km landscape Latvian name: Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchards_r3000.tif egv_437 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r3000.tif&quot;) names(slanis)=&quot;egv_437&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchards_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.438 General_ShrubsOrchards_r10000 filename: General_ShrubsOrchards_r10000.tif layername: egv_438 English name: Fractional cover of Shrubs, Young stands, Orchards within the 10 km landscape Latvian name: Krūmāju, jaunaudžu un augļudārzu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchards&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchards_r10000.tif egv_438 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r10000.tif&quot;) names(slanis)=&quot;egv_438&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchards_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchards_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.439 General_ShrubsOrchardsGardens_cell filename: General_ShrubsOrchardsGardens_cell.tif layername: egv_439 English name: Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the analysis cell (1 ha) Latvian name: Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, agricultural parcels declared as short term coppice are selected from the Rural Support Service’s information on declared fields and rasterised to match inputs. Then orchards, allotment gardens and shrubs-low forest stands from the Landscape classification are selected (values between 400 and 500 or equal to 620 are reclassified to value 1, others as 0). The first layer is then covered over the second. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_ShrubsOrchardsGardens_cell.tif egv_439 ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) table(kodi$SDM_grupa_sakums,useNA=&quot;always&quot;) lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) ilggadigiekrumveida=lad %&gt;% filter(SDM_grupa_sakums == &quot;krūmveida ilggadīgie stādījumi&quot;) krumveida_r=fasterize(ilggadigiekrumveida,rastrs10,field=&quot;yes&quot;,fun=&quot;first&quot;) krumveida_t=rast(krumveida_r) parejie=ifel((simple_landscape&gt;=400&amp;simple_landscape&lt;500)| simple_landscape==620,1,0) apvienoti=cover(krumveida_t,parejie) plot(apvienoti) i2e_rez=egvtools::input2egv(input=apvienoti, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_ShrubsOrchardsGardens_cell.tif&quot;, layername = &quot;egv_439&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(apvienoti) rm(i2e_rez) rm(ilggadigiekrumveida) rm(krumveida_r) rm(krumveida_t) rm(parejie) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchardsGardens_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.440 General_ShrubsOrchardsGardens_r500 filename: General_ShrubsOrchardsGardens_r500.tif layername: egv_440 English name: Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 0.5 km landscape Latvian name: Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchardsGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchardsGardens_r500.tif egv_440 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r500.tif&quot;) names(slanis)=&quot;egv_440&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchardsGardens_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.441 General_ShrubsOrchardsGardens_r1250 filename: General_ShrubsOrchardsGardens_r1250.tif layername: egv_441 English name: Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 1.25 km landscape Latvian name: Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchardsGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchardsGardens_r1250.tif egv_441 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r1250.tif&quot;) names(slanis)=&quot;egv_441&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchardsGardens_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.442 General_ShrubsOrchardsGardens_r3000 filename: General_ShrubsOrchardsGardens_r3000.tif layername: egv_442 English name: Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 3 km landscape Latvian name: Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchardsGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchardsGardens_r3000.tif egv_442 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r3000.tif&quot;) names(slanis)=&quot;egv_442&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchardsGardens_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.443 General_ShrubsOrchardsGardens_r10000 filename: General_ShrubsOrchardsGardens_r10000.tif layername: egv_443 English name: Fractional cover of Shrubs, Young stands, Orchards, Allotment gardens within the 10 km landscape Latvian name: Krūmāju, jaunaudžu, augļudārzu un vasarnīcu kompleksu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_cell.tif&quot;), layer_prefixes = c(&quot;General_ShrubsOrchardsGardens&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_ShrubsOrchardsGardens_r10000.tif egv_443 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r10000.tif&quot;) names(slanis)=&quot;egv_443&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_ShrubsOrchardsGardens_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_ShrubsOrchardsGardens_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.444 General_SwampsMiresBogsHelophytes_cell filename: General_SwampsMiresBogsHelophytes_cell.tif layername: egv_444 English name: Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the analysis cell (1 ha) Latvian name: Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the swamps, mires, bogs and reed, sedge, rush beds from the Landscape classification are selected (values between 700 and 800 are reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_SwampsMiresBogsHelophytes_cell.tif egv_444 ---- purvi=ifel(simple_landscape&gt;=700&amp;simple_landscape&lt;800,1,0) i2e_rez=egvtools::input2egv(input=purvi, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_SwampsMiresBogsHelophytes_cell.tif&quot;, layername = &quot;egv_444&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(purvi) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_SwampsMiresBogsHelophytes_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.445 General_SwampsMiresBogsHelophytes_r500 filename: General_SwampsMiresBogsHelophytes_r500.tif layername: egv_445 English name: Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 0.5 km landscape Latvian name: Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif&quot;), layer_prefixes = c(&quot;General_SwampsMiresBogsHelophytes&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_SwampsMiresBogsHelophytes_r500.tif egv_445 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r500.tif&quot;) names(slanis)=&quot;egv_445&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_SwampsMiresBogsHelophytes_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.446 General_SwampsMiresBogsHelophytes_r1250 filename: General_SwampsMiresBogsHelophytes_r1250.tif layername: egv_446 English name: Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 1.25 km landscape Latvian name: Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif&quot;), layer_prefixes = c(&quot;General_SwampsMiresBogsHelophytes&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_SwampsMiresBogsHelophytes_r1250.tif egv_446 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r1250.tif&quot;) names(slanis)=&quot;egv_446&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_SwampsMiresBogsHelophytes_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.447 General_SwampsMiresBogsHelophytes_r3000 filename: General_SwampsMiresBogsHelophytes_r3000.tif layername: egv_447 English name: Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 3 km landscape Latvian name: Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif&quot;), layer_prefixes = c(&quot;General_SwampsMiresBogsHelophytes&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_SwampsMiresBogsHelophytes_r3000.tif egv_447 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r3000.tif&quot;) names(slanis)=&quot;egv_447&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_SwampsMiresBogsHelophytes_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.448 General_SwampsMiresBogsHelophytes_r10000 filename: General_SwampsMiresBogsHelophytes_r10000.tif layername: egv_448 English name: Fractional cover of Swamps, Mires, Bogs, Reed-, Sedge-, Rush- Beds within the 10 km landscape Latvian name: Purvu, niedrāju, grīslāju, meldrāju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_cell.tif&quot;), layer_prefixes = c(&quot;General_SwampsMiresBogsHelophytes&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_SwampsMiresBogsHelophytes_r10000.tif egv_448 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r10000.tif&quot;) names(slanis)=&quot;egv_448&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_SwampsMiresBogsHelophytes_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_SwampsMiresBogsHelophytes_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.449 General_Trees_cell filename: General_Trees_cell.tif layername: egv_449 English name: Fractional cover of Trees, Shrubs, Clear-cuts within the analysis cell (1 ha) Latvian name: Koku, krūmu un izcirtumu platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the trees, shrubs and clear cuts from the Landscape classification are selected (values between 600 and 700 are reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_Trees_cell.tif egv_449 ---- kokimezi=ifel(simple_landscape&gt;=600&amp;simple_landscape&lt;700,1,0) i2e_rez=egvtools::input2egv(input=kokimezi, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_Trees_cell.tif&quot;, layername = &quot;egv_449&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(kokimezi) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Trees_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.450 General_Trees_r500 filename: General_Trees_r500.tif layername: egv_450 English name: Fractional cover of Trees, Shrubs, Clear-cuts within the 0.5 km landscape Latvian name: Koku, krūmu un izcirtumu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Trees_cell.tif&quot;), layer_prefixes = c(&quot;General_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Trees_r500.tif egv_450 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Trees_r500.tif&quot;) names(slanis)=&quot;egv_450&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Trees_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Trees_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.451 General_Trees_r1250 filename: General_Trees_r1250.tif layername: egv_451 English name: Fractional cover of Trees, Shrubs, Clear-cuts within the 1.25 km landscape Latvian name: Koku, krūmu un izcirtumu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Trees_cell.tif&quot;), layer_prefixes = c(&quot;General_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Trees_r1250.tif egv_451 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Trees_r1250.tif&quot;) names(slanis)=&quot;egv_451&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Trees_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Trees_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.452 General_Trees_r3000 filename: General_Trees_r3000.tif layername: egv_452 English name: Fractional cover of Trees, Shrubs, Clear-cuts within the 3 km landscape Latvian name: Koku, krūmu un izcirtumu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Trees_cell.tif&quot;), layer_prefixes = c(&quot;General_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Trees_r3000.tif egv_452 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Trees_r3000.tif&quot;) names(slanis)=&quot;egv_452&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Trees_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Trees_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.453 General_Trees_r10000 filename: General_Trees_r10000.tif layername: egv_453 English name: Fractional cover of Trees, Shrubs, Clear-cuts within the 10 km landscape Latvian name: Koku, krūmu un izcirtumu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Trees_cell.tif&quot;), layer_prefixes = c(&quot;General_Trees&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Trees_r10000.tif egv_453 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Trees_r10000.tif&quot;) names(slanis)=&quot;egv_453&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Trees_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Trees_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.454 General_TreesOutsideForests_cell filename: General_TreesOutsideForests_cell.tif layername: egv_454 English name: Fractional cover of Tree covered areas Outside Forests within the analysis cell (1 ha) Latvian name: Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the trees outside forest stands from the Landscape classification are selected (value 640 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_TreesOutsideForests_cell.tif egv_454 ---- kokiarpuse=ifel(simple_landscape==640,1,0) i2e_rez=egvtools::input2egv(input=kokiarpuse, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_TreesOutsideForests_cell.tif&quot;, layername = &quot;egv_454&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(kokiarpuse) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_TreesOutsideForests_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.455 General_TreesOutsideForests_r500 filename: General_TreesOutsideForests_r500.tif layername: egv_455 English name: Fractional cover of Tree covered areas Outside Forests within the 0.5 km landscape Latvian name: Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif&quot;), layer_prefixes = c(&quot;General_TreesOutsideForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_TreesOutsideForests_r500.tif egv_455 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r500.tif&quot;) names(slanis)=&quot;egv_455&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_TreesOutsideForests_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.456 General_TreesOutsideForests_r1250 filename: General_TreesOutsideForests_r1250.tif layername: egv_456 English name: Fractional cover of Tree covered areas Outside Forests within the 1.25 km landscape Latvian name: Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif&quot;), layer_prefixes = c(&quot;General_TreesOutsideForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_TreesOutsideForests_r1250.tif egv_456 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r1250.tif&quot;) names(slanis)=&quot;egv_456&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_TreesOutsideForests_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.457 General_TreesOutsideForests_r3000 filename: General_TreesOutsideForests_r3000.tif layername: egv_457 English name: Fractional cover of Tree covered areas Outside Forests within the 3 km landscape Latvian name: Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif&quot;), layer_prefixes = c(&quot;General_TreesOutsideForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_TreesOutsideForests_r3000.tif egv_457 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r3000.tif&quot;) names(slanis)=&quot;egv_457&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_TreesOutsideForests_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.458 General_TreesOutsideForests_r10000 filename: General_TreesOutsideForests_r10000.tif layername: egv_458 English name: Fractional cover of Tree covered areas Outside Forests within the 10 km landscape Latvian name: Ar kokiem klāto teritoriju ārpus mežiem platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_cell.tif&quot;), layer_prefixes = c(&quot;General_TreesOutsideForests&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_TreesOutsideForests_r10000.tif egv_458 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r10000.tif&quot;) names(slanis)=&quot;egv_458&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_TreesOutsideForests_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_TreesOutsideForests_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.459 General_Water_cell filename: General_Water_cell.tif layername: egv_459 English name: Fractional cover of Waterbodies within the analysis cell (1 ha) Latvian name: Ūdenstilpju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the waters from the Landscape classification are selected (value 200 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # General_Water_cell.tif egv_459 ---- udens=ifel(simple_landscape==200,1,0) i2e_rez=egvtools::input2egv(input=udens, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;General_Water_cell.tif&quot;, layername = &quot;egv_459&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(udens) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Water_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.460 General_Water_r500 filename: General_Water_r500.tif layername: egv_460 English name: Fractional cover of Waterbodies within the 0.5 km landscape Latvian name: Ūdenstilpju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Water_cell.tif&quot;), layer_prefixes = c(&quot;General_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Water_r500.tif egv_460 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Water_r500.tif&quot;) names(slanis)=&quot;egv_460&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Water_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Water_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.461 General_Water_r1250 filename: General_Water_r1250.tif layername: egv_461 English name: Fractional cover of Waterbodies within the 1.25 km landscape Latvian name: Ūdenstilpju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Water_cell.tif&quot;), layer_prefixes = c(&quot;General_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Water_r1250.tif egv_461 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Water_r1250.tif&quot;) names(slanis)=&quot;egv_461&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Water_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Water_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.462 General_Water_r3000 filename: General_Water_r3000.tif layername: egv_462 English name: Fractional cover of Waterbodies within the 3 km landscape Latvian name: Ūdenstilpju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Water_cell.tif&quot;), layer_prefixes = c(&quot;General_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Water_r3000.tif egv_462 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Water_r3000.tif&quot;) names(slanis)=&quot;egv_462&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Water_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Water_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.463 General_Water_r10000 filename: General_Water_r10000.tif layername: egv_463 English name: Fractional cover of Waterbodies within the 10 km landscape Latvian name: Ūdenstilpju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/General_Water_cell.tif&quot;), layer_prefixes = c(&quot;General_Water&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 6, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 40 * 1024^3) # General_Water_r10000.tif egv_463 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/General_Water_r10000.tif&quot;) names(slanis)=&quot;egv_463&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/General_Water_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;General_Water_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.464 Wetlands_Bogs_cell filename: Wetlands_Bogs_cell.tif layername: egv_464 English name: Fractional cover of Raised Bogs within the analysis cell (1 ha) Latvian name: Augsto purvu platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Bogs and Mires: EDI, where bogs are classified as 1 with 0 elsewhere. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # template ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Wetlands_Bogs_cell.tif egv_464 ---- bogs=rast(&quot;./RasterGrids_10m/2024/EDI_BogsYN.tif&quot;) i2e_rez=egvtools::input2egv(input=bogs, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Wetlands_Bogs_cell.tif&quot;, layername = &quot;egv_464&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(bogs) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Bogs_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.465 Wetlands_Bogs_r500 filename: Wetlands_Bogs_r500.tif layername: egv_465 English name: Fractional cover of Raised Bogs within the 0.5 km landscape Latvian name: Augsto purvu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Bogs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Bogs_r500.tif egv_465 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r500.tif&quot;) names(slanis)=&quot;egv_465&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Bogs_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.466 Wetlands_Bogs_r1250 filename: Wetlands_Bogs_r1250.tif layername: egv_466 English name: Fractional cover of Raised Bogs within the 1.25 km landscape Latvian name: Augsto purvu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Bogs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Bogs_r1250.tif egv_466 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r1250.tif&quot;) names(slanis)=&quot;egv_466&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Bogs_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.467 Wetlands_Bogs_r3000 filename: Wetlands_Bogs_r3000.tif layername: egv_467 English name: Fractional cover of Raised Bogs within the 3 km landscape Latvian name: Augsto purvu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Bogs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Bogs_r3000.tif egv_467 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r3000.tif&quot;) names(slanis)=&quot;egv_467&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Bogs_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.468 Wetlands_Bogs_r10000 filename: Wetlands_Bogs_r10000.tif layername: egv_468 English name: Fractional cover of Raised Bogs within the 10 km landscape Latvian name: Augsto purvu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Bogs&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Bogs_r10000.tif egv_468 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r10000.tif&quot;) names(slanis)=&quot;egv_468&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Bogs_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Bogs_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.469 Wetlands_Mires_cell filename: Wetlands_Mires_cell.tif layername: egv_469 English name: Fractional cover of Transitional Mires within the analysis cell (1 ha) Latvian name: Pārejas purvu platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Bogs and Mires: EDI, where transitional mires are classified as 1 with 0 elsewhere. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} # template ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Wetlands_Mires_cell.tif egv_469 ---- mires=rast(&quot;./RasterGrids_10m/2024/EDI_TransitionalMiresYN.tif&quot;) i2e_rez=egvtools::input2egv(input=mires, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Wetlands_Mires_cell.tif&quot;, layername = &quot;egv_469&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(mires) rm(i2e_rez) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Mires_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.470 Wetlands_Mires_r500 filename: Wetlands_Mires_r500.tif layername: egv_470 English name: Fractional cover of Transitional Mires within the 0.5 km landscape Latvian name: Pārejas purvu platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Mires&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Mires_r500.tif egv_470 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r500.tif&quot;) names(slanis)=&quot;egv_470&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Mires_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.471 Wetlands_Mires_r1250 filename: Wetlands_Mires_r1250.tif layername: egv_471 English name: Fractional cover of Transitional Mires within the 1.25 km landscape Latvian name: Pārejas purvu platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Mires&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Mires_r1250.tif egv_471 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r1250.tif&quot;) names(slanis)=&quot;egv_471&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Mires_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.472 Wetlands_Mires_r3000 filename: Wetlands_Mires_r3000.tif layername: egv_472 English name: Fractional cover of Transitional Mires within the 3 km landscape Latvian name: Pārejas purvu platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Mires&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Mires_r3000.tif egv_472 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r3000.tif&quot;) names(slanis)=&quot;egv_472&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Mires_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.473 Wetlands_Mires_r10000 filename: Wetlands_Mires_r10000.tif layername: egv_473 English name: Fractional cover of Transitional Mires within the 10 km landscape Latvian name: Pārejas purvu platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_Mires&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_Mires_r10000.tif egv_473 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r10000.tif&quot;) names(slanis)=&quot;egv_473&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_Mires_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_Mires_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.474 Wetlands_ReedSedgeRushBeds_cell filename: Wetlands_ReedSedgeRushBeds_cell.tif layername: egv_474 English name: Fractional cover of Reed-, Sedge-, Rush-, Beds within the analysis cell (1 ha) Latvian name: Niedrāju, grīslāju, meldrāju platības īpatsvars analīzes šūnā (1 ha) Procedure: First, the reed, sedge and rush beds from the Landscape classification are selected (value 720 is reclassified to value 1; all others are set to 0). The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(sf)) {install.packages(&quot;sf&quot;); require(sf)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} if(!require(sfarrow)) {install.packages(&quot;sfarrow&quot;); require(sfarrow)} if(!require(readxl)) {install.packages(&quot;readxl&quot;); require(readxl)} if(!require(raster)) {install.packages(&quot;raster&quot;); require(raster)} if(!require(fasterize)) {install.packages(&quot;fasterize&quot;); require(fasterize)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) rastrs10=raster(template10) nulls10=rast(&quot;./Templates/TemplateRasters/nulls_LV10m_10km.tif&quot;) nulls100=rast(&quot;./Templates/TemplateRasters/nulls_LV100m_10km.tif&quot;) # codes ---- kodi=read_excel(&quot;./Geodata/2024/LAD/KulturuKodi_2024.xlsx&quot;) kodi$kods=as.character(kodi$kods) # LAD ---- lad=sfarrow::st_read_parquet(&quot;./Geodata/2024/LAD/Lauki_2024.parquet&quot;) lad$yes=1 lad=lad %&gt;% left_join(kodi,by=c(&quot;PRODUCT_CODE&quot;=&quot;kods&quot;)) # simple landscape ---- simple_landscape=rast(&quot;RasterGrids_10m/2024/Ainava_vienk_mask.tif&quot;) # Wetlands_ReedSedgeRushBeds_cell.tif egv_474 ---- reedsedgerush=ifel(simple_landscape==720,1,0) i2e_rez=egvtools::input2egv(input=reedsedgerush, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Wetlands_ReedSedgeRushBeds_cell.tif&quot;, layername = &quot;egv_474&quot;, idw_weight = 2, plot_gaps = FALSE,plot_final = TRUE) i2e_rez rm(reedsedgerush) rm(i2e_rez) rm(simple_landscape) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_ReedSedgeRushBeds_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.475 Wetlands_ReedSedgeRushBeds_r500 filename: Wetlands_ReedSedgeRushBeds_r500.tif layername: egv_475 English name: Fractional cover of Reed-, Sedge-, Rush-, Beds within the 0.5 km landscape Latvian name: Niedrāju, grīslāju, meldrāju platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_ReedSedgeRushBeds&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_ReedSedgeRushBeds_r500.tif egv_475 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r500.tif&quot;) names(slanis)=&quot;egv_475&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_ReedSedgeRushBeds_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.476 Wetlands_ReedSedgeRushBeds_r1250 filename: Wetlands_ReedSedgeRushBeds_r1250.tif layername: egv_476 English name: Fractional cover of Reed-, Sedge-, Rush-, Beds within the 1.25 km landscape Latvian name: Niedrāju, grīslāju, meldrāju platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_ReedSedgeRushBeds&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_ReedSedgeRushBeds_r1250.tif egv_476 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r1250.tif&quot;) names(slanis)=&quot;egv_476&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_ReedSedgeRushBeds_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.477 Wetlands_ReedSedgeRushBeds_r3000 filename: Wetlands_ReedSedgeRushBeds_r3000.tif layername: egv_477 English name: Fractional cover of Reed-, Sedge-, Rush-, Beds within the 3 km landscape Latvian name: Niedrāju, grīslāju, meldrāju platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_ReedSedgeRushBeds&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_ReedSedgeRushBeds_r3000.tif egv_477 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r3000.tif&quot;) names(slanis)=&quot;egv_477&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_ReedSedgeRushBeds_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.478 Wetlands_ReedSedgeRushBeds_r10000 filename: Wetlands_ReedSedgeRushBeds_r10000.tif layername: egv_478 English name: Fractional cover of Reed-, Sedge-, Rush-, Beds within the 10 km landscape Latvian name: Niedrāju, grīslāju, meldrāju platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # Templates ----- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_cell.tif&quot;), layer_prefixes = c(&quot;Wetlands_ReedSedgeRushBeds&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 12, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 20 * 1024^3) # Wetlands_ReedSedgeRushBeds_r10000.tif egv_478 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r10000.tif&quot;) names(slanis)=&quot;egv_478&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Wetlands_ReedSedgeRushBeds_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Wetlands_ReedSedgeRushBeds_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.479 EO_NDMI-LYmed-average_cell filename: EO_NDMI-LYmed-average_cell.tif layername: egv_479 English name: Median vegetation water content (NDMI) for the last year within the analysis cell (1 ha) Latvian name: Mediānā pēdējā gada ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-LYmed-average_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDMI-LYmed-average_cell.tif&quot;, layername = &quot;egv_479&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-LYmed-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.480 EO_NDMI-LYmedian-iqr_cell filename: EO_NDMI-LYmedian-iqr_cell.tif layername: egv_480 English name: Spatial variability of last year’s median vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējā gada mediānajai ūdens satura veģetācijā indeksa (NDMI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-LYmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_480&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_480&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDMI-LYmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-LYmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.481 EO_NDMI-STiqr-median_cell filename: EO_NDMI-STiqr-median_cell.tif layername: egv_481 English name: Average short-term seasonality of vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Sezonalitāte pēdējo piecu gadu vidējam ūdens satura veģetācijā indeksa (NDMI) vērtībai, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-STiqr-median_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STiqr.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDMI-STiqr-median_cell.tif&quot;, layername = &quot;egv_481&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-STiqr-median_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.482 EO_NDMI-STmedian-average_cell filename: EO_NDMI-STmedian-average_cell.tif layername: egv_482 English name: Median short-term vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Mediānā pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-STmedian-average_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDMI-STmedian-average_cell.tif&quot;, layername = &quot;egv_482&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-STmedian-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.483 EO_NDMI-STmedian-iqr_cell filename: EO_NDMI-STmedian-iqr_cell.tif layername: egv_483 English name: Spatial variability of short-term median vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējo piecu gadu mediānajai ūdens satura veģetācijā indeksa (NDMI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-STmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_483&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_483&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDMI-STmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-STmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.484 EO_NDMI-STp25-min_cell filename: EO_NDMI-STp25-min_cell.tif layername: egv_484 English name: Minimum short-term 25th percentile of vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Minimālā 25. procentiles pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The minimum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-STp25-min_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STp25.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDMI-STp25-min_cell.tif&quot;, layername = &quot;egv_484&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-STp25-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.485 EO_NDMI-STp75-max_cell filename: EO_NDMI-STp75-max_cell.tif layername: egv_485 English name: Maximum short-term 75th percentile of vegetation water content (NDMI) within the analysis cell (1 ha) Latvian name: Maksimālā 75. procentiles pēdējo piecu gadu ūdens satura veģetācijā indeksa (NDMI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The maximum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDMI-STp75-max_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDMI-STp75.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDMI-STp75-max_cell.tif&quot;, layername = &quot;egv_485&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDMI-STp75-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.486 EO_NDVI-LYmedian-average_cell filename: EO_NDVI-LYmedian-average_cell.tif layername: egv_486 English name: Median vegetation index (NDVI) for the last year within the analysis cell (1 ha) Latvian name: Mediānā pēdējā gada veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-LYmedian-average_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDVI-LYmedian-average_cell.tif&quot;, layername = &quot;egv_486&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-LYmedian-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.487 EO_NDVI-LYmedian-iqr_cell filename: EO_NDVI-LYmedian-iqr_cell.tif layername: egv_487 English name: Spatial variability of last year’s median vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējā gada mediānajai veģetācijas indeksa (NDVI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-LYmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_487&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_487&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDVI-LYmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-LYmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.488 EO_NDVI-STiqr-median_cell filename: EO_NDVI-STiqr-median_cell.tif layername: egv_488 English name: Average short-term seasonality of vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Sezonalitāte pēdējo piecu gadu vidējam veģetācijas indeksa (NDVI) vērtībai, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-STiqr-median_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STiqr.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDVI-STiqr-median_cell.tif&quot;, layername = &quot;egv_488&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-STiqr-median_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.489 EO_NDVI-STmedian-average_cell filename: EO_NDVI-STmedian-average_cell.tif layername: egv_489 English name: Median short-term vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Mediānā pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-STmedian-average_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDVI-STmedian-average_cell.tif&quot;, layername = &quot;egv_489&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-STmedian-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.490 EO_NDVI-STmedian-iqr_cell filename: EO_NDVI-STmedian-iqr_cell.tif layername: egv_490 English name: Spatial variability of short-term median vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējo piecu gadu mediānajai veģetācijas indeksa (NDVI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-STmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_490&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_490&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDVI-STmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-STmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.491 EO_NDVI-STp25-min_cell filename: EO_NDVI-STp25-min_cell.tif layername: egv_491 English name: Minimum short-term 25th percentile of vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Minimālā 25. procentiles pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The minimum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-STp25-min_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STp25.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDVI-STp25-min_cell.tif&quot;, layername = &quot;egv_491&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-STp25-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.492 EO_NDVI-STp75-max_cell filename: EO_NDVI-STp75-max_cell.tif layername: egv_492 English name: Maximum short-term 75th percentile of vegetation index (NDVI) within the analysis cell (1 ha) Latvian name: Maksimālā 75. procentiles pēdējo piecu gadu veģetācijas indeksa (NDVI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The maximum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDVI-STp75-max_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDVI-STp75.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDVI-STp75-max_cell.tif&quot;, layername = &quot;egv_492&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDVI-STp75-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.493 EO_NDWI-LYmedian-average_cell filename: EO_NDWI-LYmedian-average_cell.tif layername: egv_493 English name: Median water index (NDWI) for the last year within the analysis cell (1 ha) Latvian name: Mediānā pēdējā gada ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDWI-LYmedian-average_cell.tif&quot;, layername = &quot;egv_493&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-LYmedian-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.494 EO_NDWI-LYmedian-iqr_cell filename: EO_NDWI-LYmedian-iqr_cell.tif layername: egv_494 English name: Spatial variability of last year’s median water index (NDWI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējā gada mediānajai ūdens indeksa (NDWI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “last year” is 2024. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-LYmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_494&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-LYmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_494&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDWI-LYmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-LYmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.495 EO_NDWI-STiqr-median_cell filename: EO_NDWI-STiqr-median_cell.tif layername: egv_495 English name: Average short-term seasonality of water index (NDWI) within the analysis cell (1 ha) Latvian name: Sezonalitāte pēdējo piecu gadu vidējam ūdens indeksa (NDWI) vērtībai, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-STiqr-median_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STiqr.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDWI-STiqr-median_cell.tif&quot;, layername = &quot;egv_495&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-STiqr-median_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.496 EO_NDWI-STmedian-average_cell filename: EO_NDWI-STmedian-average_cell.tif layername: egv_496 English name: Median short-term water index (NDWI) within the analysis cell (1 ha) Latvian name: Mediānā pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The arithmetic mean value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-STmedian-average_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDWI-STmedian-average_cell.tif&quot;, layername = &quot;egv_496&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-STmedian-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.497 EO_NDWI-STmedian-iqr_cell filename: EO_NDWI-STmedian-iqr_cell.tif layername: egv_497 English name: Spatial variability of short-term median water index (NDWI) within the analysis cell (1 ha) Latvian name: Telpiskā variabilitāte pēdējo piecu gadu mediānajai ūdens indeksa (NDWI) vērtībai, starpkvartiļu apgabals analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-STmedian-iqr_cell.tif ---- p25rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_497&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STmedian.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_497&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/EO_NDWI-STmedian-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-STmedian-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.498 EO_NDWI-STp25-min_cell filename: EO_NDWI-STp25-min_cell.tif layername: egv_498 English name: Minimum short-term 25th percentile of water index (NDWI) within the analysis cell (1 ha) Latvian name: Minimālā 25. procentiles pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The minimum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-STp25-min_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STp25.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDWI-STp25-min_cell.tif&quot;, layername = &quot;egv_498&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-STp25-min_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.499 EO_NDWI-STp75-max_cell filename: EO_NDWI-STp75-max_cell.tif layername: egv_499 English name: Maximum short-term 75th percentile of water index (NDWI) within the analysis cell (1 ha) Latvian name: Maksimālā 75. procentiles pēdējo piecu gadu ūdens indeksa (NDWI) vērtība, vidējais analīzes šūnā (1 ha) Procedure: Directly follows preprocessing. The maximum value at the analysis cell is calculated using the workflow egvtools::input2egv(). To protect against potential data loss at edge cells, inverse distance weighted (power = 2) gap filling is implemented. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. The “short-term” refers to the last five years (2020-2024). Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EO_NDWI-STp75-max_cell.tif ---- egvrez=input2egv(input=&quot;./Geodata/2024/S2indices/Mosaics/EO_NDWI-STp75.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;min&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;EO_NDWI-STp75-max_cell.tif&quot;, layername = &quot;egv_499&quot;, idw_weight = 2, plot_gaps = FALSE, plot_final = FALSE) egvrez # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;EO_NDWI-STp75-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.500 SoilChemistry_ESDAC-CN_cell filename: SoilChemistry_ESDAC-CN_cell.tif layername: egv_500 English name: Average value of Topsoil Carbon-Nitrogen ratio (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas oglekļa-slāpekļa attiecība (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # CN ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/CN/CN.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-CN_cell.tif&quot;, layer_name = &quot;egv_500&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-CN_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.501 SoilChemistry_ESDAC-CaCo3_cell filename: SoilChemistry_ESDAC-CaCo3_cell.tif layername: egv_501 English name: Average value of Topsoil Calcium Carbonates Content (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas kalcija karbonātu saturs (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # CaCO3 ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/Caco3/CaCO3.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-CaCo3_cell.tif&quot;, layer_name = &quot;egv_501&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-CaCo3_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.502 SoilChemistry_ESDAC-K_cell filename: SoilChemistry_ESDAC-K_cell.tif layername: egv_502 English name: Average value of Topsoil Sodium Content (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas kālija saturs (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # K ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/K/K.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-K_cell.tif&quot;, layer_name = &quot;egv_502&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-K_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.503 SoilChemistry_ESDAC-N_cell filename: SoilChemistry_ESDAC-N_cell.tif layername: egv_503 English name: Average value of Topsoil Nitrogen Content (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas slāpekļa saturs (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # N ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/N/N.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-N_cell.tif&quot;, layer_name = &quot;egv_503&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-N_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.504 SoilChemistry_ESDAC-P_cell filename: SoilChemistry_ESDAC-P_cell.tif layername: egv_504 English name: Average value of Topsoil Phosphorous Content (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas fosfora saturs (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # P ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/P/P.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-P_cell.tif&quot;, layer_name = &quot;egv_504&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-P_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.505 SoilChemistry_ESDAC-phH2O_cell filename: SoilChemistry_ESDAC-phH2O_cell.tif layername: egv_505 English name: Average value of Topsoil pH reaction in water (ESDAC v2.0) within the analysis cell (1 ha) Latvian name: Augsnes virskārtas reakcija (pH) ūdens šķīdumā (ESDAC v2.0) analīzes šūnā (1 ha) Procedure: Directly derived from the Soil chemistry. Processed using the workflow egvtools::downscale2egv() with fill gaps = TRUE, performing inverse distance weighted (power = 2) filling of gaps at the border and smooth = FALSE. This is done to preserve the original values as much as possible (bilinear interpolation is involved when projecting from a 500 m resolution to a 100 m resolution in a different CRS). Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # pH_H2O ---- egv=downscale2egv( template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, grid_path = &quot;./Templates/TemplateGrids/tikls1km_sauzeme.parquet&quot;, rawfile_path = &quot;./Geodata/2024/Soils/ESDAC/chemistry/chemistry/pH_H2O/pH_H2O.tif&quot;, out_path = &quot;./RasterGrids_100m/2024/RAW/&quot;, file_name = &quot;SoilChemistry_ESDAC-phH2O_cell.tif&quot;, layer_name = &quot;egv_505&quot;, fill_gaps = TRUE, smooth = FALSE, plot_result = TRUE) egv # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilChemistry_ESDAC-phH2O_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.506 SoilTexture_Clay_cell filename: SoilTexture_Clay_cell.tif layername: egv_506 English name: Fractional cover of Clay Soils within the analysis cell (1 ha) Latvian name: Augsnes granulometriskās klases “māls” platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Soil texture product. First, the layer is reclassified so that the class of interest is 1 and the other classes are 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # input ---- combtext=rast(&quot;./RasterGrids_10m/2024/SoilTXT_combined.tif&quot;) # EGVs cell ---- # SoilTexture_Clay_cell.tif egv_506 clay10=ifel(combtext==3,1,0) input2egv(input=clay10, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;SoilTexture_Clay_cell.tif&quot;, layername=&quot;egv_506&quot;, return_visible = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Clay_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.507 SoilTexture_Clay_r500 filename: SoilTexture_Clay_r500.tif layername: egv_507 English name: Fractional cover of Clay Soils within the 0.5 km landscape Latvian name: Augsnes granulometriskās klases “māls” platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Clay&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Clay_r500.tif egv_507 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r500.tif&quot;) names(slanis)=&quot;egv_507&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Clay_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.508 SoilTexture_Clay_r1250 filename: SoilTexture_Clay_r1250.tif layername: egv_508 English name: Fractional cover of Clay Soils within the 1.25 km landscape Latvian name: Augsnes granulometriskās klases “māls” platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Clay&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Clay_r1250.tif egv_508 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r1250.tif&quot;) names(slanis)=&quot;egv_508&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Clay_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.509 SoilTexture_Clay_r3000 filename: SoilTexture_Clay_r3000.tif layername: egv_509 English name: Fractional cover of Clay Soils within the 3 km landscape Latvian name: Augsnes granulometriskās klases “māls” platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Clay&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Clay_r3000.tif egv_509 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r3000.tif&quot;) names(slanis)=&quot;egv_509&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Clay_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.510 SoilTexture_Clay_r10000 filename: SoilTexture_Clay_r10000.tif layername: egv_510 English name: Fractional cover of Clay Soils within the 10 km landscape Latvian name: Augsnes granulometriskās klases “māls” platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Clay&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Clay_r10000.tif egv_510 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r10000.tif&quot;) names(slanis)=&quot;egv_510&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Clay_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Clay_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.511 SoilTexture_Organic_cell filename: SoilTexture_Organic_cell.tif layername: egv_511 English name: Fractional cover of Organic Soils within the analysis cell (1 ha) Latvian name: Augsnes granulometriskās klases “organiskās augsnes” platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Soil texture product. First, the layer is reclassified so that the class of interest is 1 and the other classes are 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # input ---- combtext=rast(&quot;./RasterGrids_10m/2024/SoilTXT_combined.tif&quot;) # EGVs cell ---- # SoilTexture_Organic_cell.tif egv_511 org10=ifel(combtext==4,1,0) input2egv(input=org10, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;SoilTexture_Organic_cell.tif&quot;, layername=&quot;egv_511&quot;, return_visible = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Organic_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.512 SoilTexture_Organic_r500 filename: SoilTexture_Organic_r500.tif layername: egv_512 English name: Fractional cover of Organic Soils within the 0.5 km landscape Latvian name: Augsnes granulometriskās klases “organiskās augsnes” platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Organic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Organic_r500.tif egv_512 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r500.tif&quot;) names(slanis)=&quot;egv_512&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Organic_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.513 SoilTexture_Organic_r1250 filename: SoilTexture_Organic_r1250.tif layername: egv_513 English name: Fractional cover of Organic Soils within the 1.25 km landscape Latvian name: Augsnes granulometriskās klases “organiskās augsnes” platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Organic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Organic_r1250.tif egv_513 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r1250.tif&quot;) names(slanis)=&quot;egv_513&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Organic_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.514 SoilTexture_Organic_r3000 filename: SoilTexture_Organic_r3000.tif layername: egv_514 English name: Fractional cover of Organic Soils within the 3 km landscape Latvian name: Augsnes granulometriskās klases “organiskās augsnes” platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Organic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Organic_r3000.tif egv_514 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r3000.tif&quot;) names(slanis)=&quot;egv_514&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Organic_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.515 SoilTexture_Organic_r10000 filename: SoilTexture_Organic_r10000.tif layername: egv_515 English name: Fractional cover of Organic Soils within the 10 km landscape Latvian name: Augsnes granulometriskās klases “organiskās augsnes” platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Organic&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Organic_r10000.tif egv_515 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r10000.tif&quot;) names(slanis)=&quot;egv_515&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Organic_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Organic_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.516 SoilTexture_Sand_cell filename: SoilTexture_Sand_cell.tif layername: egv_516 English name: Fractional cover of Sand Soils within the analysis cell (1 ha) Latvian name: Augsnes granulometriskās klases “smilts” platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Soil texture product. First, the layer is reclassified so that the class of interest is 1 and the other classes are 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # input ---- combtext=rast(&quot;./RasterGrids_10m/2024/SoilTXT_combined.tif&quot;) # EGVs cell ---- # SoilTexture_Sand_cell.tif egv_516 sand10=ifel(combtext==1,1,0) plot(sand10) input2egv(input=sand10, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;SoilTexture_Sand_cell.tif&quot;, layername=&quot;egv_516&quot;, return_visible = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Sand_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.517 SoilTexture_Sand_r500 filename: SoilTexture_Sand_r500.tif layername: egv_517 English name: Fractional cover of Sand Soils within the 0.5 km landscape Latvian name: Augsnes granulometriskās klases “smilts” platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Sand&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Sand_r500.tif egv_517 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r500.tif&quot;) names(slanis)=&quot;egv_517&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Sand_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.518 SoilTexture_Sand_r1250 filename: SoilTexture_Sand_r1250.tif layername: egv_518 English name: Fractional cover of Sand Soils within the 1.25 km landscape Latvian name: Augsnes granulometriskās klases “smilts” platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Sand&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Sand_r1250.tif egv_518 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r1250.tif&quot;) names(slanis)=&quot;egv_518&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Sand_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.519 SoilTexture_Sand_r3000 filename: SoilTexture_Sand_r3000.tif layername: egv_519 English name: Fractional cover of Sand Soils within the 3 km landscape Latvian name: Augsnes granulometriskās klases “smilts” platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Sand&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Sand_r3000.tif egv_519 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r3000.tif&quot;) names(slanis)=&quot;egv_519&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Sand_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.520 SoilTexture_Sand_r10000 filename: SoilTexture_Sand_r10000.tif layername: egv_520 English name: Fractional cover of Sand Soils within the 10 km landscape Latvian name: Augsnes granulometriskās klases “smilts” platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Sand&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Sand_r10000.tif egv_520 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r10000.tif&quot;) names(slanis)=&quot;egv_520&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Sand_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Sand_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.521 SoilTexture_Silt_cell filename: SoilTexture_Silt_cell.tif layername: egv_521 English name: Fractional cover of Silt Soils within the analysis cell (1 ha) Latvian name: Augsnes granulometriskās klases “smilšmāls un mālsmilts” platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Soil texture product. First, the layer is reclassified so that the class of interest is 1 and the other classes are 0. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template10=rast(&quot;./Templates/TemplateRasters/LV10m_10km.tif&quot;) template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # input ---- combtext=rast(&quot;./RasterGrids_10m/2024/SoilTXT_combined.tif&quot;) # EGVs cell ---- # SoilTexture_Silt_cell.tif egv_521 silt10=ifel(combtext==2,1,0) input2egv(input=silt10, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;SoilTexture_Silt_cell.tif&quot;, layername=&quot;egv_521&quot;, return_visible = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Silt_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.522 SoilTexture_Silt_r500 filename: SoilTexture_Silt_r500.tif layername: egv_522 English name: Fractional cover of Silt Soils within the 0.5 km landscape Latvian name: Augsnes granulometriskās klases “smilšmāls un mālsmilts” platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Silt&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Silt_r500.tif egv_522 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r500.tif&quot;) names(slanis)=&quot;egv_522&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Silt_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.523 SoilTexture_Silt_r1250 filename: SoilTexture_Silt_r1250.tif layername: egv_523 English name: Fractional cover of Silt Soils within the 1.25 km landscape Latvian name: Augsnes granulometriskās klases “smilšmāls un mālsmilts” platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Silt&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Silt_r1250.tif egv_523 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r1250.tif&quot;) names(slanis)=&quot;egv_523&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Silt_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.524 SoilTexture_Silt_r3000 filename: SoilTexture_Silt_r3000.tif layername: egv_524 English name: Fractional cover of Silt Soils within the 3 km landscape Latvian name: Augsnes granulometriskās klases “smilšmāls un mālsmilts” platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Silt&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Silt_r3000.tif egv_524 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r3000.tif&quot;) names(slanis)=&quot;egv_524&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Silt_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.525 SoilTexture_Silt_r10000 filename: SoilTexture_Silt_r10000.tif layername: egv_525 English name: Fractional cover of Silt Soils within the 10 km landscape Latvian name: Augsnes granulometriskās klases “smilšmāls un mālsmilts” platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # EGVs radii ---- radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_cell.tif&quot;), layer_prefixes = c(&quot;SoilTexture_Silt&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # SoilTexture_Silt_r10000.tif egv_525 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r10000.tif&quot;) names(slanis)=&quot;egv_525&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/SoilTexture_Silt_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;SoilTexture_Silt_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.526 Terrain_ASL-average_cell filename: Terrain_ASL-average_cell.tif layername: egv_526 English name: Average value of height Above Sea Level (m) within the analysis cell (1 ha) Latvian name: Augstums virs jūras līmeņa (m) analīzes šūnā (1 ha) Procedure: Derived from the Digital elevation/terrain models. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_ASL-average_cell.tif egv_526 input2egv(input=&quot;./Geodata/2024/DEM/mozDEM_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_ASL-average_cell.tif&quot;, layername=&quot;egv_526&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_ASL-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.527 Terrain_Aspect-average_cell filename: Terrain_Aspect-average_cell.tif layername: egv_527 English name: Average value of Terrain Aspect (degree) within the analysis cell (1 ha) Latvian name: Nogāzes vidējais vērsuma virziens analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_Aspect-average_cell.tif egv_527 input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_Aspect-average_cell.tif&quot;, layername=&quot;egv_527&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_Aspect-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.528 Terrain_Aspect-iqr_cell filename: Terrain_Aspect-iqr_cell.tif layername: egv_528 English name: Variability of Terrain Aspect (degree) within the analysis cell (1 ha) Latvian name: Nogāzes vērsuma variabilitāte analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_Aspect-iqr_cell.tif egv_528 p25rez=input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_528&quot;, idw_weight = 2) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Aspect_udeni2_10m.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_528&quot;, idw_weight = 2) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/Terrain_Aspect-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_Aspect-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.529 Terrain_DiS-area_cell filename: Terrain_DiS-area_cell.tif layername: egv_529 English name: Fractional cover of Terrain Sinks within the analysis cell (1 ha) Latvian name: Reljefa depresiju bez virszemes noteces platības īpatsvars analīzes šūnā (1 ha) Procedure: Derived from the Terrain products depth-in-sinks layer, which is reclassified to a value of 1 in every cell with a positive value. The resulting layer is then aggregated to EGV resolution using the workflow egvtools::input2egv(), which calculates the arithmetic mean to determine the cover fraction. During aggregation, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_DiS-area_cell.tif egv_529 dis=rast(&quot;./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif&quot;) dis2=ifel(dis&gt;0,1,dis) input2egv(input=dis2, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_DiS-area_cell.tif&quot;, layername=&quot;egv_529&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-area_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.530 Terrain_DiS-area_r500 filename: Terrain_DiS-area_r500.tif layername: egv_530 English name: Fractional cover of Terrain Sinks within the 0.5 km landscape Latvian name: Reljefa depresiju bez virszemes noteces platības īpatsvars 0,5 km ainavā Procedure: The cover fraction within a radius of 500 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif&quot;), layer_prefixes = c(&quot;Terrain_DiS-area&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r500&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Terrain_DiS-area_r500.tif egv_530 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r500.tif&quot;) names(slanis)=&quot;egv_530&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r500.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-area_r500.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.531 Terrain_DiS-area_r1250 filename: Terrain_DiS-area_r1250.tif layername: egv_531 English name: Fractional cover of Terrain Sinks within the 1.25 km landscape Latvian name: Reljefa depresiju bez virszemes noteces platības īpatsvars 1,25 km ainavā Procedure: The cover fraction within a radius of 1250 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif&quot;), layer_prefixes = c(&quot;Terrain_DiS-area&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r1250&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Terrain_DiS-area_r1250.tif egv_531 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r1250.tif&quot;) names(slanis)=&quot;egv_531&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r1250.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-area_r1250.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.532 Terrain_DiS-area_r3000 filename: Terrain_DiS-area_r3000.tif layername: egv_532 English name: Fractional cover of Terrain Sinks within the 3 km landscape Latvian name: Reljefa depresiju bez virszemes noteces platības īpatsvars 3 km ainavā Procedure: The cover fraction within a radius of 3000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif&quot;), layer_prefixes = c(&quot;Terrain_DiS-area&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r3000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Terrain_DiS-area_r3000.tif egv_532 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r3000.tif&quot;) names(slanis)=&quot;egv_532&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r3000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-area_r3000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.533 Terrain_DiS-area_r10000 filename: Terrain_DiS-area_r10000.tif layername: egv_533 English name: Fractional cover of Terrain Sinks within the 10 km landscape Latvian name: Reljefa depresiju bez virszemes noteces platības īpatsvars 10 km ainavā Procedure: The cover fraction within a radius of 10000 m around the analysis grid cell is calculated as the area-weighted sum of the analysis cells inside the buffer, using the workflow egvtools::radius_function(). During the calculation of the landscape metric, inverse distance weighted (power = 2) gap filling on the output is applied to ensure no missing values at the edges. Then the layer is rewritten to set its name. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # radii radius_function( kvadrati_path = &quot;./Templates/TemplateGrids/tiles/&quot;, radii_path = &quot;./Templates/TemplateGridPoints/tiles/&quot;, tikls100_path = &quot;./Templates/TemplateGrids/tikls100_sauzeme.parquet&quot;, template_path = &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, input_layers = c(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_cell.tif&quot;), layer_prefixes = c(&quot;Terrain_DiS-area&quot;), output_dir = &quot;./RasterGrids_100m/2024/RAW/&quot;, n_workers = 5, radii = c(&quot;r10000&quot;), radius_mode = &quot;sparse&quot;, extract_fun = &quot;mean&quot;, fill_missing = TRUE, IDW_weight = 2, future_max_size = 5 * 1024^3) # Terrain_DiS-area_r10000.tif egv_533 slanis=rast(&quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r10000.tif&quot;) names(slanis)=&quot;egv_533&quot; slanis2=project(slanis,template100) writeRaster(slanis2, &quot;./RasterGrids_100m/2024/RAW/Terrain_DiS-area_r10000.tif&quot;, overwrite=TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-area_r10000.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.534 Terrain_DiS-max_cell filename: Terrain_DiS-max_cell.tif layername: egv_534 English name: Maximum Depth in Terrain Sink within the analysis cell (1 ha) Latvian name: Reljefa depresiju lielākais dziļums analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_DiS-max_cell.tif egv_534 input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;max&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_DiS-max_cell.tif&quot;, layername=&quot;egv_534&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-max_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.535 Terrain_DiS-mean_cell filename: Terrain_DiS-mean_cell.tif layername: egv_535 English name: Average Depth in Terrain Sink within the analysis cell (1 ha) Latvian name: Reljefa depresiju vidējais dziļums analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_DiS-mean_cell.tif egv_535 input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_DiS_udeni2_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_DiS-mean_cell.tif&quot;, layername=&quot;egv_535&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_DiS-mean_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.536 Terrain_Slope-average_cell filename: Terrain_Slope-average_cell.tif layername: egv_536 English name: Average value of Terrain Slope (degree) within the analysis cell (1 ha) Latvian name: Nogāzes slīpuma vidējā vērtība analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_Slope-average_cell.tif egv_536 input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_Slope-average_cell.tif&quot;, layername=&quot;egv_536&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_Slope-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.537 Terrain_Slope-iqr_cell filename: Terrain_Slope-iqr_cell.tif layername: egv_537 English name: Variability of Terrain Slope (degree) within the analysis cell (1 ha) Latvian name: Nogāzes slīpuma variabilitāte analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. The workflow egvtools::input2egv() is used to calculate Q1 and Q3 for every cell. To protect against potential data loss at the edges, inverse distance weighted (power = 2) gap filling is implemented. Next, Q1 is subtracted from Q3. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_Slope-iqr_cell.tif egv_537 p25rez=input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q1&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p25.tif&quot;, layername = &quot;egv_537&quot;, idw_weight = 2) p25rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) p75rez=input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_Slope_udeni2_10m.tif&quot;, egv_template= &quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;q3&quot;, missing_job = &quot;FillOutput&quot;, outlocation = &quot;./RasterGrids_100m/2024/&quot;, outfilename = &quot;draza_p75.tif&quot;, layername = &quot;egv_537&quot;, idw_weight = 2) p75rez_r=rast(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) iqr_rez=p75rez_r-p25rez_r iqr_rez plot(iqr_rez) writeRaster(iqr_rez, &quot;./RasterGrids_100m/2024/RAW/Terrain_Slope-iqr_cell.tif&quot;, overwrite=TRUE) unlink(&quot;./RasterGrids_100m/2024/draza_p75.tif&quot;) unlink(&quot;./RasterGrids_100m/2024/draza_p25.tif&quot;) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_Slope-iqr_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) 6.538 Terrain_TWI-average_cell filename: Terrain_TWI-average_cell.tif layername: egv_538 English name: Average value of Topographic Wetness Index (TWI) within the analysis cell (1 ha) Latvian name: Topogrāfiskā mitruma indeksa vidējā vērtība analīzes šūnā (1 ha) Procedure: Derived from the Terrain products. Processed using the workflow egvtools::input2egv(). Inverse distance weighted (power = 2) gap filling is implemented to protect against potential data loss at edge cells. Finally, the layer is standardised by subtracting the arithmetic mean and dividing by the root mean squared error. Code # libs ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(egvtools)) {remotes::install_github(&quot;aavotins/egvtools&quot;); require(egvtools)} # templates ---- template100=rast(&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;) # Terrain_TWI-average_cell.tif egv_538 input2egv(input=&quot;./RasterGrids_10m/2024/Terrain_TWI_udeni2_10m.tif&quot;, egv_template=&quot;./Templates/TemplateRasters/LV100m_10km.tif&quot;, summary_function = &quot;average&quot;, missing_job = &quot;FillOutput&quot;, idw_weight = 2, outlocation = &quot;./RasterGrids_100m/2024/RAW/&quot;, outfilename = &quot;Terrain_TWI-average_cell.tif&quot;, layername=&quot;egv_538&quot;, return_visible = TRUE, plot_final = TRUE) # standardisation ---- if(!require(terra)) {install.packages(&quot;terra&quot;); require(terra)} if(!require(tidyverse)) {install.packages(&quot;tidyverse&quot;); require(tidyverse)} nosaukums=&quot;Terrain_TWI-average_cell.tif&quot; ielasisanas_cels=paste0(&quot;./RasterGrids_100m/2024/RAW/&quot;,nosaukums) saglabasanas_cels=paste0(&quot;./RasterGrids_100m/2024/Scaled/&quot;,nosaukums) slanis=rast(ielasisanas_cels) videjais=global(slanis,fun=&quot;mean&quot;,na.rm=TRUE) centrets=slanis-videjais[,1] standartnovirze=terra::global(centrets,fun=&quot;rms&quot;,na.rm=TRUE) merogots=centrets/standartnovirze[,1] writeRaster(merogots, filename=saglabasanas_cels, overwrite=TRUE) "],["Ch07.html", "7 Data access", " 7 Data access When using code or data disclosed in this document, please cite our article and data repository: article reference repository reference Standardised ecogeographical variables are available for download from the project’s Zenodo repository. Layers can be interacted with via Google Earth Engine application. "],["references.html", "References", " References Brown, C.F., Brumby, S.P., Guzder-Williams, B., Birch, T., Hyde, S.B., Mazzariello, J., Czerwinski, W., Pasquarella, V.J., Haertel, R., Ilyushchenko, S., Schwehr, K., Weisse, M., Stolle, F., Hanson, C., Guinan, O., Moore, R., Tait, A.M., 2022. Dynamic World, Near real-time global 10 m land use land cover mapping. Scientific Data 9, 251. https://doi.org/10.1038/s41597-022-01307-4 Domisch, S., Amatulli, G., Jetz, W., 2015. Near-global freshwater-specific environmental variables for biodiversity analyses in 1 km resolution. Scientific Data 2:150073, 1–13. https://doi.org/10.1038/sdata.2015.73 Gorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., Moore, R., 2017. Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment 202, 18–27. https://doi.org/10.1016/j.rse.2017.06.031 Hansen, M.C., Potapov, P.V., Moore, R., Hancher, M., Turubanova, S.A., Tyukavina, A., Thau, D., Stehman, S.V., Goetz, S.J., Loveland, T.R., Kommareddy, A., Egorov, A., Chini, L., Justice, C.O., Townshend, J.R.G., 2013. High-resolution Global maps of 21st-century forest cover change. Science 342, 850–853. https://doi.org/10.1126/science.1244693 Hijmans, R.J., Cameron, S.E., Parra, J.L., Jones, P.G., Jarvis, A., 2005. Very high resolution interpolated climate surfaces for global land areas. International Journal of Climatology 25, 1965–1978. https://doi.org/10.1002/joc.1276 Karger, D.N., Conrad, O., Böhner, J., Kawohl, T., Kreft, H., Soria-Auza, R.W., Zimmermann, N.E., Linder, H.P., Kessler, M., 2017. Data Descriptor: Climatologies at high resolution for the earth’s land surface areas. Scientific Data 4:170122. https://doi.org/10.1038/sdata.2017.122 Lehner, B., Grill, G., 2013. Global river hydrography and network routing: Baseline data and new approaches to study the world’s large river systems. Hydrological Processes 27, 2171–2186. https://doi.org/10.1002/hyp.9740 Lehner, B., Verdin, K., Jarvis, A., 2008. New global hydrography derived from spaceborne elevation data. Eos, Transactions, American Geophysical Union 89, 93–94. https://doi.org/10.1029/2008EO100001 Panagos, P., Liedekerke, M.V., Borrelli, P., Köninger, J., Ballabio, C., Orgiazzi, A., Lugato, E., Liakos, L., Hervas, J., Jones, A., Montanarella, L., 2022. European Soil Data Centre 2.0: Soil data and knowledge in support of the EU policies. European Journal of Soil Science 73, e13315. https://doi.org/10.1111/ejss.13315 Shimada, M., Itoh, T., Motooka, T., Watanabe, M., Shiraishi, T., Thapa, R., Lucas, R., 2013. New global forest/non-forest maps from ALOS PALSAR data (2007–2010). Remote Sensing of Environment 155, 13–31. https://doi.org/10.1016/j.rse.2014.04.014 Wang, L., Liu, H., 2006. An efficient method for identifying and filling surface depressions in digital elevation models for hydrologic analysis and modelling. International Journal of Geographical Information Science 20, 193–213. https://doi.org/10.1080/13658810500433453 "]]
